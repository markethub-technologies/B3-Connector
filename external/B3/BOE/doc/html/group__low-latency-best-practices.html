<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.8.11"/>
    <title>OnixS C++ B3 BOE Binary Order Entry: Low Latency Best Practices</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="onixs-doxygen.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript">
    $(window).scroll(function() {
        if ($(this).scrollTop() > 1)
        {
            $('header').addClass("sticky");
        }
        else
        {
            $('header').removeClass("sticky");
        }
    });
    </script>
</head>
<body>
<header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
<tbody>
    <tr style="height: 56px;">
        <td id="projectlogo"><a href="http://www.onixs.biz"><img alt="Logo" src="onixs.svg"/></a></td>
        <td style="padding-left: 0.5em;">
            <div id="projectname">OnixS C++ B3 BOE Binary Order Entry
            &#160;<span id="projectnumber">1.3.0</span>
            </div>
            <div id="projectbrief">API Documentation</div>
        </td>
    </tr>
</tbody>
</table>
</div>
</header>
<div id="wrapper">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="modules.html"><span>Contents</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Low Latency Best Practices<div class="ingroups"><a class="el" href="group__best-practices.html">Best Practices</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<h1><a class="anchor" id="hardware-and-middleware"></a>
Hardware and Middleware</h1>
<p>One of the most efficient ways to reduce the latency is to use specialized network cards (e.g., <a href="https://www.solarflare.com">Solarflare</a>), and user-space TCP stack implementations (e.g., <a href="https://www.openonload.org/">Onload</a>).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__understanding-send-latency.html">Understanding Send Latency</a> </dd>
<dd>
<a class="el" href="group__solarflare-specific-features.html">Solarflare-specific Features</a></dd></dl>
<h1><a class="anchor" id="selecting-session-storage"></a>
Selecting Session Storage</h1>
<p>Using <a class="el" href="structOnixS_1_1B3_1_1BOE_1_1SessionStorageType.html#a8150b7776c2a1749101acf22e868d091a9dfbd06c6ba5e0c497070593d788a8bc" title="Memory-based Session Storage. ">OnixS::B3::BOE::SessionStorageType::MemoryBased</a> instead of <a class="el" href="structOnixS_1_1B3_1_1BOE_1_1SessionStorageType.html#a8150b7776c2a1749101acf22e868d091a21eaeabd5a9a18b8ab8f4991ce640488" title="File-based Session Storage. ">OnixS::B3::BOE::SessionStorageType::FileBased</a> boosts performance, since SBE messages are stored directly in memory.</p>
<p>Alternatively, it's possible to use pluggable storage ( <a class="el" href="structOnixS_1_1B3_1_1BOE_1_1SessionStorageType.html#a8150b7776c2a1749101acf22e868d091a6036fffe85c7c224f06cb0bb8a27a1e0" title="Pluggable Session Storage. ">OnixS::B3::BOE::SessionStorageType::Pluggable</a> ) that does nothing on message-related operations.</p>
<p>You can also use the <a class="el" href="group__asynchronous-file-based-session-storage.html">Asynchronous File-Based Session Storage</a> if you need to keep the file-based storage functionality and excellent performance.</p>
<h1><a class="anchor" id="threads-tuning"></a>
Threads Tuning</h1>
<h2><a class="anchor" id="affinity"></a>
Affinity</h2>
<p>By default, <a class="el" href="group__threading-models.html">session threads</a> can be executed on any of the available processors/cores. Specifying CPU affinity for each thread may give a significant performance boost: </p><div class="fragment"><div class="line"><a class="code" href="namespaceOnixS_1_1B3_1_1BOE.html#a9d1eb7296d93291b4869c33fb235a65c">CpuIndexes</a> receivingCpuIndexes;</div><div class="line"><a class="code" href="namespaceOnixS_1_1B3_1_1BOE.html#a9d1eb7296d93291b4869c33fb235a65c">CpuIndexes</a> sendingCpuIndexes;</div><div class="line"></div><div class="line">receivingCpuIndexes.insert(1);</div><div class="line">sendingCpuIndexes.insert(2);</div><div class="line"></div><div class="line"><span class="comment">// The Handler tries to send an outgoing application-level message in the context</span></div><div class="line"><span class="comment">// of the thread that calls the OnixS::B3::BOE::Session::send method.</span></div><div class="line">Threading::ThisThread::affinity(sendingCpuIndexes);</div><div class="line"></div><div class="line">session.receivingThreadAffinity(receivingCpuIndexes);</div><div class="line"></div><div class="line"><span class="comment">// If the message cannot be sent immediately, then it is saved to the queue</span></div><div class="line"><span class="comment">// for the subsequent sending by the sending thread.</span></div><div class="line">session.sendingThreadAffinity(sendingCpuIndexes);</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Ideally, each spinning thread should run on a separate CPU core so that it will not stop other important threads from doing work if it blocks or is de-scheduled. </dd>
<dd>
If more than one spinning thread shares the same CPU core, it could significantly increase jitter.</dd></dl>
<h2><a class="anchor" id="priority"></a>
Priority</h2>
<p>To modify threads prioritis, use the <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Threading_1_1ThisThread.html#a02436220f34292c14c5a00cfa1b0e3b4" title="Sets the priority for the current thread. ">OnixS::B3::BOE::Threading::ThisThread::priority</a>, <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Session.html#a7947ffca5902357e828cbda341b67c92">OnixS::B3::BOE::Session::receivingThreadPriority</a>, and <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Session.html#aaa7ccd1999df65839bdc3e538ed81c7d">OnixS::B3::BOE::Session::sendingThreadPriority</a> methods.</p>
<h2><a class="anchor" id="scheduling-policy"></a>
Scheduling Policy</h2>
<p>To modify threads scheduling policies, use the <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Threading_1_1ThisThread.html#a5d27d76009d72743ddc10e87b922364d" title="Sets the scheduling policy for the current thread. ">OnixS::B3::BOE::Threading::ThisThread::policy</a>, <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Session.html#a84af9d7f01870df90245847d1a3bb782">OnixS::B3::BOE::Session::receivingThreadPolicy</a>, and <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Session.html#ab411ce1090d4b789dc191dcd20ab30e1" title="Sets the sending thread policy. ">OnixS::B3::BOE::Session::sendingThreadPolicy</a> methods.</p>
<dl class="section note"><dt>Note</dt><dd>These methods are supported on Linux only. </dd>
<dd>
<code>SCHED_FIFO</code> and <code>SCHED_RR</code> scheduling policies implement the fixed-priority real-time scheduling, so threads with these policies preempt every other thread, which can go into starvation.</dd></dl>
<h1><a class="anchor" id="spinning"></a>
Spinning (busy-wait)</h1>
<dl class="section note"><dt>Note</dt><dd>The user-space TCP stack spinning is usually more efficient than the built-in spinning (e.g., <a href="https://www.openonload.org/">Onload's</a> <code>EF_POLL_USEC</code> environment variable or the <code>latency-best</code> profile).</dd></dl>
<h2><a class="anchor" id="receive-spinning-timeout"></a>
Receive Spinning Timeout</h2>
<p>When a session receiving thread attempts to read from a network and no incoming messages are available, the thread will enter the OS kernel and block (so-called "blocking wait" mode). When an incoming message becomes available, the network adapter will interrupt the CPU, allowing the OS kernel to reschedule the thread to continue.</p>
<p>Blocking, interrupts, and thread context switches are relatively expensive operations and can negatively affect the latency.</p>
<p>The session can be configured to spin on the processor in user mode for up to a specified number of microseconds waiting for messages from the network using the <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Session.html#a7a32e7bc92c0d76a29b0ac58de9d8692">OnixS::B3::BOE::Session::receiveSpinningTimeout</a> method. If the spin period expires, the session will revert to normal blocking behavior.</p>
<p><a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Session.html#a7a32e7bc92c0d76a29b0ac58de9d8692">OnixS::B3::BOE::Session::receiveSpinningTimeout</a> usage makes sense when the session receives SBE messages frequently, in this case, waiting in the loop is cheaper than the thread context switch to the "blocking wait" mode.</p>
<dl class="section note"><dt>Note</dt><dd>The spin wait increases the CPU usage, so the spin wait period should not be too long.</dd></dl>
<h2><a class="anchor" id="send-spinning-timeout"></a>
Send Spinning Timeout</h2>
<p>The <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Session.html#ae70ed24fc79d4d2f1028910e2bd11678">OnixS::B3::BOE::Session::sendSpinningTimeout</a> method can be used to decrease the latency of the message sending.</p>
<p>If the value is zero (by default) and the outgoing message cannot be sent immediately, it is saved to the outgoing queue. If the value greater than zero, the <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Session.html#ad244c9903b4d4aea32acf60905cd8536" title="Sends the message. ">OnixS::B3::BOE::Session::send</a> method waits for the socket sending buffer availability in the spin loop mode before placing the message to the outgoing queue (to be sent later by the sending thread).</p>
<p><a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Session.html#ae70ed24fc79d4d2f1028910e2bd11678">OnixS::B3::BOE::Session::sendSpinningTimeout</a> usage makes sense when the session sends SBE messages frequently, in this case, waiting in the loop is cheaper than the thread context switch.</p>
<dl class="section note"><dt>Note</dt><dd>The spin wait increases the CPU usage, so the spin wait period should not be too long.</dd></dl>
<h1><a class="anchor" id="session-warmup"></a>
Warmup</h1>
<p>If the session sends SBE messages infrequently, the sending path and associated data structures will not be in a cache, and this can increase the message sending latency.</p>
<p>One can periodically (a recommended interval is <code>500</code> microseconds or less) call the <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Session.html#a80e73ea445447edb4e6952a0304d28f3" title="Warms up the sending path. ">OnixS::B3::BOE::Session::warmUp</a> to avoid cache misses and keep the sending path fast.</p>
<h1><a class="anchor" id="using-session-send-batch"></a>
Using session send batch</h1>
<p>The <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Session.html#ad244c9903b4d4aea32acf60905cd8536" title="Sends the message. ">OnixS::B3::BOE::Session::send</a> method can be used to send messages in a batch. It can decrease the send latency because all batch messages will be sent in one TCP packet. The <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Messaging_1_1MessageBatch.html" title="The message batch wrapper. ">OnixS::B3::BOE::Messaging::MessageBatch</a> class represents the message batch. This class instance should be created in advance on the non-critical path, and required messages should be added. After that, one can send the batch on the critical path:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#if defined (ONIXS_B3_BOE_CXX11)</span></div><div class="line"><span class="comment">// Create the MessageBatch object on the non-critical path.</span></div><div class="line">MessageBatch&lt;NewOrderSingle102&gt; batch;</div><div class="line"><span class="comment">// Add messages to the batch.</span></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> messageCounter = 0; messageCounter &lt; 10; ++messageCounter)</div><div class="line">    batch.add(createOrder());</div><div class="line"><span class="comment">// Updates headers to be ready for sending.</span></div><div class="line">batch.updateHeaders();</div><div class="line"></div><div class="line"><span class="comment">// Check the batch fits a single packet</span></div><div class="line">assert(MessageBatchChecker::fitSize(batch));</div><div class="line"></div><div class="line"><span class="comment">// On the critical path one can update field values in the batch and send messages to the wire.</span></div><div class="line">batch[0]-&gt;setOrderQty(10);</div><div class="line">session.send(batch);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="comment">// The batch send is not supported on this platform.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p> Also, there is the <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Messaging_1_1MessageBatchCombiner.html" title="The class can be used to combine messages with different types to the batch for sending. ">OnixS::B3::BOE::Messaging::MessageBatchCombiner</a> class, which can be used when one needs to send messages with different types in the batch. It can combine different <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Messaging_1_1MessageBatch.html" title="The message batch wrapper. ">OnixS::B3::BOE::Messaging::MessageBatch</a> or <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Messaging_1_1MessageHolder.html" title="Contains the SimpleOpenFramingHeader, the SBE message, and the data buffer. ">OnixS::B3::BOE::Messaging::MessageHolder</a> instances. </p><dl class="section warning"><dt>Warning</dt><dd>It does not copy combined messages and does not store them internally. Therefore, the lifetime of combined messages should be greater or equal to the lifetime of this class instance:</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#if defined (ONIXS_B3_BOE_CXX11)</span></div><div class="line"><span class="comment">// Create MessageBatch objects with different message types on the non-critical path.</span></div><div class="line">MessageBatch&lt;NewOrderSingle102&gt; orderBatch;</div><div class="line">MessageBatch&lt;OrderCancelRequest105&gt; orderCancelBatch;</div><div class="line"><span class="comment">// Add messages to batches.</span></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> messageCounter = 0; messageCounter &lt; 10; ++messageCounter)</div><div class="line">    orderBatch.add(createOrder());</div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> messageCounter = 0; messageCounter &lt; 5; ++messageCounter)</div><div class="line">    orderCancelBatch.add(createOrderCancel());</div><div class="line"><span class="comment">// Updates headers to be ready for sending.</span></div><div class="line">orderBatch.updateHeaders();</div><div class="line">orderCancelBatch.updateHeaders();</div><div class="line"></div><div class="line"><span class="comment">// Combine batches with different message types.</span></div><div class="line">MessageBatchCombiner combiner;</div><div class="line"></div><div class="line">combiner.add(orderBatch);</div><div class="line">combiner.add(orderCancelBatch);</div><div class="line"></div><div class="line"><span class="comment">// One can combine a single message also.</span></div><div class="line">MessageHolder&lt;NewOrderSingle102&gt; order;</div><div class="line">combiner.add(order);</div><div class="line"></div><div class="line"><span class="comment">// Check the batch fits a single packet</span></div><div class="line">assert(MessageBatchChecker::fitSize(combiner));</div><div class="line"></div><div class="line"><span class="comment">// On the critical path one can update field values in batches and send all combined messages to the wire.</span></div><div class="line">orderBatch[0]-&gt;setOrderQty(10);</div><div class="line">orderCancelBatch[0]-&gt;setOrderId(123);</div><div class="line"></div><div class="line">session.send(combiner);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="comment">// The batch send is not supported on this platform.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Session.html#a05b3c194b5c410fab9b80841952ca85a">OnixS::B3::BOE::Session::messageGrouping</a> setting conflicts with the usage of the session send batch and can affect it. For the batch sending, the session uses the "gathering" socket <code>send</code> system call, which accepts an array of buffers to send all of them at once. When one sets the <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Session.html#a05b3c194b5c410fab9b80841952ca85a">OnixS::B3::BOE::Session::messageGrouping</a> setting, the session tries to combine (copy) outgoing messages (when available) to the one outgoing buffer until the given grouping value is achieved and then uses the regular socket <code>send</code> system call for sending. Therefore, one should not use the <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Session.html#a05b3c194b5c410fab9b80841952ca85a">OnixS::B3::BOE::Session::messageGrouping</a> option and batch sending simultaneously.</dd></dl>
<h1><a class="anchor" id="logging-after-sending"></a>
Logging After Sending</h1>
<p>By default, the logging of an outgoing message to the session storage is performed before sending it to the wire. This approach is more reliable because the outgoing message is stored before going to the counterparty. However, this approach adds the logging latency to the message sending latency, so it increases the tick-to-trade latency.</p>
<p>When the latency is more important, one can switch off the logging before sending, by setting the <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Session.html#a86aa269a28d49592694dcda8dda87c4a">OnixS::B3::BOE::Session::logBeforeSending</a> option to <code>false</code>. In this case, the logging of outgoing messages to the session storage will be performed after sending them to the wire.</p>
<h1><a class="anchor" id="reusing-sbe-message-instance"></a>
Reusing Message Instances</h1>
<p>A common strategy is to use the same outgoing application-level message instance multiple times.</p>
<h1><a class="anchor" id="sending-time"></a>
Sending time</h1>
<p>The BOE protocol requires the <code>timestamp</code> field to be filled with "the number of nanoseconds since Unix epoch" for each outgoing message. This is done automatically by the session when <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Session.html#ad244c9903b4d4aea32acf60905cd8536" title="Sends the message. ">OnixS::B3::BOE::Session::send</a> is invoked.</p>
<p>The current time value is provided as an argument of <a class="el" href="classOnixS_1_1B3_1_1BOE_1_1Session.html#ad244c9903b4d4aea32acf60905cd8536" title="Sends the message. ">OnixS::B3::BOE::Session::send</a>; this argument has the default value of the current system time being calculated at the invocation time.</p>
<p>The latency of taking system time can be avoided if it is requested before the call is made, for instance, at the warm-up stage. Also, when the session is used with the <a class="el" href="namespaceOnixS.html">OnixS</a> C++ B3 Market Data Handler, this value can be taken from the network packet receiving time.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__benchmark-sample.html">Benchmark Sample</a> </dd>
<dd>
<a class="el" href="group__tcp-direct-benchmark-sample.html">TCPDirect Benchmark Sample</a> </dd>
<dd>
<a class="el" href="group__tcp-standard-benchmark-sample.html">TCPStandard Benchmark Sample</a> </dd></dl>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<footer>
<hr class="footer"/>
<address class="footer">
    <small>&copy; <a href="http://www.onixs.biz">Onix Solutions [On<span class="corporate-orange">i</span>x<span class="corporate-orange">S</span>]</a>. All rights reserved.</small>
</address>
</footer>
</div> <!-- wrapper -->
</body>
</html>
