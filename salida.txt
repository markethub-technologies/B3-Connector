
===== FILE: ./build/md/CMakeFiles/3.28.3/CompilerIdCXX/CMakeCXXCompilerId.cpp =====
/* This source file must have a .cpp extension so that all C++ compilers
   recognize the extension without flags.  Borland does not know .cxx for
   example.  */
#ifndef __cplusplus
# error "A C compiler has been selected for C++."
#endif

#if !defined(__has_include)
/* If the compiler does not have __has_include, pretend the answer is
   always no.  */
#  define __has_include(x) 0
#endif


/* Version number components: V=Version, R=Revision, P=Patch
   Version date components:   YYYY=Year, MM=Month,   DD=Day  */

#if defined(__COMO__)
# define COMPILER_ID "Comeau"
  /* __COMO_VERSION__ = VRR */
# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)
# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)

#elif defined(__INTEL_COMPILER) || defined(__ICC)
# define COMPILER_ID "Intel"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# if defined(__GNUC__)
#  define SIMULATE_ID "GNU"
# endif
  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
     except that a few beta releases use the old format with V=2021.  */
# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
#  if defined(__INTEL_COMPILER_UPDATE)
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
#  else
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
#  endif
# else
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)
   /* The third version component from --version is an update index,
      but no macro is provided for it.  */
#  define COMPILER_VERSION_PATCH DEC(0)
# endif
# if defined(__INTEL_COMPILER_BUILD_DATE)
   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
# endif
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# if defined(__GNUC__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
# elif defined(__GNUG__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)
# define COMPILER_ID "IntelLLVM"
#if defined(_MSC_VER)
# define SIMULATE_ID "MSVC"
#endif
#if defined(__GNUC__)
# define SIMULATE_ID "GNU"
#endif
/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and
 * later.  Look for 6 digit vs. 8 digit version number to decide encoding.
 * VVVV is no smaller than the current year when a version is released.
 */
#if __INTEL_LLVM_COMPILER < 1000000L
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)
#else
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)
#endif
#if defined(_MSC_VER)
  /* _MSC_VER = VVRR */
# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
#endif
#if defined(__GNUC__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#elif defined(__GNUG__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
#endif

===== FILE: ./build/CMakeFiles/3.28.3/CompilerIdCXX/CMakeCXXCompilerId.cpp =====
/* This source file must have a .cpp extension so that all C++ compilers
   recognize the extension without flags.  Borland does not know .cxx for
   example.  */
#ifndef __cplusplus
# error "A C compiler has been selected for C++."
#endif

#if !defined(__has_include)
/* If the compiler does not have __has_include, pretend the answer is
   always no.  */
#  define __has_include(x) 0
#endif


/* Version number components: V=Version, R=Revision, P=Patch
   Version date components:   YYYY=Year, MM=Month,   DD=Day  */

#if defined(__COMO__)
# define COMPILER_ID "Comeau"
  /* __COMO_VERSION__ = VRR */
# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)
# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)

#elif defined(__INTEL_COMPILER) || defined(__ICC)
# define COMPILER_ID "Intel"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# if defined(__GNUC__)
#  define SIMULATE_ID "GNU"
# endif
  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
     except that a few beta releases use the old format with V=2021.  */
# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
#  if defined(__INTEL_COMPILER_UPDATE)
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
#  else
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
#  endif
# else
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)
   /* The third version component from --version is an update index,
      but no macro is provided for it.  */
#  define COMPILER_VERSION_PATCH DEC(0)
# endif
# if defined(__INTEL_COMPILER_BUILD_DATE)
   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
# endif
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# if defined(__GNUC__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
# elif defined(__GNUG__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)
# define COMPILER_ID "IntelLLVM"
#if defined(_MSC_VER)
# define SIMULATE_ID "MSVC"
#endif
#if defined(__GNUC__)
# define SIMULATE_ID "GNU"
#endif
/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and
 * later.  Look for 6 digit vs. 8 digit version number to decide encoding.
 * VVVV is no smaller than the current year when a version is released.
 */
#if __INTEL_LLVM_COMPILER < 1000000L
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)
#else
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)
#endif
#if defined(_MSC_VER)
  /* _MSC_VER = VVRR */
# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
#endif
#if defined(__GNUC__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#elif defined(__GNUG__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
#endif

===== FILE: ./build/oe/CMakeFiles/3.28.3/CompilerIdCXX/CMakeCXXCompilerId.cpp =====
/* This source file must have a .cpp extension so that all C++ compilers
   recognize the extension without flags.  Borland does not know .cxx for
   example.  */
#ifndef __cplusplus
# error "A C compiler has been selected for C++."
#endif

#if !defined(__has_include)
/* If the compiler does not have __has_include, pretend the answer is
   always no.  */
#  define __has_include(x) 0
#endif


/* Version number components: V=Version, R=Revision, P=Patch
   Version date components:   YYYY=Year, MM=Month,   DD=Day  */

#if defined(__COMO__)
# define COMPILER_ID "Comeau"
  /* __COMO_VERSION__ = VRR */
# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)
# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)

#elif defined(__INTEL_COMPILER) || defined(__ICC)
# define COMPILER_ID "Intel"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# if defined(__GNUC__)
#  define SIMULATE_ID "GNU"
# endif
  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
     except that a few beta releases use the old format with V=2021.  */
# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
#  if defined(__INTEL_COMPILER_UPDATE)
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
#  else
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
#  endif
# else
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)
   /* The third version component from --version is an update index,
      but no macro is provided for it.  */
#  define COMPILER_VERSION_PATCH DEC(0)
# endif
# if defined(__INTEL_COMPILER_BUILD_DATE)
   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
# endif
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# if defined(__GNUC__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
# elif defined(__GNUG__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)
# define COMPILER_ID "IntelLLVM"
#if defined(_MSC_VER)
# define SIMULATE_ID "MSVC"
#endif
#if defined(__GNUC__)
# define SIMULATE_ID "GNU"
#endif
/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and
 * later.  Look for 6 digit vs. 8 digit version number to decide encoding.
 * VVVV is no smaller than the current year when a version is released.
 */
#if __INTEL_LLVM_COMPILER < 1000000L
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)
#else
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)
#endif
#if defined(_MSC_VER)
  /* _MSC_VER = VVRR */
# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
#endif
#if defined(__GNUC__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#elif defined(__GNUG__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
#endif

===== FILE: ./b3-md-connector/src/main.cpp =====
#include <OnixS/B3/MarketData/UMDF.h>

#include "core/MdPublishPipeline.hpp"
#include "core/MdPublishWorker.hpp"
#include "core/MarketDataEngine.hpp"
#include "onixs/OnixsOrderBookListener.hpp"

#include "mapping/MdSnapshotMapper.hpp"
#include "publishing/IMdPublisher.hpp"
#include "telemetry/LogEvent.hpp"

// TODO: reemplazar por tus implementaciones reales
#include "testsupport/FakePublisher.hpp"   // placeholder publisher
#include "telemetry/SpdlogLogPublisher.hpp"

#include <cstdint>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <unordered_map>
#include <vector>

using namespace OnixS::B3::MarketData::UMDF;

namespace {

// Config ultra simple: key=value por línea, ignora vacíos y #comentarios.
std::unordered_map<std::string, std::string> loadKeyValueFile(const std::string& path) {
    std::unordered_map<std::string, std::string> kv;

    std::ifstream in(path);
    if (!in.is_open()) {
        std::cerr << "[config] cannot open file: " << path << "\n";
        return kv;
    }

    std::string line;
    while (std::getline(in, line)) {
        // trim básico
        auto trim = [](std::string& s) {
            while (!s.empty() && (s.back() == ' ' || s.back() == '\r' || s.back() == '\n' || s.back() == '\t')) s.pop_back();
            size_t i = 0;
            while (i < s.size() && (s[i] == ' ' || s[i] == '\t')) ++i;
            if (i > 0) s.erase(0, i);
        };

        trim(line);
        if (line.empty()) continue;
        if (!line.empty() && line[0] == '#') continue;

        const auto eq = line.find('=');
        if (eq == std::string::npos) continue;

        std::string key = line.substr(0, eq);
        std::string val = line.substr(eq + 1);

        trim(key);
        trim(val);
        if (!key.empty()) kv[key] = val;
    }

    return kv;
}

std::string getOr(const std::unordered_map<std::string, std::string>& kv,
                  const std::string& key,
                  const std::string& def) {
    auto it = kv.find(key);
    return (it == kv.end()) ? def : it->second;
}

int getOrInt(const std::unordered_map<std::string, std::string>& kv,
             const std::string& key,
             int def) {
    auto it = kv.find(key);
    if (it == kv.end()) return def;
    try {
        return std::stoi(it->second);
    } catch (...) {
        return def;
    }
}

} // namespace

int main(int argc, char** argv) {
    const std::string configPath = (argc >= 2) ? argv[1] : "b3-md-connector.conf";
    const auto cfg = loadKeyValueFile(configPath);

    // -------------------------
    // Placeholders / defaults
    // -------------------------
    const std::string licenseDir       = getOr(cfg, "onixs.license_dir",       "./LICENSE_DIR_TODO");
    const std::string connectivityFile = getOr(cfg, "onixs.connectivity_file", "./CONNECTIVITY_TODO.xml");
    const int channel                  = getOrInt(cfg, "onixs.channel",        80);

    const std::string ifA              = getOr(cfg, "onixs.if_a", "");

===== FILE: ./b3-md-connector/src/telemetry/LogQueueSpsc.hpp =====
#pragma once
#include <atomic>
#include <cstddef>
#include <cstdint>
#include <type_traits>

namespace b3::md::telemetry {

template <typename T, size_t Capacity>
class LogQueueSpsc {
    static_assert(Capacity >= 2, "Capacity must be >= 2");
    static_assert(std::is_trivially_copyable_v<T>, "T must be trivially copyable");

public:
    bool try_push(const T& v) noexcept {
        const uint32_t t = tail_.load(std::memory_order_relaxed);
        const uint32_t next = inc(t);
        if (next == head_.load(std::memory_order_acquire)) return false; // full
        buffer_[t] = v;
        tail_.store(next, std::memory_order_release);
        return true;
    }

    bool try_pop(T& out) noexcept {
        const uint32_t h = head_.load(std::memory_order_relaxed);
        if (h == tail_.load(std::memory_order_acquire)) return false; // empty
        out = buffer_[h];
        head_.store(inc(h), std::memory_order_release);
        return true;
    }

private:
    static constexpr uint32_t inc(uint32_t v) noexcept {
        v++;
        if (v >= Capacity) v = 0;
        return v;
    }

    alignas(64) T buffer_[Capacity]{};
    alignas(64) std::atomic<uint32_t> head_{0};
    alignas(64) std::atomic<uint32_t> tail_{0};
};

} // namespace b3::md::telemetry

===== FILE: ./b3-md-connector/src/telemetry/SpdlogLogPublisher.hpp =====
#pragma once
#include "LogEvent.hpp"
#include "LogQueueSpsc.hpp"

#include <atomic>
#include <chrono>
#include <thread>

#include <spdlog/spdlog.h>

namespace b3::md::telemetry {

template <size_t Capacity>
class SpdlogLogPublisher {
public:
    SpdlogLogPublisher() = default;

    // Producer API (SPSC): call only from ONE producer thread (owner)
    bool try_publish(const LogEvent& e) noexcept {
        if (!queue_.try_push(e)) {
            dropped_.fetch_add(1, std::memory_order_relaxed);
            return false;
        }
        return true;
    }

    void start() {
        running_.store(true, std::memory_order_release);
        thread_ = std::thread([this] { this->run(); });
    }

    void stop() {
        running_.store(false, std::memory_order_release);
        if (thread_.joinable()) thread_.join();
    }

    uint64_t dropped() const noexcept {
        return dropped_.load(std::memory_order_relaxed);
    }

private:
    void run() noexcept {
        using namespace std::chrono_literals;

        auto nextDropReport = std::chrono::steady_clock::now() + 5s;
        uint64_t lastDropped = 0;

        LogEvent e{};
        while (running_.load(std::memory_order_acquire)) {
            bool didWork = false;

            while (queue_.try_pop(e)) {
                didWork = true;
                emit_to_spdlog(e);
            }

            const auto now = std::chrono::steady_clock::now();
            if (now >= nextDropReport) {
                const uint64_t d = dropped_.load(std::memory_order_relaxed);
                const uint64_t delta = d - lastDropped;
                lastDropped = d;
                nextDropReport = now + 5s;

                if (delta > 0) {
                    spdlog::warn("[telemetry] log queue saturated: dropped={} in last 5s", delta);
                }
            }

            if (!didWork) {
                std::this_thread::sleep_for(1ms);
            }
        }

        // Drain remaining events on shutdown
        while (queue_.try_pop(e)) {
            emit_to_spdlog(e);
        }
    }

    static const char* to_component(Component c) noexcept {
        switch (c) {
            case Component::Core:       return "core";
            case Component::Pipeline:   return "pipeline";
            case Component::Worker:     return "worker";
            case Component::Mapping:    return "mapping";
            case Component::Publishing: return "publishing";
            case Component::Adapter:    return "adapter";
            default:                    return "unknown";
        }
    }

    static const char* to_code(Code code) noexcept {
        switch (code) {
            case Code::Startup:         return "startup";
            case Code::Shutdown:        return "shutdown";
            case Code::HealthTick:      return "health_tick";
            case Code::Drops:           return "drops";
            case Code::QueueSaturated:  return "queue_saturated";
            case Code::WorkerException: return "worker_exception";
            case Code::PublishFailed:   return "publish_failed";

===== FILE: ./b3-md-connector/src/telemetry/LogEvent.hpp =====
#pragma once
#include <cstdint>
#include <type_traits>

namespace b3::md::telemetry {

enum class LogLevel : uint8_t { Health = 0, Info = 1, Error = 2 };

enum class Component : uint8_t {
    Core = 0, Pipeline = 1, Worker = 2, Mapping = 3, Publishing = 4, Adapter = 5
};

enum class Code : uint16_t {
    Startup = 1,
    Shutdown = 2,

    HealthTick = 10,
    Drops = 11,
    QueueSaturated = 12,

    WorkerException = 100,
    PublishFailed = 101,
    SerializeFailed = 102,
    Backpressured = 103,
};

struct LogEvent {
    uint64_t tsNs{0};

    LogLevel level{LogLevel::Info};
    Component component{Component::Core};
    Code code{Code::HealthTick};

    uint32_t instrumentId{0}; // 0 = n/a
    uint16_t shard{0};        // 0 = n/a
    uint16_t reserved{0};

    uint64_t arg0{0};
    uint64_t arg1{0};
};

static_assert(std::is_trivially_copyable_v<LogEvent>);
static_assert(std::is_trivially_destructible_v<LogEvent>);

} // namespace b3::md::telemetry

===== FILE: ./b3-md-connector/src/onixs/OnixOrderBookView.hpp =====
#pragma once

#include "../core/IOrderBookView.hpp"
#include "../core/BookSnapshot.hpp" // Level + kTopN (o el const que uses)

#include <OnixS/B3/MarketData/UMDF/OrderBook.h>

#include <algorithm>
#include <chrono>
#include <cstdint>
#include <type_traits>
#include <utility>

namespace b3::md::onixs {

class OnixsOrderBookView final : public b3::md::IOrderBookView {
public:
    explicit OnixsOrderBookView(const ::OnixS::B3::MarketData::UMDF::OrderBook& book) noexcept
        : book_(book) {}

    uint32_t instrumentId() const noexcept override {
        // SDK: InstrumentId es UInt64
        const auto iid64 = static_cast<uint64_t>(book_.instrumentId());
        return static_cast<uint32_t>(iid64); // asumimos entra en 32 bits (si no, subimos el tipo en core)
    }

    uint64_t exchangeTsNs() const noexcept override {
        // OrderBook no expone timestamp.
        // Fallback: monotonic now (sirve para detectar backlog/jitter, no latencia real exchange->publish).
        const auto now = std::chrono::steady_clock::now().time_since_epoch();
        return static_cast<uint64_t>(
            std::chrono::duration_cast<std::chrono::nanoseconds>(now).count()
        );
    }

    uint32_t bidCount() const noexcept override {
        const auto n = book_.bids().size();
        return clampToTopN(n);
    }

    uint32_t askCount() const noexcept override {
        const auto n = book_.asks().size();
        return clampToTopN(n);
    }

    b3::md::Level bidLevel(uint32_t i) const noexcept override {
        const auto r = book_.bids();
        const auto n = r.size();
        const auto top = clampToTopN(n);

        if (i >= top || n == 0) return b3::md::Level{};

        // bids() en header dice "ascending bid prices" => mejor bid al final
        const size_t idx = (n - 1) - static_cast<size_t>(i);
        return mapOrderToLevel(r[idx]);
    }

    b3::md::Level askLevel(uint32_t i) const noexcept override {
        const auto r = book_.asks();
        const auto n = r.size();
        const auto top = clampToTopN(n);

        if (i >= top || n == 0) return b3::md::Level{};

        // Asumimos mejor ask al principio (lo típico).
        // Si ves que asks() viene descending realmente, cambiá a: idx = (n - 1) - i
        const size_t idx = static_cast<size_t>(i);
        return mapOrderToLevel(r[idx]);
    }

private:
    static uint32_t clampToTopN(size_t n) noexcept {
        // si tu TopN está en otro lado, ajustá este nombre:
        constexpr size_t TopN = static_cast<size_t>(5);
        return static_cast<uint32_t>(std::min(n, TopN));
    }

    static b3::md::Level mapOrderToLevel(const ::OnixS::B3::MarketData::UMDF::Order& o) noexcept {
        b3::md::Level lv{};

        // ---- qty ----
        // SDK: Quantity = Int64
        using QtyFieldT = decltype(lv.qty);
        lv.qty = static_cast<QtyFieldT>(o.quantity());

        // ---- price ----
        // SDK: PriceOptional (4 decimals), marketOrder => isNull()
        const auto p = o.price();
        if (p.isNull()) {
            // market order: precio "sin valor"
            // mantenemos default 0
            return lv;
        }

        const auto mant = p.mantissa(); // entero con 4 decimales

        using PriceFieldT = decltype(lv.price);
        if constexpr (std::is_floating_point_v<PriceFieldT>) {
            // Guardamos como double/float en unidades reales
            lv.price = static_cast<PriceFieldT>(static_cast<double>(mant) / 10000.0);

===== FILE: ./b3-md-connector/src/onixs/OnixsOrdersSnapshotBuilder.hpp =====
#pragma once

#include "../core/OrdersSnapshot.hpp"

#include <cstddef>
#include <cstdint>
#include <chrono>

// OnixS
#include <OnixS/B3/MarketData/UMDF/OrderBook.h> // o el include correcto en tu entorno

namespace b3::md::onixs {

// Builder hot-path: copia una ventana acotada de órdenes (MBO) desde el OrderBook de OnixS.
// Reglas:
// - NO aloca
// - NO loguea
// - NO agrupa por niveles (eso se hace en worker)
// - saltea órdenes con precio null (market orders), porque no aportan a MBP por niveles de precio.
struct OnixsOrdersSnapshotBuilder final {
    using OrderBook = OnixS::B3::MarketData::UMDF::OrderBook;

    static inline void buildFromBook(const OrderBook& book, b3::md::OrdersSnapshot& out) noexcept {
        // Reset POD
        out = b3::md::OrdersSnapshot{};

        // Metadata base
        out.instrumentId = static_cast<uint32_t>(book.instrumentId());
        out.rptSeq       = static_cast<uint64_t>(book.lastRptSeq());
        out.channelSeq   = static_cast<uint64_t>(book.lastMessageSeqNumApplied());

        //TODO: tratar de meter el timestamp del exchange.
        using clock = std::chrono::system_clock;
        const auto now = clock::now().time_since_epoch();
        out.exchangeTsNs =
            static_cast<uint64_t>(
                std::chrono::duration_cast<std::chrono::nanoseconds>(now).count());

        // Copia bids (según header: bids() => ascending bid prices
        // TODO: el comentario del SDK parece raro, que viene al revés, validar en runtime, 
        {
            const auto bidsRange = book.bids();
            const size_t raw = bidsRange.size();
            out.bidCountRaw = static_cast<uint16_t>(raw > 0xFFFFu ? 0xFFFFu : raw);

            uint16_t copied = 0;
            bool truncated = false;

            // Recorremos y copiamos solo precios válidos hasta K
            for (size_t i = 0; i < raw; ++i) {
                const auto& ord = bidsRange[i];

                const auto px = ord.price();
                if (px.isNull()) {
                    // Market order: se saltea; no contribuye al agregado MBP por niveles de precio.
                    continue;
                }

                if (copied >= b3::md::OrdersSnapshot::K) {
                    truncated = true;
                    break;
                }

                out.bids[copied].priceMantissa = static_cast<int64_t>(px.mantissa());
                out.bids[copied].qty          = static_cast<int64_t>(ord.quantity());
                ++copied;
            }

            out.bidsCopied   = copied;
            out.bidTruncated = truncated ? 1 : 0;
        }

        // Copia asks
        {
            const auto asksRange = book.asks();
            const size_t raw = asksRange.size();
            out.askCountRaw = static_cast<uint16_t>(raw > 0xFFFFu ? 0xFFFFu : raw);

            uint16_t copied = 0;
            bool truncated = false;

            for (size_t i = 0; i < raw; ++i) {
                const auto& ord = asksRange[i];

                const auto px = ord.price();
                if (px.isNull()) {
                    // Market order: se saltea; no contribuye al agregado MBP por niveles de precio.
                    continue;
                }

                if (copied >= b3::md::OrdersSnapshot::K) {
                    truncated = true;
                    break;
                }

                out.asks[copied].priceMantissa = static_cast<int64_t>(px.mantissa());
                out.asks[copied].qty          = static_cast<int64_t>(ord.quantity());
                ++copied;
            }


===== FILE: ./b3-md-connector/src/onixs/OnixsOrderBookListener.hpp =====
#pragma once

#include "../core/MarketDataEngine.hpp"

#include <OnixS/B3/MarketData/UMDF/OrderBookListener.h>
#include <OnixS/B3/MarketData/UMDF/OrderBook.h>
#include <OnixS/B3/MarketData/UMDF/messaging/SbeMessage.h>

#include <atomic>
#include <cstdint>

namespace b3::md::onixs {

// Adapter: OnixS -> MarketDataEngine
class OnixsOrderBookListener final : public ::OnixS::B3::MarketData::UMDF::OrderBookListener {
public:
    explicit OnixsOrderBookListener(b3::md::MarketDataEngine& engine) noexcept
        : engine_(engine)
    {}

    OnixsOrderBookListener(const OnixsOrderBookListener&) = delete;
    OnixsOrderBookListener& operator=(const OnixsOrderBookListener&) = delete;

    void onOrderBookChanged(
        const ::OnixS::B3::MarketData::UMDF::OrderBook& /*book*/,
        const ::OnixS::B3::MarketData::UMDF::Messaging::SbeMessage /*message*/) override
    {
        // Por ahora no publicamos acá para evitar snapshots intermedios.
        //
        // TODO(B3): revisar si el SbeMessage trae exchange timestamp (o event time) y dónde.
        // Si existe, decidir cómo propagarlo sin heap ni mapas en hot path (ideal: usar onOrderBookUpdated
        // si el SDK expone el timestamp ahí; si no, estudiar estrategia).
        changedCount_.fetch_add(1, std::memory_order_relaxed);
    }

    void onOrderBookUpdated(const ::OnixS::B3::MarketData::UMDF::OrderBook& book) override {
        updatedCount_.fetch_add(1, std::memory_order_relaxed);
        engine_.onOrderBookUpdated(book);
    }

    void onOrderBookOutOfDate(const ::OnixS::B3::MarketData::UMDF::OrderBook& /*book*/) override {
        outOfDateCount_.fetch_add(1, std::memory_order_relaxed);
        // TODO(B3): emitir health/counter para marcar "books outdated" (sin bloquear).
    }

    uint64_t changedCount() const noexcept { return changedCount_.load(std::memory_order_relaxed); }
    uint64_t updatedCount() const noexcept { return updatedCount_.load(std::memory_order_relaxed); }
    uint64_t outOfDateCount() const noexcept { return outOfDateCount_.load(std::memory_order_relaxed); }

private:
    b3::md::MarketDataEngine& engine_;

    std::atomic<uint64_t> changedCount_{0};
    std::atomic<uint64_t> updatedCount_{0};
    std::atomic<uint64_t> outOfDateCount_{0};
};

} // namespace b3::md::onixs

===== FILE: ./b3-md-connector/src/b3-md-connector.conf =====
# OnixS
onixs.license_dir=./license
onixs.connectivity_file=./b3_connectivity.xml
onixs.channel=80
# onixs.if_a=eth0
# onixs.if_b=eth1

# MD
md.shards=4

===== FILE: ./b3-md-connector/src/publishing/IMdPublisher.hpp =====
#pragma once
#include <cstdint>
#include <string_view>

namespace b3::md {

class IMdPublisher {
public:
    virtual ~IMdPublisher() = default;
    virtual void publish(std::string_view topic,
                         const uint8_t* data,
                         size_t size) = 0;
};

} // namespace b3::md

===== FILE: ./b3-md-connector/src/core/MdPublishWorker.hpp =====
#pragma once

#include "SnapshotQueueSpsc.hpp"
#include "BookSnapshot.hpp"
#include "OrdersSnapshot.hpp" 
#include "MboToMbpAggregator.hpp"

#include "../mapping/MdSnapshotMapper.hpp" // BookSnapshot -> bytes
#include "../publishing/IMdPublisher.hpp"
#include "../telemetry/SpdlogLogPublisher.hpp"
#include "../telemetry/LogEvent.hpp"

#include <atomic>
#include <thread>
#include <string>

namespace b3::md {

class MdPublishWorker final {
public:
    static constexpr size_t kQueueCapacity    = 4096;
    static constexpr size_t kLogQueueCapacity = 1024;

    MdPublishWorker(uint32_t shardId,
                    MdSnapshotMapper& mapper,
                    IMdPublisher& publisher)
        : shardId_(shardId)
        , mapper_(mapper)
        , publisher_(publisher)
    {}

    MdPublishWorker(const MdPublishWorker&) = delete;
    MdPublishWorker& operator=(const MdPublishWorker&) = delete;

    void start() {
        bool expected = false;
        if (!running_.compare_exchange_strong(expected, true, std::memory_order_acq_rel)) {
            return; // idempotente
        }

        // Logger propio del worker (thread separado)
        logger_.start();

        drainOnStop_.store(true, std::memory_order_relaxed);
        thread_ = std::thread([this] { run(); });
    }

    void stop(bool drain = true) {
        drainOnStop_.store(drain, std::memory_order_relaxed);
        running_.store(false, std::memory_order_release);

        if (thread_.joinable()) {
            thread_.join();
        }

        // Drenar y detener logger al final
        logger_.stop();
    }

    // Hot path del pipeline->worker: SPSC, no throw, no alloc.
    bool tryEnqueue(const OrdersSnapshot& snapshot) noexcept {
        if (queue_.try_push(snapshot)) {
            enqueued_.fetch_add(1, std::memory_order_relaxed);
            return true;
        }

        dropped_.fetch_add(1, std::memory_order_relaxed);
        return false;
    }

    uint64_t enqueued()  const noexcept { return enqueued_.load(std::memory_order_relaxed); }
    uint64_t dropped()   const noexcept { return dropped_.load(std::memory_order_relaxed); }
    uint64_t published() const noexcept { return published_.load(std::memory_order_relaxed); }

private:
    void run() noexcept {
        OrdersSnapshot raw{};
        BookSnapshot   mbp{};        // Top-N agregado (MBP)
        std::string    outBuffer;
        outBuffer.reserve(512);

        auto publish_one = [&](const OrdersSnapshot& s) {
            // 1) Agregar MBO window -> MBP Top-N
            aggregateMboWindowToMbpTopN(s, mbp);

            // 2) Serializar y publicar
            outBuffer.clear();
            mapper_.mapAndSerialize(mbp, outBuffer);

            publisher_.publish(
                "b3.md.book",
                reinterpret_cast<const uint8_t*>(outBuffer.data()),
                outBuffer.size());

            published_.fetch_add(1, std::memory_order_relaxed);
        };

        while (running_.load(std::memory_order_acquire) ||
               (drainOnStop_.load(std::memory_order_relaxed) && queue_.size_approx() > 0)) {


===== FILE: ./b3-md-connector/src/core/IOrderBookView.hpp =====
#pragma once
#include <cstdint>

namespace b3::md {

struct Level {
    int64_t price{0};
    int64_t qty{0};
};

class IOrderBookView {
public:
    virtual ~IOrderBookView() = default;

    virtual uint32_t instrumentId() const noexcept = 0;
    virtual uint64_t exchangeTsNs() const noexcept = 0;

    virtual uint32_t bidCount() const noexcept = 0;
    virtual uint32_t askCount() const noexcept = 0;

    virtual Level bidLevel(uint32_t i) const noexcept = 0;
    virtual Level askLevel(uint32_t i) const noexcept = 0;
};

} // namespace b3::md

===== FILE: ./b3-md-connector/src/core/BookSnapshot.hpp =====
#pragma once
#include "IOrderBookView.hpp"   // o donde esté Level
#include <cstdint>
#include <type_traits>

namespace b3::md {

template<int N>
struct BookSnapshotT {
    static constexpr int DEPTH = N;

    uint32_t instrumentId{0};
    uint64_t exchangeTsNs{0};
    uint8_t bidCount{0};
    uint8_t askCount{0};

    Level bids[N]{};
    Level asks[N]{};
};

using BookSnapshot = BookSnapshotT<5>;

static_assert(std::is_trivially_copyable_v<BookSnapshot>);
static_assert(std::is_trivially_destructible_v<BookSnapshot>);

} // namespace b3::md

===== FILE: ./b3-md-connector/src/core/OrdersSnapshot.hpp =====
#pragma once

#include <cstdint>
#include <cstddef>
#include <type_traits>

namespace b3::md {

// Ventana acotada de órdenes (MBO) copiada en hot path.
// Se agrega (MBO->MBP) en el worker para generar BookSnapshot (niveles de precio).
//
// Nota: las órdenes con precio null (market orders) se SALTEAN al copiar,
// porque no contribuyen al agregado por niveles de precio (MBP).
struct OrdersSnapshot {
    static constexpr size_t K = 256;

    struct OrderEntry {  //todo:verificar prefision
        int64_t priceMantissa{0}; // precio con 4 decimales (mantissa) 
        int64_t qty{0};           // Quantity (Int64)
    };

    uint32_t instrumentId{0};
    uint64_t exchangeTsNs{0};

    // Secuencias del SDK (las copiamos para futuro/protobuf/health)
    uint64_t rptSeq{0};      // OrderBook::lastRptSeq()
    uint64_t channelSeq{0};  // OrderBook::lastMessageSeqNumApplied()

    // Tamaños "crudos" del libro (lo que expone el SDK, sin filtrar null-price)
    uint16_t bidCountRaw{0};
    uint16_t askCountRaw{0};

    // Cantidad efectiva copiada (solo órdenes con precio válido, hasta K)
    uint16_t bidsCopied{0};
    uint16_t asksCopied{0};

    // Flags: 1 si hubo más órdenes válidas que K y se truncó; 0 si entraron todas.
    uint8_t bidTruncated{0};
    uint8_t askTruncated{0};

    OrderEntry bids[K]{};
    OrderEntry asks[K]{};
};

static_assert(std::is_trivially_copyable_v<OrdersSnapshot>);
static_assert(std::is_trivially_destructible_v<OrdersSnapshot>);

} // namespace b3::md

===== FILE: ./b3-md-connector/src/core/MdPublishPipeline.hpp =====
#pragma once

#include "MdPublishWorker.hpp"
#include "OrdersSnapshot.hpp"

#include <cstdint>
#include <memory>
#include <vector>
#include <atomic>
#include <stdexcept>

namespace b3::md {

// Pipeline = orquestador de sharding + lifecycle de workers.
// NO crea threads en ctor. NO conoce IO. NO conoce OnixS.
// Enqueue único punto de entrada (hot path friendly).
class MdPublishPipeline final {
public:
    explicit MdPublishPipeline(std::vector<std::unique_ptr<MdPublishWorker>> workers)
        : workers_(std::move(workers))
    {
        if (workers_.empty()) {
            throw std::invalid_argument("MdPublishPipeline: workers empty");
        }
    }

    MdPublishPipeline(const MdPublishPipeline&) = delete;
    MdPublishPipeline& operator=(const MdPublishPipeline&) = delete;

    void start() {
        bool expected = false;
        if (!started_.compare_exchange_strong(expected, true, std::memory_order_acq_rel)) {
            return; // idempotente
        }
        for (auto& w : workers_) {
            w->start();
        }
    }

    void stop(bool drain = true) {
        bool expected = true;
        if (!started_.compare_exchange_strong(expected, false, std::memory_order_acq_rel)) {
            return; // idempotente
        }
        for (auto& w : workers_) {
            w->stop(drain);
        }
    }

    // Hot path: no throw, no alloc.
    // Devuelve false si se dropeó (cola llena).
    bool tryEnqueue(const OrdersSnapshot& snapshot) noexcept {
        const uint32_t shard = shardFor(snapshot.instrumentId);
        return workers_[shard]->tryEnqueue(snapshot);
    }

    uint32_t shardCount() const noexcept {
        return static_cast<uint32_t>(workers_.size());
    }

private:
    // Hash multiplicativo para mejorar distribución si instrumentId tiene patrones.
    static constexpr uint64_t kKnuth = 11400714819323198485ull;

    uint32_t shardFor(uint64_t instrumentId) const noexcept {
        const uint64_t mixed = instrumentId * kKnuth;
        return static_cast<uint32_t>(mixed % workers_.size());
    }

private:
    std::vector<std::unique_ptr<MdPublishWorker>> workers_;
    std::atomic<bool> started_{false};
};

} // namespace b3::md

===== FILE: ./b3-md-connector/src/core/MboToMbpAggregator.hpp =====
#pragma once

#include "OrdersSnapshot.hpp"
#include "BookSnapshot.hpp"
#include <cstdint>

namespace b3::md {

// Agrega órdenes (MBO) por precio para producir niveles (MBP Top-N).
// No aloca. No tira exceptions. Diseñado para ejecutarse en worker.
inline void aggregateMboWindowToMbpTopN(const OrdersSnapshot& in, BookSnapshot& out) noexcept {
    out.instrumentId = in.instrumentId;
    out.exchangeTsNs = in.exchangeTsNs;
    out.bidCount = 0;
    out.askCount = 0;

    // Limpieza explícita (por si Level no es trivially-zero-safe)
    for (int i = 0; i < BookSnapshot::DEPTH; ++i) {
        out.bids[i] = Level{};
        out.asks[i] = Level{};
    }

    auto add_level = [](Level* levels, uint8_t& count, int64_t priceMantissa, int64_t qty) noexcept {
        // Buscar si ya existe ese precio dentro de los niveles armados
        for (uint8_t i = 0; i < count; ++i) {
            // TODO, verificar la presicion cuando tenga la documentacion para evitar narrowing
            // típicamente Level::price es entero (mantissa) o algo compatible ṕero verificar. 20251222
            const auto existingPrice = static_cast<int64_t>(levels[i].price);
            if (existingPrice == priceMantissa) {
                levels[i].qty = static_cast<decltype(levels[i].qty)>(
                    static_cast<int64_t>(levels[i].qty) + qty
                );
                return;
            }
        }

        // Nuevo precio si todavía hay espacio
        if (count < BookSnapshot::DEPTH) {
            levels[count].price = static_cast<decltype(levels[count].price)>(priceMantissa);
            levels[count].qty   = static_cast<decltype(levels[count].qty)>(qty);
            ++count;
        }
    };

    // BID side
    {
        const uint16_t n = in.bidCountRaw;
        for (uint16_t i = 0; i < n && out.bidCount < BookSnapshot::DEPTH; ++i) {
            const auto& e = in.bids[i];
            if (e.qty == 0) continue;
            // market orders se saltean en el builder, así que priceMantissa==0 acá debería ser raro.
            if (e.priceMantissa == 0) continue;

            add_level(out.bids, out.bidCount, e.priceMantissa, e.qty);
        }
    }

    // ASK side
    {
        const uint16_t n = in.askCountRaw;
        for (uint16_t i = 0; i < n && out.askCount < BookSnapshot::DEPTH; ++i) {
            const auto& e = in.asks[i];
            if (e.qty == 0) continue;
            if (e.priceMantissa == 0) continue;

            add_level(out.asks, out.askCount, e.priceMantissa, e.qty);
        }
    }
}

} // namespace b3::md

===== FILE: ./b3-md-connector/src/core/MarketDataEngine.hpp =====
#pragma once

#include "MdPublishPipeline.hpp"
#include "IOrderBookView.hpp"
#include "OrdersSnapshot.hpp"

#include "../onixs/OnixsOrdersSnapshotBuilder.hpp"

#include <atomic>
#include <cstdint>

#include <OnixS/B3/MarketData/UMDF/OrderBook.h>

namespace b3::md {

class MarketDataEngine final {
public:
    explicit MarketDataEngine(MdPublishPipeline& pipeline)
        : pipeline_(pipeline)
    {}

    // Vive en el thread del feed (listener OnixS).
    // Construye OrdersSnapshot (ventana MBO) y encola al pipeline.
    void onOrderBookUpdated(const ::OnixS::B3::MarketData::UMDF::OrderBook& orderBook) noexcept {
        OrdersSnapshot snapshot{};
        b3::md::onixs::OnixsOrdersSnapshotBuilder::buildFromBook(orderBook, snapshot);

        if (!pipeline_.tryEnqueue(snapshot)) {
            drops_.fetch_add(1, std::memory_order_relaxed);
        }
    }

    uint64_t drops() const noexcept {
        return drops_.load(std::memory_order_relaxed);
    }

private:
    MdPublishPipeline& pipeline_;
    std::atomic<uint64_t> drops_{0};
};

} // namespace b3::md

===== FILE: ./b3-md-connector/src/core/SnapshotQueueSpsc.hpp =====
#pragma once
#include <atomic>
#include <cstddef>
#include <cstdint>
#include <memory>

namespace b3::md {

// FIFO SPSC ring buffer.
// Producer: 1 thread (pipeline/callback)
// Consumer: 1 thread (worker)
template <typename T, size_t CapacityPow2>
class SnapshotQueueSpsc {
    static_assert((CapacityPow2 & (CapacityPow2 - 1)) == 0, "Capacity must be power of two");

public:
    SnapshotQueueSpsc()
        : buffer_(std::make_unique<T[]>(CapacityPow2))
    {}

    bool try_push(const T& v) noexcept {
        const uint32_t t = tail_.load(std::memory_order_relaxed);
        const uint32_t h = head_.load(std::memory_order_acquire);

        if ((t - h) >= CapacityPow2) return false; // full

        buffer_[t & (CapacityPow2 - 1)] = v;
        tail_.store(t + 1, std::memory_order_release);
        return true;
    }

    bool try_pop(T& out) noexcept {
        const uint32_t h = head_.load(std::memory_order_relaxed);
        const uint32_t t = tail_.load(std::memory_order_acquire);

        if (h == t) return false; // empty

        out = buffer_[h & (CapacityPow2 - 1)];
        head_.store(h + 1, std::memory_order_release);
        return true;
    }

    uint32_t size_approx() const noexcept {
        const uint32_t h = head_.load(std::memory_order_acquire);
        const uint32_t t = tail_.load(std::memory_order_acquire);
        return t - h;
    }

private:
    alignas(64) std::atomic<uint32_t> head_{0};
    alignas(64) std::atomic<uint32_t> tail_{0};

    std::unique_ptr<T[]> buffer_;
};

} // namespace b3::md

===== FILE: ./b3-md-connector/src/testsupport/OrdersSnapshotFromMbpView.hpp =====
#pragma once

#include "../core/OrdersSnapshot.hpp"
#include "../core/IOrderBookView.hpp"

namespace b3::md::testsupport {

// Adapter MBP (niveles) -> OrdersSnapshot (ventana MBO fake)
// Uso exclusivo para tests.
// Cada nivel se copia como si fuera una "orden agregada".
inline OrdersSnapshot makeOrdersSnapshotFromMbpView(
    const IOrderBookView& book) noexcept
{
    OrdersSnapshot snapshot{};

    snapshot.instrumentId = book.instrumentId();
    snapshot.exchangeTsNs = book.exchangeTsNs();

    const uint32_t bidN = book.bidCount();
    const uint32_t askN = book.askCount();

    uint16_t writtenBid = 0;
    for (uint32_t i = 0;
         i < bidN && writtenBid < OrdersSnapshot::K;
         ++i)
    {
        const auto lv = book.bidLevel(i);
        snapshot.bids[writtenBid].priceMantissa = lv.price;
        snapshot.bids[writtenBid].qty = lv.qty;
        ++writtenBid;
    }

    snapshot.bidCountRaw = writtenBid;
    snapshot.bidTruncated = (bidN > OrdersSnapshot::K) ? 1u : 0u;

    uint16_t writtenAsk = 0;
    for (uint32_t i = 0;
         i < askN && writtenAsk < OrdersSnapshot::K;
         ++i)
    {
        const auto lv = book.askLevel(i);
        snapshot.asks[writtenAsk].priceMantissa = lv.price;
        snapshot.asks[writtenAsk].qty = lv.qty;
        ++writtenAsk;
    }

    snapshot.askCountRaw = writtenAsk;
    snapshot.askTruncated = (askN > OrdersSnapshot::K) ? 1u : 0u;

    return snapshot;
}

} // namespace b3::md::testsupport

===== FILE: ./b3-md-connector/src/testsupport/FakePublisher.hpp =====
#pragma once
#include "../publishing/IMdPublisher.hpp"
#include <mutex>
#include <string>
#include <vector>

namespace b3::md :: testsupport {

struct PublishedMessage {
    std::string topic;
    std::string bytes;
};

class FakePublisher final : public IMdPublisher {
public:
    void publish(std::string_view topic,
                 const uint8_t* data,
                 size_t size) override {
        std::lock_guard<std::mutex> g(m_);
        PublishedMessage m;
        m.topic.assign(topic.data(), topic.size());
        m.bytes.assign(reinterpret_cast<const char*>(data), size);
        msgs_.push_back(std::move(m));
    }

    size_t count() const {
        std::lock_guard<std::mutex> g(m_);
        return msgs_.size();
    }

    PublishedMessage at(size_t i) const {
        std::lock_guard<std::mutex> g(m_);
        return msgs_.at(i);
    }

private:
    mutable std::mutex m_;
    std::vector<PublishedMessage> msgs_;
};

} // namespace b3::md

===== FILE: ./b3-md-connector/src/mapping/MdSnapshotMapper.hpp =====
#pragma once
#include "../core/BookSnapshot.hpp"
#include <string>

namespace b3::md {

// Mapper puro: snapshot -> bytes
// (stub determinístico para tests; luego será Protobuf)
class MdSnapshotMapper {
public:
    void mapAndSerialize(const BookSnapshot& s,
                         std::string& out) const {
        out.clear();
        out.reserve(64);
        out.append("iid=");
        out.append(std::to_string(s.instrumentId));
        out.append(";ts=");
        out.append(std::to_string(s.exchangeTsNs));
        out.append(";bc=");
        out.append(std::to_string(s.bidCount));
        out.append(";ac=");
        out.append(std::to_string(s.askCount));
    }
};

} // namespace b3::md

===== FILE: ./b3-md-connector/src/MessagingLibIntegrationTest.cpp =====
#include "core/MarketDataEngine.hpp"
#include <clients/PublisherSubscriber.h>
#include <models/messages.pb.h>
#include <models/messageTypes.h>
#include <models/risk_management.pb.h>
#include <iostream>
#include <spdlog/spdlog.h>
//#include <OnixS/B3/MarketData/UMDF.h>
#include <thread>
#include <chrono>
#include <iomanip>
#include <sstream>
#include <atomic>

namespace {
    std::string GenerateSimpleUUID() {
        auto now = std::chrono::system_clock::now();
        auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
        std::stringstream ss;
        ss << "msg-" << ms << "-" << std::this_thread::get_id();
        return ss.str();
    }

    void SimpleLogger(const std::string &level, const std::string &message) {
        auto now = std::chrono::system_clock::now();
        auto time = std::chrono::system_clock::to_time_t(now);
        std::cout << "[" << std::put_time(std::localtime(&time), "%H:%M:%S") << "] "
                  << "[" << level << "] " << message << '\n';
    }
}

int main2() {
    // spdlog::info("=== B3 Market Data Connector Test ===");
    // spdlog::info("OnixS C++ B3 Binary UMDF Market Data Handler version {}",
    //              OnixS::B3::MarketData::UMDF::Handler::version());

    // Test configuration
    const std::string SERVER = "Risk01.byma.mkthub.int";
    int RISK_UAT[] = {5955, 5956, 5557};

    std::string REQ_ENDPOINT{"tcp://" + SERVER + ":" + std::to_string(RISK_UAT[0])};
    std::string RES_ENDPOINT{"tcp://" + SERVER + ":" + std::to_string(RISK_UAT[1])};
    std::string RT_ENDPOINT{"tcp://" + SERVER + ":" + std::to_string(RISK_UAT[2])};

    std::string clientId = "95515";
    std::atomic<int> clientResponsesReceived{0};

    // Create PublisherSubscriber client
    markethub::messaging::clients::PublisherSubscriber client(
        clientId,
        REQ_ENDPOINT,
        RES_ENDPOINT,
        SimpleLogger
    );

    // Setup message received callback
    client.SetMessageReceivedCallback([&](const markethub::messaging::WrapperMessage &response) {
        int count = ++clientResponsesReceived;
        std::stringstream ss;
        ss << "Response #" << count << ": " << response.ShortDebugString();
        SimpleLogger("Info", ss.str());
    });

    // Start client
    SimpleLogger("Info", "Starting CLIENT...");
    client.Start();
    SimpleLogger("Info", "CLIENT ready");

    std::cout << "\n=== Press ENTER to send PNL Report Request ===" << std::endl;
    std::string dummy;
    std::getline(std::cin, dummy);

    // Create and send PNL Report Request
    markethub::messaging::WrapperMessage msg;
    msg.set_message_id(GenerateSimpleUUID());
    msg.set_message_type(markethub::messaging::models::MessageTypes::PNLReportRequest);

    auto *pnl = msg.mutable_pnl_report_request();
    pnl->set_market("byma");
    pnl->set_account("10410");

    client.SendMessage(std::move(msg));
    SimpleLogger("Info", "PNL Report Request sent");

    std::cout << "\n=== Press ENTER to exit ===" << std::endl;
    std::getline(std::cin, dummy);

    SimpleLogger("Info", "Shutting down...");
    client.Stop();

    spdlog::info("Total responses received: {}", clientResponsesReceived.load());
    spdlog::info("Test completed successfully");

    return 0;
}

===== FILE: ./tests/md/build/CMakeFiles/3.28.3/CompilerIdCXX/CMakeCXXCompilerId.cpp =====
/* This source file must have a .cpp extension so that all C++ compilers
   recognize the extension without flags.  Borland does not know .cxx for
   example.  */
#ifndef __cplusplus
# error "A C compiler has been selected for C++."
#endif

#if !defined(__has_include)
/* If the compiler does not have __has_include, pretend the answer is
   always no.  */
#  define __has_include(x) 0
#endif


/* Version number components: V=Version, R=Revision, P=Patch
   Version date components:   YYYY=Year, MM=Month,   DD=Day  */

#if defined(__COMO__)
# define COMPILER_ID "Comeau"
  /* __COMO_VERSION__ = VRR */
# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)
# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)

#elif defined(__INTEL_COMPILER) || defined(__ICC)
# define COMPILER_ID "Intel"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# if defined(__GNUC__)
#  define SIMULATE_ID "GNU"
# endif
  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
     except that a few beta releases use the old format with V=2021.  */
# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
#  if defined(__INTEL_COMPILER_UPDATE)
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
#  else
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
#  endif
# else
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)
   /* The third version component from --version is an update index,
      but no macro is provided for it.  */
#  define COMPILER_VERSION_PATCH DEC(0)
# endif
# if defined(__INTEL_COMPILER_BUILD_DATE)
   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
# endif
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# if defined(__GNUC__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
# elif defined(__GNUG__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)
# define COMPILER_ID "IntelLLVM"
#if defined(_MSC_VER)
# define SIMULATE_ID "MSVC"
#endif
#if defined(__GNUC__)
# define SIMULATE_ID "GNU"
#endif
/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and
 * later.  Look for 6 digit vs. 8 digit version number to decide encoding.
 * VVVV is no smaller than the current year when a version is released.
 */
#if __INTEL_LLVM_COMPILER < 1000000L
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)
#else
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)
#endif
#if defined(_MSC_VER)
  /* _MSC_VER = VVRR */
# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
#endif
#if defined(__GNUC__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#elif defined(__GNUG__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
#endif

===== FILE: ./tests/md/build/_deps/googletest-src/googlemock/include/gmock/gmock-cardinalities.h =====
// Copyright 2007, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Google Mock - a framework for writing C++ mock classes.
//
// This file implements some commonly used cardinalities.  More
// cardinalities can be defined by the user implementing the
// CardinalityInterface interface if necessary.

// IWYU pragma: private, include "gmock/gmock.h"
// IWYU pragma: friend gmock/.*

#ifndef GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_CARDINALITIES_H_
#define GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_CARDINALITIES_H_

#include <limits.h>

#include <memory>
#include <ostream>  // NOLINT

#include "gmock/internal/gmock-port.h"
#include "gtest/gtest.h"

GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \
/* class A needs to have dll-interface to be used by clients of class B */)

namespace testing {

// To implement a cardinality Foo, define:
//   1. a class FooCardinality that implements the
//      CardinalityInterface interface, and
//   2. a factory function that creates a Cardinality object from a
//      const FooCardinality*.
//
// The two-level delegation design follows that of Matcher, providing
// consistency for extension developers.  It also eases ownership
// management as Cardinality objects can now be copied like plain values.

// The implementation of a cardinality.
class CardinalityInterface {
 public:
  virtual ~CardinalityInterface() = default;

  // Conservative estimate on the lower/upper bound of the number of
  // calls allowed.
  virtual int ConservativeLowerBound() const { return 0; }
  virtual int ConservativeUpperBound() const { return INT_MAX; }

  // Returns true if and only if call_count calls will satisfy this
  // cardinality.
  virtual bool IsSatisfiedByCallCount(int call_count) const = 0;

  // Returns true if and only if call_count calls will saturate this
  // cardinality.
  virtual bool IsSaturatedByCallCount(int call_count) const = 0;

  // Describes self to an ostream.
  virtual void DescribeTo(::std::ostream* os) const = 0;
};

// A Cardinality is a copyable and IMMUTABLE (except by assignment)
// object that specifies how many times a mock function is expected to
// be called.  The implementation of Cardinality is just a std::shared_ptr
// to const CardinalityInterface. Don't inherit from Cardinality!
class GTEST_API_ Cardinality {
 public:
  // Constructs a null cardinality.  Needed for storing Cardinality
  // objects in STL containers.
  Cardinality() = default;

  // Constructs a Cardinality from its implementation.
  explicit Cardinality(const CardinalityInterface* impl) : impl_(impl) {}

  // Conservative estimate on the lower/upper bound of the number of

===== FILE: ./tests/md/build/_deps/googletest-src/googlemock/include/gmock/gmock.h =====
// Copyright 2007, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Google Mock - a framework for writing C++ mock classes.
//
// This is the main header file a user should include.

#ifndef GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_H_
#define GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_H_

// This file implements the following syntax:
//
//   ON_CALL(mock_object, Method(...))
//     .With(...) ?
//     .WillByDefault(...);
//
// where With() is optional and WillByDefault() must appear exactly
// once.
//
//   EXPECT_CALL(mock_object, Method(...))
//     .With(...) ?
//     .Times(...) ?
//     .InSequence(...) *
//     .WillOnce(...) *
//     .WillRepeatedly(...) ?
//     .RetiresOnSaturation() ? ;
//
// where all clauses are optional and WillOnce() can be repeated.

#include "gmock/gmock-actions.h"  // IWYU pragma: export
#include "gmock/gmock-cardinalities.h"  // IWYU pragma: export
#include "gmock/gmock-function-mocker.h"  // IWYU pragma: export
#include "gmock/gmock-matchers.h"  // IWYU pragma: export
#include "gmock/gmock-more-actions.h"  // IWYU pragma: export
#include "gmock/gmock-more-matchers.h"  // IWYU pragma: export
#include "gmock/gmock-nice-strict.h"  // IWYU pragma: export
#include "gmock/gmock-spec-builders.h"  // IWYU pragma: export
#include "gmock/internal/gmock-internal-utils.h"
#include "gmock/internal/gmock-port.h"

// Declares Google Mock flags that we want a user to use programmatically.
GMOCK_DECLARE_bool_(catch_leaked_mocks);
GMOCK_DECLARE_string_(verbose);
GMOCK_DECLARE_int32_(default_mock_behavior);

namespace testing {

// Initializes Google Mock.  This must be called before running the
// tests.  In particular, it parses the command line for the flags
// that Google Mock recognizes.  Whenever a Google Mock flag is seen,
// it is removed from argv, and *argc is decremented.
//
// No value is returned.  Instead, the Google Mock flag variables are
// updated.
//
// Since Google Test is needed for Google Mock to work, this function
// also initializes Google Test and parses its flags, if that hasn't
// been done.
GTEST_API_ void InitGoogleMock(int* argc, char** argv);

// This overloaded version can be used in Windows programs compiled in
// UNICODE mode.
GTEST_API_ void InitGoogleMock(int* argc, wchar_t** argv);

// This overloaded version can be used on Arduino/embedded platforms where
// there is no argc/argv.
GTEST_API_ void InitGoogleMock();

}  // namespace testing

#endif  // GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_H_

===== FILE: ./tests/md/build/_deps/googletest-src/googlemock/include/gmock/gmock-more-matchers.h =====
// Copyright 2013, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Google Mock - a framework for writing C++ mock classes.
//
// This file implements some matchers that depend on gmock-matchers.h.
//
// Note that tests are implemented in gmock-matchers_test.cc rather than
// gmock-more-matchers-test.cc.

// IWYU pragma: private, include "gmock/gmock.h"
// IWYU pragma: friend gmock/.*

#ifndef GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_MORE_MATCHERS_H_
#define GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_MORE_MATCHERS_H_

#include <ostream>
#include <string>

#include "gmock/gmock-matchers.h"

namespace testing {

// Silence C4100 (unreferenced formal
// parameter) for MSVC
GTEST_DISABLE_MSC_WARNINGS_PUSH_(4100)
#if defined(_MSC_VER) && (_MSC_VER == 1900)
// and silence C4800 (C4800: 'int *const ': forcing value
// to bool 'true' or 'false') for MSVC 14
GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800)
#endif

namespace internal {

// Implements the polymorphic IsEmpty matcher, which
// can be used as a Matcher<T> as long as T is either a container that defines
// empty() and size() (e.g. std::vector or std::string), or a C-style string.
class IsEmptyMatcher {
 public:
  // Matches anything that defines empty() and size().
  template <typename MatcheeContainerType>
  bool MatchAndExplain(const MatcheeContainerType& c,
                       MatchResultListener* listener) const {
    if (c.empty()) {
      return true;
    }
    *listener << "whose size is " << c.size();
    return false;
  }

  // Matches C-style strings.
  bool MatchAndExplain(const char* s, MatchResultListener* listener) const {
    return MatchAndExplain(std::string(s), listener);
  }

  // Describes what this matcher matches.
  void DescribeTo(std::ostream* os) const { *os << "is empty"; }

  void DescribeNegationTo(std::ostream* os) const { *os << "isn't empty"; }
};

}  // namespace internal

// Creates a polymorphic matcher that matches an empty container or C-style
// string. The container must support both size() and empty(), which all
// STL-like containers provide.
inline PolymorphicMatcher<internal::IsEmptyMatcher> IsEmpty() {
  return MakePolymorphicMatcher(internal::IsEmptyMatcher());
}

// Define a matcher that matches a value that evaluates in boolean
// context to true.  Useful for types that define "explicit operator
// bool" operators and so can't be compared for equality with true
// and false.

===== FILE: ./tests/md/build/_deps/googletest-src/googlemock/include/gmock/gmock-nice-strict.h =====
// Copyright 2008, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Implements class templates NiceMock, NaggyMock, and StrictMock.
//
// Given a mock class MockFoo that is created using Google Mock,
// NiceMock<MockFoo> is a subclass of MockFoo that allows
// uninteresting calls (i.e. calls to mock methods that have no
// EXPECT_CALL specs), NaggyMock<MockFoo> is a subclass of MockFoo
// that prints a warning when an uninteresting call occurs, and
// StrictMock<MockFoo> is a subclass of MockFoo that treats all
// uninteresting calls as errors.
//
// Currently a mock is naggy by default, so MockFoo and
// NaggyMock<MockFoo> behave like the same.  However, we will soon
// switch the default behavior of mocks to be nice, as that in general
// leads to more maintainable tests.  When that happens, MockFoo will
// stop behaving like NaggyMock<MockFoo> and start behaving like
// NiceMock<MockFoo>.
//
// NiceMock, NaggyMock, and StrictMock "inherit" the constructors of
// their respective base class.  Therefore you can write
// NiceMock<MockFoo>(5, "a") to construct a nice mock where MockFoo
// has a constructor that accepts (int, const char*), for example.
//
// A known limitation is that NiceMock<MockFoo>, NaggyMock<MockFoo>,
// and StrictMock<MockFoo> only works for mock methods defined using
// the MOCK_METHOD* family of macros DIRECTLY in the MockFoo class.
// If a mock method is defined in a base class of MockFoo, the "nice"
// or "strict" modifier may not affect it, depending on the compiler.
// In particular, nesting NiceMock, NaggyMock, and StrictMock is NOT
// supported.

// IWYU pragma: private, include "gmock/gmock.h"
// IWYU pragma: friend gmock/.*

#ifndef GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_NICE_STRICT_H_
#define GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_NICE_STRICT_H_

#include <cstdint>
#include <type_traits>

#include "gmock/gmock-spec-builders.h"
#include "gmock/internal/gmock-port.h"

namespace testing {
template <class MockClass>
class NiceMock;
template <class MockClass>
class NaggyMock;
template <class MockClass>
class StrictMock;

namespace internal {
template <typename T>
std::true_type StrictnessModifierProbe(const NiceMock<T>&);
template <typename T>
std::true_type StrictnessModifierProbe(const NaggyMock<T>&);
template <typename T>
std::true_type StrictnessModifierProbe(const StrictMock<T>&);
std::false_type StrictnessModifierProbe(...);

template <typename T>
constexpr bool HasStrictnessModifier() {
  return decltype(StrictnessModifierProbe(std::declval<const T&>()))::value;
}

// Base classes that register and deregister with testing::Mock to alter the
// default behavior around uninteresting calls. Inheriting from one of these
// classes first and then MockClass ensures the MockClass constructor is run
// after registration, and that the MockClass destructor runs before
// deregistration. This guarantees that MockClass's constructor and destructor
// run with the same level of strictness as its instance methods.


===== FILE: ./tests/md/build/_deps/googletest-src/googlemock/include/gmock/internal/gmock-internal-utils.h =====
// Copyright 2007, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Google Mock - a framework for writing C++ mock classes.
//
// This file defines some utilities useful for implementing Google
// Mock.  They are subject to change without notice, so please DO NOT
// USE THEM IN USER CODE.

// IWYU pragma: private, include "gmock/gmock.h"
// IWYU pragma: friend gmock/.*

#ifndef GOOGLEMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_INTERNAL_UTILS_H_
#define GOOGLEMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_INTERNAL_UTILS_H_

#include <stdio.h>

#include <ostream>  // NOLINT
#include <string>
#include <type_traits>
#include <utility>
#include <vector>

#include "gmock/internal/gmock-port.h"
#include "gtest/gtest.h"

namespace testing {

template <typename>
class Matcher;

namespace internal {

// Silence MSVC C4100 (unreferenced formal parameter) and
// C4805('==': unsafe mix of type 'const int' and type 'const bool')
GTEST_DISABLE_MSC_WARNINGS_PUSH_(4100 4805)

// Joins a vector of strings as if they are fields of a tuple; returns
// the joined string.
GTEST_API_ std::string JoinAsKeyValueTuple(
    const std::vector<const char*>& names, const Strings& values);

// Converts an identifier name to a space-separated list of lower-case
// words.  Each maximum substring of the form [A-Za-z][a-z]*|\d+ is
// treated as one word.  For example, both "FooBar123" and
// "foo_bar_123" are converted to "foo bar 123".
GTEST_API_ std::string ConvertIdentifierNameToWords(const char* id_name);

// GetRawPointer(p) returns the raw pointer underlying p when p is a
// smart pointer, or returns p itself when p is already a raw pointer.
// The following default implementation is for the smart pointer case.
template <typename Pointer>
inline const typename Pointer::element_type* GetRawPointer(const Pointer& p) {
  return p.get();
}
// This overload version is for std::reference_wrapper, which does not work with
// the overload above, as it does not have an `element_type`.
template <typename Element>
inline const Element* GetRawPointer(const std::reference_wrapper<Element>& r) {
  return &r.get();
}

// This overloaded version is for the raw pointer case.
template <typename Element>
inline Element* GetRawPointer(Element* p) {
  return p;
}

// Default definitions for all compilers.
// NOTE: If you implement support for other compilers, make sure to avoid
// unexpected overlaps.
// (e.g., Clang also processes #pragma GCC, and clang-cl also handles _MSC_VER.)
#define GMOCK_INTERNAL_WARNING_PUSH()
#define GMOCK_INTERNAL_WARNING_CLANG(Level, Name)

===== FILE: ./tests/md/build/_deps/googletest-src/googlemock/include/gmock/internal/gmock-port.h =====
// Copyright 2008, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Low-level types and utilities for porting Google Mock to various
// platforms.  All macros ending with _ and symbols defined in an
// internal namespace are subject to change without notice.  Code
// outside Google Mock MUST NOT USE THEM DIRECTLY.  Macros that don't
// end with _ are part of Google Mock's public API and can be used by
// code outside Google Mock.

// IWYU pragma: private, include "gmock/gmock.h"
// IWYU pragma: friend gmock/.*

#ifndef GOOGLEMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_PORT_H_
#define GOOGLEMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_PORT_H_

#include <assert.h>
#include <stdlib.h>
#include <cstdint>
#include <iostream>

// Most of the utilities needed for porting Google Mock are also
// required for Google Test and are defined in gtest-port.h.
//
// Note to maintainers: to reduce code duplication, prefer adding
// portability utilities to Google Test's gtest-port.h instead of
// here, as Google Mock depends on Google Test.  Only add a utility
// here if it's truly specific to Google Mock.

#include "gmock/internal/custom/gmock-port.h"
#include "gtest/internal/gtest-port.h"

#if defined(GTEST_HAS_ABSL) && !defined(GTEST_NO_ABSL_FLAGS)
#include "absl/flags/declare.h"
#include "absl/flags/flag.h"
#endif

// For MS Visual C++, check the compiler version. At least VS 2015 is
// required to compile Google Mock.
#if defined(_MSC_VER) && _MSC_VER < 1900
#error "At least Visual C++ 2015 (14.0) is required to compile Google Mock."
#endif

// Macro for referencing flags.  This is public as we want the user to
// use this syntax to reference Google Mock flags.
#define GMOCK_FLAG_NAME_(name) gmock_##name
#define GMOCK_FLAG(name) FLAGS_gmock_##name

// Pick a command line flags implementation.
#if defined(GTEST_HAS_ABSL) && !defined(GTEST_NO_ABSL_FLAGS)

// Macros for defining flags.
#define GMOCK_DEFINE_bool_(name, default_val, doc) \
  ABSL_FLAG(bool, GMOCK_FLAG_NAME_(name), default_val, doc)
#define GMOCK_DEFINE_int32_(name, default_val, doc) \
  ABSL_FLAG(int32_t, GMOCK_FLAG_NAME_(name), default_val, doc)
#define GMOCK_DEFINE_string_(name, default_val, doc) \
  ABSL_FLAG(std::string, GMOCK_FLAG_NAME_(name), default_val, doc)

// Macros for declaring flags.
#define GMOCK_DECLARE_bool_(name) \
  ABSL_DECLARE_FLAG(bool, GMOCK_FLAG_NAME_(name))
#define GMOCK_DECLARE_int32_(name) \
  ABSL_DECLARE_FLAG(int32_t, GMOCK_FLAG_NAME_(name))
#define GMOCK_DECLARE_string_(name) \
  ABSL_DECLARE_FLAG(std::string, GMOCK_FLAG_NAME_(name))

#define GMOCK_FLAG_GET(name) ::absl::GetFlag(GMOCK_FLAG(name))
#define GMOCK_FLAG_SET(name, value) \
  (void)(::absl::SetFlag(&GMOCK_FLAG(name), value))

#else  // defined(GTEST_HAS_ABSL) && !defined(GTEST_NO_ABSL_FLAGS)

// Macros for defining flags.

===== FILE: ./tests/md/build/_deps/googletest-src/googlemock/include/gmock/internal/custom/gmock-generated-actions.h =====
// IWYU pragma: private, include "gmock/gmock.h"
// IWYU pragma: friend gmock/.*

#ifndef GOOGLEMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_GENERATED_ACTIONS_H_
#define GOOGLEMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_GENERATED_ACTIONS_H_

#endif  // GOOGLEMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_GENERATED_ACTIONS_H_

===== FILE: ./tests/md/build/_deps/googletest-src/googlemock/include/gmock/internal/custom/gmock-port.h =====
// Copyright 2015, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Injection point for custom user configurations. See README for details
//
// ** Custom implementation starts here **

// IWYU pragma: private, include "gmock/gmock.h"
// IWYU pragma: friend gmock/.*

#ifndef GOOGLEMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_PORT_H_
#define GOOGLEMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_PORT_H_

#endif  // GOOGLEMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_PORT_H_

===== FILE: ./tests/md/build/_deps/googletest-src/googlemock/include/gmock/internal/custom/gmock-matchers.h =====
// Copyright 2015, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Injection point for custom user configurations. See README for details

// IWYU pragma: private, include "gmock/gmock.h"
// IWYU pragma: friend gmock/.*

#ifndef GOOGLEMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_MATCHERS_H_
#define GOOGLEMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_MATCHERS_H_
#endif  // GOOGLEMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_MATCHERS_H_

===== FILE: ./tests/md/build/_deps/googletest-src/googlemock/include/gmock/internal/gmock-pp.h =====
#ifndef GOOGLEMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_PP_H_
#define GOOGLEMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_PP_H_

// Expands and concatenates the arguments. Constructed macros reevaluate.
#define GMOCK_PP_CAT(_1, _2) GMOCK_PP_INTERNAL_CAT(_1, _2)

// Expands and stringifies the only argument.
#define GMOCK_PP_STRINGIZE(...) GMOCK_PP_INTERNAL_STRINGIZE(__VA_ARGS__)

// Returns empty. Given a variadic number of arguments.
#define GMOCK_PP_EMPTY(...)

// Returns a comma. Given a variadic number of arguments.
#define GMOCK_PP_COMMA(...) ,

// Returns the only argument.
#define GMOCK_PP_IDENTITY(_1) _1

// Evaluates to the number of arguments after expansion.
//
//   #define PAIR x, y
//
//   GMOCK_PP_NARG() => 1
//   GMOCK_PP_NARG(x) => 1
//   GMOCK_PP_NARG(x, y) => 2
//   GMOCK_PP_NARG(PAIR) => 2
//
// Requires: the number of arguments after expansion is at most 15.
#define GMOCK_PP_NARG(...) \
  GMOCK_PP_INTERNAL_16TH(  \
      (__VA_ARGS__, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0))

// Returns 1 if the expansion of arguments has an unprotected comma. Otherwise
// returns 0. Requires no more than 15 unprotected commas.
#define GMOCK_PP_HAS_COMMA(...) \
  GMOCK_PP_INTERNAL_16TH(       \
      (__VA_ARGS__, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0))

// Returns the first argument.
#define GMOCK_PP_HEAD(...) GMOCK_PP_INTERNAL_HEAD((__VA_ARGS__, unusedArg))

// Returns the tail. A variadic list of all arguments minus the first. Requires
// at least one argument.
#define GMOCK_PP_TAIL(...) GMOCK_PP_INTERNAL_TAIL((__VA_ARGS__))

// Calls CAT(_Macro, NARG(__VA_ARGS__))(__VA_ARGS__)
#define GMOCK_PP_VARIADIC_CALL(_Macro, ...) \
  GMOCK_PP_IDENTITY(                        \
      GMOCK_PP_CAT(_Macro, GMOCK_PP_NARG(__VA_ARGS__))(__VA_ARGS__))

// If the arguments after expansion have no tokens, evaluates to `1`. Otherwise
// evaluates to `0`.
//
// Requires: * the number of arguments after expansion is at most 15.
//           * If the argument is a macro, it must be able to be called with one
//             argument.
//
// Implementation details:
//
// There is one case when it generates a compile error: if the argument is macro
// that cannot be called with one argument.
//
//   #define M(a, b)  // it doesn't matter what it expands to
//
//   // Expected: expands to `0`.
//   // Actual: compile error.
//   GMOCK_PP_IS_EMPTY(M)
//
// There are 4 cases tested:
//
// * __VA_ARGS__ possible expansion has no unparen'd commas. Expected 0.
// * __VA_ARGS__ possible expansion is not enclosed in parenthesis. Expected 0.
// * __VA_ARGS__ possible expansion is not a macro that ()-evaluates to a comma.
//   Expected 0
// * __VA_ARGS__ is empty, or has unparen'd commas, or is enclosed in
//   parenthesis, or is a macro that ()-evaluates to comma. Expected 1.
//
// We trigger detection on '0001', i.e. on empty.
#define GMOCK_PP_IS_EMPTY(...)                                               \
  GMOCK_PP_INTERNAL_IS_EMPTY(GMOCK_PP_HAS_COMMA(__VA_ARGS__),                \
                             GMOCK_PP_HAS_COMMA(GMOCK_PP_COMMA __VA_ARGS__), \
                             GMOCK_PP_HAS_COMMA(__VA_ARGS__()),              \
                             GMOCK_PP_HAS_COMMA(GMOCK_PP_COMMA __VA_ARGS__()))

// Evaluates to _Then if _Cond is 1 and _Else if _Cond is 0.
#define GMOCK_PP_IF(_Cond, _Then, _Else) \
  GMOCK_PP_CAT(GMOCK_PP_INTERNAL_IF_, _Cond)(_Then, _Else)

// Similar to GMOCK_PP_IF but takes _Then and _Else in parentheses.
//
// GMOCK_PP_GENERIC_IF(1, (a, b, c), (d, e, f)) => a, b, c
// GMOCK_PP_GENERIC_IF(0, (a, b, c), (d, e, f)) => d, e, f
//
#define GMOCK_PP_GENERIC_IF(_Cond, _Then, _Else) \
  GMOCK_PP_REMOVE_PARENS(GMOCK_PP_IF(_Cond, _Then, _Else))

// Evaluates to the number of arguments after expansion. Identifies 'empty' as
// 0.
//
//   #define PAIR x, y

===== FILE: ./tests/md/build/_deps/googletest-src/googlemock/include/gmock/gmock-spec-builders.h =====
// Copyright 2007, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Google Mock - a framework for writing C++ mock classes.
//
// This file implements the ON_CALL() and EXPECT_CALL() macros.
//
// A user can use the ON_CALL() macro to specify the default action of
// a mock method.  The syntax is:
//
//   ON_CALL(mock_object, Method(argument-matchers))
//       .With(multi-argument-matcher)
//       .WillByDefault(action);
//
//  where the .With() clause is optional.
//
// A user can use the EXPECT_CALL() macro to specify an expectation on
// a mock method.  The syntax is:
//
//   EXPECT_CALL(mock_object, Method(argument-matchers))
//       .With(multi-argument-matchers)
//       .Times(cardinality)
//       .InSequence(sequences)
//       .After(expectations)
//       .WillOnce(action)
//       .WillRepeatedly(action)
//       .RetiresOnSaturation();
//
// where all clauses are optional, and .InSequence()/.After()/
// .WillOnce() can appear any number of times.

// IWYU pragma: private, include "gmock/gmock.h"
// IWYU pragma: friend gmock/.*

#ifndef GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_
#define GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_

#include <cstdint>
#include <functional>
#include <map>
#include <memory>
#include <ostream>
#include <set>
#include <sstream>
#include <string>
#include <type_traits>
#include <utility>
#include <vector>

#include "gmock/gmock-actions.h"
#include "gmock/gmock-cardinalities.h"
#include "gmock/gmock-matchers.h"
#include "gmock/internal/gmock-internal-utils.h"
#include "gmock/internal/gmock-port.h"
#include "gtest/gtest.h"

#if GTEST_HAS_EXCEPTIONS
#include <stdexcept>  // NOLINT
#endif

GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \
/* class A needs to have dll-interface to be used by clients of class B */)

namespace testing {

// An abstract handle of an expectation.
class Expectation;

// A set of expectation handles.
class ExpectationSet;

// Anything inside the 'internal' namespace IS INTERNAL IMPLEMENTATION
// and MUST NOT BE USED IN USER CODE!!!
namespace internal {

===== FILE: ./tests/md/build/_deps/googletest-src/googlemock/include/gmock/gmock-actions.h =====
// Copyright 2007, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Google Mock - a framework for writing C++ mock classes.
//
// The ACTION* family of macros can be used in a namespace scope to
// define custom actions easily.  The syntax:
//
//   ACTION(name) { statements; }
//
// will define an action with the given name that executes the
// statements.  The value returned by the statements will be used as
// the return value of the action.  Inside the statements, you can
// refer to the K-th (0-based) argument of the mock function by
// 'argK', and refer to its type by 'argK_type'.  For example:
//
//   ACTION(IncrementArg1) {
//     arg1_type temp = arg1;
//     return ++(*temp);
//   }
//
// allows you to write
//
//   ...WillOnce(IncrementArg1());
//
// You can also refer to the entire argument tuple and its type by
// 'args' and 'args_type', and refer to the mock function type and its
// return type by 'function_type' and 'return_type'.
//
// Note that you don't need to specify the types of the mock function
// arguments.  However rest assured that your code is still type-safe:
// you'll get a compiler error if *arg1 doesn't support the ++
// operator, or if the type of ++(*arg1) isn't compatible with the
// mock function's return type, for example.
//
// Sometimes you'll want to parameterize the action.   For that you can use
// another macro:
//
//   ACTION_P(name, param_name) { statements; }
//
// For example:
//
//   ACTION_P(Add, n) { return arg0 + n; }
//
// will allow you to write:
//
//   ...WillOnce(Add(5));
//
// Note that you don't need to provide the type of the parameter
// either.  If you need to reference the type of a parameter named
// 'foo', you can write 'foo_type'.  For example, in the body of
// ACTION_P(Add, n) above, you can write 'n_type' to refer to the type
// of 'n'.
//
// We also provide ACTION_P2, ACTION_P3, ..., up to ACTION_P10 to support
// multi-parameter actions.
//
// For the purpose of typing, you can view
//
//   ACTION_Pk(Foo, p1, ..., pk) { ... }
//
// as shorthand for
//
//   template <typename p1_type, ..., typename pk_type>
//   FooActionPk<p1_type, ..., pk_type> Foo(p1_type p1, ..., pk_type pk) { ... }
//
// In particular, you can provide the template type arguments
// explicitly when invoking Foo(), as in Foo<long, bool>(5, false);
// although usually you can rely on the compiler to infer the types
// for you automatically.  You can assign the result of expression
// Foo(p1, ..., pk) to a variable of type FooActionPk<p1_type, ...,
// pk_type>.  This can be useful when composing actions.
//
// You can also overload actions with different numbers of parameters:

===== FILE: ./tests/md/build/_deps/googletest-src/googlemock/include/gmock/gmock-more-actions.h =====
// Copyright 2007, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Google Mock - a framework for writing C++ mock classes.
//
// This file implements some commonly used variadic actions.

// IWYU pragma: private, include "gmock/gmock.h"
// IWYU pragma: friend gmock/.*

#ifndef GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_MORE_ACTIONS_H_
#define GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_MORE_ACTIONS_H_

#include <memory>
#include <utility>

#include "gmock/gmock-actions.h"
#include "gmock/internal/gmock-port.h"

// Include any custom callback actions added by the local installation.
#include "gmock/internal/custom/gmock-generated-actions.h"

// Sometimes you want to give an action explicit template parameters
// that cannot be inferred from its value parameters.  ACTION() and
// ACTION_P*() don't support that.  ACTION_TEMPLATE() remedies that
// and can be viewed as an extension to ACTION() and ACTION_P*().
//
// The syntax:
//
//   ACTION_TEMPLATE(ActionName,
//                   HAS_m_TEMPLATE_PARAMS(kind1, name1, ..., kind_m, name_m),
//                   AND_n_VALUE_PARAMS(p1, ..., p_n)) { statements; }
//
// defines an action template that takes m explicit template
// parameters and n value parameters.  name_i is the name of the i-th
// template parameter, and kind_i specifies whether it's a typename,
// an integral constant, or a template.  p_i is the name of the i-th
// value parameter.
//
// Example:
//
//   // DuplicateArg<k, T>(output) converts the k-th argument of the mock
//   // function to type T and copies it to *output.
//   ACTION_TEMPLATE(DuplicateArg,
//                   HAS_2_TEMPLATE_PARAMS(int, k, typename, T),
//                   AND_1_VALUE_PARAMS(output)) {
//     *output = T(::std::get<k>(args));
//   }
//   ...
//     int n;
//     EXPECT_CALL(mock, Foo(_, _))
//         .WillOnce(DuplicateArg<1, unsigned char>(&n));
//
// To create an instance of an action template, write:
//
//   ActionName<t1, ..., t_m>(v1, ..., v_n)
//
// where the ts are the template arguments and the vs are the value
// arguments.  The value argument types are inferred by the compiler.
// If you want to explicitly specify the value argument types, you can
// provide additional template arguments:
//
//   ActionName<t1, ..., t_m, u1, ..., u_k>(v1, ..., v_n)
//
// where u_i is the desired type of v_i.
//
// ACTION_TEMPLATE and ACTION/ACTION_P* can be overloaded on the
// number of value parameters, but not on the number of template
// parameters.  Without the restriction, the meaning of the following
// is unclear:
//
//   OverloadedAction<int, bool>(x);
//
// Are we using a single-template-parameter action where 'bool' refers

===== FILE: ./tests/md/build/_deps/googletest-src/googlemock/include/gmock/gmock-function-mocker.h =====
// Copyright 2007, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Google Mock - a framework for writing C++ mock classes.
//
// This file implements MOCK_METHOD.

// IWYU pragma: private, include "gmock/gmock.h"
// IWYU pragma: friend gmock/.*

#ifndef GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_FUNCTION_MOCKER_H_
#define GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_FUNCTION_MOCKER_H_

#include <cstddef>
#include <type_traits>  // IWYU pragma: keep
#include <utility>      // IWYU pragma: keep

#include "gmock/gmock-spec-builders.h"
#include "gmock/internal/gmock-internal-utils.h"
#include "gmock/internal/gmock-pp.h"

namespace testing {
namespace internal {
template <typename T>
using identity_t = T;

template <typename Pattern>
struct ThisRefAdjuster {
  template <typename T>
  using AdjustT = typename std::conditional<
      std::is_const<typename std::remove_reference<Pattern>::type>::value,
      typename std::conditional<std::is_lvalue_reference<Pattern>::value,
                                const T&, const T&&>::type,
      typename std::conditional<std::is_lvalue_reference<Pattern>::value, T&,
                                T&&>::type>::type;

  template <typename MockType>
  static AdjustT<MockType> Adjust(const MockType& mock) {
    return static_cast<AdjustT<MockType>>(const_cast<MockType&>(mock));
  }
};

constexpr bool PrefixOf(const char* a, const char* b) {
  return *a == 0 || (*a == *b && internal::PrefixOf(a + 1, b + 1));
}

template <size_t N, size_t M>
constexpr bool StartsWith(const char (&prefix)[N], const char (&str)[M]) {
  return N <= M && internal::PrefixOf(prefix, str);
}

template <size_t N, size_t M>
constexpr bool EndsWith(const char (&suffix)[N], const char (&str)[M]) {
  return N <= M && internal::PrefixOf(suffix, str + M - N);
}

template <size_t N, size_t M>
constexpr bool Equals(const char (&a)[N], const char (&b)[M]) {
  return N == M && internal::PrefixOf(a, b);
}

template <size_t N>
constexpr bool ValidateSpec(const char (&spec)[N]) {
  return internal::Equals("const", spec) ||
         internal::Equals("override", spec) ||
         internal::Equals("final", spec) ||
         internal::Equals("noexcept", spec) ||
         (internal::StartsWith("noexcept(", spec) &&
          internal::EndsWith(")", spec)) ||
         internal::Equals("ref(&)", spec) ||
         internal::Equals("ref(&&)", spec) ||
         (internal::StartsWith("Calltype(", spec) &&
          internal::EndsWith(")", spec));
}

===== FILE: ./tests/md/build/_deps/googletest-src/googlemock/include/gmock/gmock-matchers.h =====
// Copyright 2007, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Google Mock - a framework for writing C++ mock classes.
//
// The MATCHER* family of macros can be used in a namespace scope to
// define custom matchers easily.
//
// Basic Usage
// ===========
//
// The syntax
//
//   MATCHER(name, description_string) { statements; }
//
// defines a matcher with the given name that executes the statements,
// which must return a bool to indicate if the match succeeds.  Inside
// the statements, you can refer to the value being matched by 'arg',
// and refer to its type by 'arg_type'.
//
// The description string documents what the matcher does, and is used
// to generate the failure message when the match fails.  Since a
// MATCHER() is usually defined in a header file shared by multiple
// C++ source files, we require the description to be a C-string
// literal to avoid possible side effects.  It can be empty, in which
// case we'll use the sequence of words in the matcher name as the
// description.
//
// For example:
//
//   MATCHER(IsEven, "") { return (arg % 2) == 0; }
//
// allows you to write
//
//   // Expects mock_foo.Bar(n) to be called where n is even.
//   EXPECT_CALL(mock_foo, Bar(IsEven()));
//
// or,
//
//   // Verifies that the value of some_expression is even.
//   EXPECT_THAT(some_expression, IsEven());
//
// If the above assertion fails, it will print something like:
//
//   Value of: some_expression
//   Expected: is even
//     Actual: 7
//
// where the description "is even" is automatically calculated from the
// matcher name IsEven.
//
// Argument Type
// =============
//
// Note that the type of the value being matched (arg_type) is
// determined by the context in which you use the matcher and is
// supplied to you by the compiler, so you don't need to worry about
// declaring it (nor can you).  This allows the matcher to be
// polymorphic.  For example, IsEven() can be used to match any type
// where the value of "(arg % 2) == 0" can be implicitly converted to
// a bool.  In the "Bar(IsEven())" example above, if method Bar()
// takes an int, 'arg_type' will be int; if it takes an unsigned long,
// 'arg_type' will be unsigned long; and so on.
//
// Parameterizing Matchers
// =======================
//
// Sometimes you'll want to parameterize the matcher.  For that you
// can use another macro:
//
//   MATCHER_P(name, param_name, description_string) { statements; }
//
// For example:
//

===== FILE: ./tests/md/build/_deps/googletest-src/googlemock/test/gmock_link_test.h =====
// Copyright 2009, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Google Mock - a framework for writing C++ mock classes.
//
// This file tests that:
// a. A header file defining a mock class can be included in multiple
//    translation units without causing a link error.
// b. Actions and matchers can be instantiated with identical template
//    arguments in different translation units without causing link
//    errors.
//    The following constructs are currently tested:
//    Actions:
//      Return()
//      Return(value)
//      ReturnNull
//      ReturnRef
//      Assign
//      SetArgPointee
//      SetArrayArgument
//      SetErrnoAndReturn
//      Invoke(function)
//      Invoke(object, method)
//      InvokeWithoutArgs(function)
//      InvokeWithoutArgs(object, method)
//      InvokeArgument
//      WithArg
//      WithArgs
//      WithoutArgs
//      DoAll
//      DoDefault
//      IgnoreResult
//      Throw
//      ACTION()-generated
//      ACTION_P()-generated
//      ACTION_P2()-generated
//    Matchers:
//      _
//      A
//      An
//      Eq
//      Gt, Lt, Ge, Le, Ne
//      NotNull
//      Ref
//      TypedEq
//      DoubleEq
//      FloatEq
//      NanSensitiveDoubleEq
//      NanSensitiveFloatEq
//      ContainsRegex
//      MatchesRegex
//      EndsWith
//      HasSubstr
//      StartsWith
//      StrCaseEq
//      StrCaseNe
//      StrEq
//      StrNe
//      ElementsAre
//      ElementsAreArray
//      ContainerEq
//      Field
//      Property
//      ResultOf(function)
//      ResultOf(callback)
//      Pointee
//      Truly(predicate)
//      AddressSatisfies
//      AllOf
//      AnyOf
//      Not
//      MatcherCast<T>
//
//  Please note: this test does not verify the functioning of these

===== FILE: ./tests/md/build/_deps/googletest-src/googlemock/test/gmock-matchers_test.h =====
// Copyright 2007, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Google Mock - a framework for writing C++ mock classes.
//
// This file tests some commonly used argument matchers.

#ifndef GOOGLEMOCK_TEST_GMOCK_MATCHERS_TEST_H_
#define GOOGLEMOCK_TEST_GMOCK_MATCHERS_TEST_H_

#include <string.h>
#include <time.h>

#include <array>
#include <cstdint>
#include <deque>
#include <forward_list>
#include <functional>
#include <iostream>
#include <iterator>
#include <limits>
#include <list>
#include <map>
#include <memory>
#include <set>
#include <sstream>
#include <string>
#include <type_traits>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>

#include "gmock/gmock-matchers.h"
#include "gmock/gmock-more-matchers.h"
#include "gmock/gmock.h"
#include "gtest/gtest-spi.h"
#include "gtest/gtest.h"

namespace testing {
namespace gmock_matchers_test {

using std::greater;
using std::less;
using std::list;
using std::make_pair;
using std::map;
using std::multimap;
using std::multiset;
using std::ostream;
using std::pair;
using std::set;
using std::stringstream;
using std::vector;
using testing::internal::DummyMatchResultListener;
using testing::internal::ElementMatcherPair;
using testing::internal::ElementMatcherPairs;
using testing::internal::ElementsAreArrayMatcher;
using testing::internal::ExplainMatchFailureTupleTo;
using testing::internal::FloatingEqMatcher;
using testing::internal::FormatMatcherDescription;
using testing::internal::IsReadableTypeName;
using testing::internal::MatchMatrix;
using testing::internal::PredicateFormatterFromMatcher;
using testing::internal::RE;
using testing::internal::StreamMatchResultListener;
using testing::internal::Strings;

// Helper for testing container-valued matchers in mock method context. It is
// important to test matchers in this context, since it requires additional type
// deduction beyond what EXPECT_THAT does, thus making it more restrictive.
struct ContainerHelper {
  MOCK_METHOD1(Call, void(std::vector<std::unique_ptr<int>>));
};

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/src/gtest-internal-inl.h =====
// Copyright 2005, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Utility functions and classes used by the Google C++ testing framework.//
// This file contains purely Google Test's internal implementation.  Please
// DO NOT #INCLUDE IT IN A USER PROGRAM.

#ifndef GOOGLETEST_SRC_GTEST_INTERNAL_INL_H_
#define GOOGLETEST_SRC_GTEST_INTERNAL_INL_H_

#ifndef _WIN32_WCE
#include <errno.h>
#endif  // !_WIN32_WCE
#include <stddef.h>
#include <stdlib.h>  // For strtoll/_strtoul64/malloc/free.
#include <string.h>  // For memmove.

#include <algorithm>
#include <cstdint>
#include <memory>
#include <set>
#include <string>
#include <unordered_map>
#include <vector>

#include "gtest/internal/gtest-port.h"

#if GTEST_CAN_STREAM_RESULTS_
#include <arpa/inet.h>  // NOLINT
#include <netdb.h>      // NOLINT
#endif

#ifdef GTEST_OS_WINDOWS
#include <windows.h>  // NOLINT
#endif                // GTEST_OS_WINDOWS

#include "gtest/gtest-spi.h"
#include "gtest/gtest.h"

GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \
/* class A needs to have dll-interface to be used by clients of class B */)

// Declares the flags.
//
// We don't want the users to modify this flag in the code, but want
// Google Test's own unit tests to be able to access it. Therefore we
// declare it here as opposed to in gtest.h.
GTEST_DECLARE_bool_(death_test_use_fork);

namespace testing {
namespace internal {

// The value of GetTestTypeId() as seen from within the Google Test
// library.  This is solely for testing GetTestTypeId().
GTEST_API_ extern const TypeId kTestTypeIdInGoogleTest;

// A valid random seed must be in [1, kMaxRandomSeed].
const int kMaxRandomSeed = 99999;

// g_help_flag is true if and only if the --help flag or an equivalent form
// is specified on the command line.
GTEST_API_ extern bool g_help_flag;

// Returns the current time in milliseconds.
GTEST_API_ TimeInMillis GetTimeInMillis();

// Returns true if and only if Google Test should use colors in the output.
GTEST_API_ bool ShouldUseColor(bool stdout_is_tty);

// Formats the given time in milliseconds as seconds. If the input is an exact N
// seconds, the output has a trailing decimal point (e.g., "N." instead of "N").
GTEST_API_ std::string FormatTimeInMillisAsSeconds(TimeInMillis ms);

// Converts the given time in milliseconds to a date string in the ISO 8601

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/samples/sample1.h =====
// Copyright 2005, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// A sample program demonstrating using Google C++ testing framework.

#ifndef GOOGLETEST_SAMPLES_SAMPLE1_H_
#define GOOGLETEST_SAMPLES_SAMPLE1_H_

// Returns n! (the factorial of n).  For negative n, n! is defined to be 1.
int Factorial(int n);

// Returns true if and only if n is a prime number.
bool IsPrime(int n);

#endif  // GOOGLETEST_SAMPLES_SAMPLE1_H_

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/samples/prime_tables.h =====
// Copyright 2008 Google Inc.
// All Rights Reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This provides interface PrimeTable that determines whether a number is a
// prime and determines a next prime number. This interface is used
// in Google Test samples demonstrating use of parameterized tests.

#ifndef GOOGLETEST_SAMPLES_PRIME_TABLES_H_
#define GOOGLETEST_SAMPLES_PRIME_TABLES_H_

#include <algorithm>

// The prime table interface.
class PrimeTable {
 public:
  virtual ~PrimeTable() = default;

  // Returns true if and only if n is a prime number.
  virtual bool IsPrime(int n) const = 0;

  // Returns the smallest prime number greater than p; or returns -1
  // if the next prime is beyond the capacity of the table.
  virtual int GetNextPrime(int p) const = 0;
};

// Implementation #1 calculates the primes on-the-fly.
class OnTheFlyPrimeTable : public PrimeTable {
 public:
  bool IsPrime(int n) const override {
    if (n <= 1) return false;

    for (int i = 2; i * i <= n; i++) {
      // n is divisible by an integer other than 1 and itself.
      if ((n % i) == 0) return false;
    }

    return true;
  }

  int GetNextPrime(int p) const override {
    if (p < 0) return -1;

    for (int n = p + 1;; n++) {
      if (IsPrime(n)) return n;
    }
  }
};

// Implementation #2 pre-calculates the primes and stores the result
// in an array.
class PreCalculatedPrimeTable : public PrimeTable {
 public:
  // 'max' specifies the maximum number the prime table holds.
  explicit PreCalculatedPrimeTable(int max)
      : is_prime_size_(std::max(1, max + 1)),
        is_prime_(new bool[static_cast<size_t>(is_prime_size_)]) {
    CalculatePrimesUpTo(is_prime_size_ - 1);
  }
  ~PreCalculatedPrimeTable() override { delete[] is_prime_; }

  bool IsPrime(int n) const override {
    return 0 <= n && n < is_prime_size_ && is_prime_[n];
  }

  int GetNextPrime(int p) const override {
    for (int n = p + 1; n < is_prime_size_; n++) {
      if (is_prime_[n]) return n;
    }

    return -1;
  }

 private:
  void CalculatePrimesUpTo(int max) {

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/samples/sample4.h =====
// Copyright 2005, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// A sample program demonstrating using Google C++ testing framework.
#ifndef GOOGLETEST_SAMPLES_SAMPLE4_H_
#define GOOGLETEST_SAMPLES_SAMPLE4_H_

// A simple monotonic counter.
class Counter {
 private:
  int counter_;

 public:
  // Creates a counter that starts at 0.
  Counter() : counter_(0) {}

  // Returns the current counter value, and increments it.
  int Increment();

  // Returns the current counter value, and decrements it.
  int Decrement();

  // Prints the current counter value to STDOUT.
  void Print() const;
};

#endif  // GOOGLETEST_SAMPLES_SAMPLE4_H_

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/samples/sample3-inl.h =====
// Copyright 2005, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// A sample program demonstrating using Google C++ testing framework.

#ifndef GOOGLETEST_SAMPLES_SAMPLE3_INL_H_
#define GOOGLETEST_SAMPLES_SAMPLE3_INL_H_

#include <stddef.h>

// Queue is a simple queue implemented as a singled-linked list.
//
// The element type must support copy constructor.
template <typename E>  // E is the element type
class Queue;

// QueueNode is a node in a Queue, which consists of an element of
// type E and a pointer to the next node.
template <typename E>  // E is the element type
class QueueNode {
  friend class Queue<E>;

 public:
  // Gets the element in this node.
  const E& element() const { return element_; }

  // Gets the next node in the queue.
  QueueNode* next() { return next_; }
  const QueueNode* next() const { return next_; }

 private:
  // Creates a node with a given element value.  The next pointer is
  // set to NULL.
  explicit QueueNode(const E& an_element)
      : element_(an_element), next_(nullptr) {}

  // We disable the default assignment operator and copy c'tor.
  const QueueNode& operator=(const QueueNode&);
  QueueNode(const QueueNode&);

  E element_;
  QueueNode* next_;
};

template <typename E>  // E is the element type.
class Queue {
 public:
  // Creates an empty queue.
  Queue() : head_(nullptr), last_(nullptr), size_(0) {}

  // D'tor.  Clears the queue.
  ~Queue() { Clear(); }

  // Clears the queue.
  void Clear() {
    if (size_ > 0) {
      // 1. Deletes every node.
      QueueNode<E>* node = head_;
      QueueNode<E>* next = node->next();
      for (;;) {
        delete node;
        node = next;
        if (node == nullptr) break;
        next = node->next();
      }

      // 2. Resets the member variables.
      head_ = last_ = nullptr;
      size_ = 0;
    }
  }

  // Gets the number of elements.
  size_t Size() const { return size_; }

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/samples/sample2.h =====
// Copyright 2005, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// A sample program demonstrating using Google C++ testing framework.

#ifndef GOOGLETEST_SAMPLES_SAMPLE2_H_
#define GOOGLETEST_SAMPLES_SAMPLE2_H_

#include <string.h>

// A simple string class.
class MyString {
 private:
  const char* c_string_;
  const MyString& operator=(const MyString& rhs);

 public:
  // Clones a 0-terminated C string, allocating memory using new.
  static const char* CloneCString(const char* a_c_string);

  ////////////////////////////////////////////////////////////
  //
  // C'tors

  // The default c'tor constructs a NULL string.
  MyString() : c_string_(nullptr) {}

  // Constructs a MyString by cloning a 0-terminated C string.
  explicit MyString(const char* a_c_string) : c_string_(nullptr) {
    Set(a_c_string);
  }

  // Copy c'tor
  MyString(const MyString& string) : c_string_(nullptr) {
    Set(string.c_string_);
  }

  ////////////////////////////////////////////////////////////
  //
  // D'tor.  MyString is intended to be a final class, so the d'tor
  // doesn't need to be virtual.
  ~MyString() { delete[] c_string_; }

  // Gets the 0-terminated C string this MyString object represents.
  const char* c_string() const { return c_string_; }

  size_t Length() const { return c_string_ == nullptr ? 0 : strlen(c_string_); }

  // Sets the 0-terminated C string this MyString object represents.
  void Set(const char* c_string);
};

#endif  // GOOGLETEST_SAMPLES_SAMPLE2_H_

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/gtest-spi.h =====
// Copyright 2007, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Utilities for testing Google Test itself and code that uses Google Test
// (e.g. frameworks built on top of Google Test).

#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_SPI_H_
#define GOOGLETEST_INCLUDE_GTEST_GTEST_SPI_H_

#include <string>

#include "gtest/gtest.h"

GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \
/* class A needs to have dll-interface to be used by clients of class B */)

namespace testing {

// This helper class can be used to mock out Google Test failure reporting
// so that we can test Google Test or code that builds on Google Test.
//
// An object of this class appends a TestPartResult object to the
// TestPartResultArray object given in the constructor whenever a Google Test
// failure is reported. It can either intercept only failures that are
// generated in the same thread that created this object or it can intercept
// all generated failures. The scope of this mock object can be controlled with
// the second argument to the two arguments constructor.
class GTEST_API_ ScopedFakeTestPartResultReporter
    : public TestPartResultReporterInterface {
 public:
  // The two possible mocking modes of this object.
  enum InterceptMode {
    INTERCEPT_ONLY_CURRENT_THREAD,  // Intercepts only thread local failures.
    INTERCEPT_ALL_THREADS           // Intercepts all failures.
  };

  // The c'tor sets this object as the test part result reporter used
  // by Google Test.  The 'result' parameter specifies where to report the
  // results. This reporter will only catch failures generated in the current
  // thread. DEPRECATED
  explicit ScopedFakeTestPartResultReporter(TestPartResultArray* result);

  // Same as above, but you can choose the interception scope of this object.
  ScopedFakeTestPartResultReporter(InterceptMode intercept_mode,
                                   TestPartResultArray* result);

  // The d'tor restores the previous test part result reporter.
  ~ScopedFakeTestPartResultReporter() override;

  // Appends the TestPartResult object to the TestPartResultArray
  // received in the constructor.
  //
  // This method is from the TestPartResultReporterInterface
  // interface.
  void ReportTestPartResult(const TestPartResult& result) override;

 private:
  void Init();

  const InterceptMode intercept_mode_;
  TestPartResultReporterInterface* old_reporter_;
  TestPartResultArray* const result_;

  ScopedFakeTestPartResultReporter(const ScopedFakeTestPartResultReporter&) =
      delete;
  ScopedFakeTestPartResultReporter& operator=(
      const ScopedFakeTestPartResultReporter&) = delete;
};

namespace internal {

// A helper class for implementing EXPECT_FATAL_FAILURE() and
// EXPECT_NONFATAL_FAILURE().  Its destructor verifies that the given
// TestPartResultArray contains exactly one failure that has the given

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/internal/gtest-type-util.h =====
// Copyright 2008 Google Inc.
// All Rights Reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Type utilities needed for implementing typed and type-parameterized
// tests.

// IWYU pragma: private, include "gtest/gtest.h"
// IWYU pragma: friend gtest/.*
// IWYU pragma: friend gmock/.*

#ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_
#define GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_

#include <string>
#include <type_traits>
#include <typeinfo>

#include "gtest/internal/gtest-port.h"

// #ifdef __GNUC__ is too general here.  It is possible to use gcc without using
// libstdc++ (which is where cxxabi.h comes from).
#if GTEST_HAS_CXXABI_H_
#include <cxxabi.h>
#elif defined(__HP_aCC)
#include <acxx_demangle.h>
#endif  // GTEST_HASH_CXXABI_H_

namespace testing {
namespace internal {

// Canonicalizes a given name with respect to the Standard C++ Library.
// This handles removing the inline namespace within `std` that is
// used by various standard libraries (e.g., `std::__1`).  Names outside
// of namespace std are returned unmodified.
inline std::string CanonicalizeForStdLibVersioning(std::string s) {
  static const char prefix[] = "std::__";
  if (s.compare(0, strlen(prefix), prefix) == 0) {
    std::string::size_type end = s.find("::", strlen(prefix));
    if (end != s.npos) {
      // Erase everything between the initial `std` and the second `::`.
      s.erase(strlen("std"), end - strlen("std"));
    }
  }

  // Strip redundant spaces in typename to match MSVC
  // For example, std::pair<int, bool> -> std::pair<int,bool>
  static const char to_search[] = ", ";
  const char replace_char = ',';
  size_t pos = 0;
  while (true) {
    // Get the next occurrence from the current position
    pos = s.find(to_search, pos);
    if (pos == std::string::npos) {
      break;
    }
    // Replace this occurrence of substring
    s.replace(pos, strlen(to_search), 1, replace_char);
    ++pos;
  }
  return s;
}

#if GTEST_HAS_RTTI
// GetTypeName(const std::type_info&) returns a human-readable name of type T.
inline std::string GetTypeName(const std::type_info& type) {
  const char* const name = type.name();
#if GTEST_HAS_CXXABI_H_ || defined(__HP_aCC)
  int status = 0;
  // gcc's implementation of typeid(T).name() mangles the type name,
  // so we have to demangle it.
#if GTEST_HAS_CXXABI_H_
  using abi::__cxa_demangle;
#endif  // GTEST_HAS_CXXABI_H_
  char* const readable_name = __cxa_demangle(name, nullptr, nullptr, &status);

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/internal/gtest-port-arch.h =====
// Copyright 2015, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// The Google C++ Testing and Mocking Framework (Google Test)
//
// This header file defines the GTEST_OS_* macro.
// It is separate from gtest-port.h so that custom/gtest-port.h can include it.

#ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_ARCH_H_
#define GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_ARCH_H_

// Determines the platform on which Google Test is compiled.
#ifdef __CYGWIN__
#define GTEST_OS_CYGWIN 1
#elif defined(__MINGW__) || defined(__MINGW32__) || defined(__MINGW64__)
#define GTEST_OS_WINDOWS_MINGW 1
#define GTEST_OS_WINDOWS 1
#elif defined _WIN32
#define GTEST_OS_WINDOWS 1
#ifdef _WIN32_WCE
#define GTEST_OS_WINDOWS_MOBILE 1
#elif defined(WINAPI_FAMILY)
#include <winapifamily.h>
#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
#define GTEST_OS_WINDOWS_DESKTOP 1
#elif WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_PHONE_APP)
#define GTEST_OS_WINDOWS_PHONE 1
#elif WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
#define GTEST_OS_WINDOWS_RT 1
#elif WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_TV_TITLE)
#define GTEST_OS_WINDOWS_PHONE 1
#define GTEST_OS_WINDOWS_TV_TITLE 1
#elif WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_GAMES)
#define GTEST_OS_WINDOWS_GAMES 1
#else
// WINAPI_FAMILY defined but no known partition matched.
// Default to desktop.
#define GTEST_OS_WINDOWS_DESKTOP 1
#endif
#else
#define GTEST_OS_WINDOWS_DESKTOP 1
#endif  // _WIN32_WCE
#elif defined __OS2__
#define GTEST_OS_OS2 1
#elif defined __APPLE__
#define GTEST_OS_MAC 1
#include <TargetConditionals.h>
#if TARGET_OS_IPHONE
#define GTEST_OS_IOS 1
#endif
#elif defined __DragonFly__
#define GTEST_OS_DRAGONFLY 1
#elif defined __FreeBSD__
#define GTEST_OS_FREEBSD 1
#elif defined __Fuchsia__
#define GTEST_OS_FUCHSIA 1
#elif defined(__GNU__)
#define GTEST_OS_GNU_HURD 1
#elif defined(__GLIBC__) && defined(__FreeBSD_kernel__)
#define GTEST_OS_GNU_KFREEBSD 1
#elif defined __linux__
#define GTEST_OS_LINUX 1
#if defined __ANDROID__
#define GTEST_OS_LINUX_ANDROID 1
#endif
#elif defined __MVS__
#define GTEST_OS_ZOS 1
#elif defined(__sun) && defined(__SVR4)
#define GTEST_OS_SOLARIS 1
#elif defined(_AIX)
#define GTEST_OS_AIX 1
#elif defined(__hpux)
#define GTEST_OS_HPUX 1
#elif defined __native_client__

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/internal/gtest-filepath.h =====
// Copyright 2008, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Google Test filepath utilities
//
// This header file declares classes and functions used internally by
// Google Test.  They are subject to change without notice.
//
// This file is #included in gtest/internal/gtest-internal.h.
// Do not include this header file separately!

// IWYU pragma: private, include "gtest/gtest.h"
// IWYU pragma: friend gtest/.*
// IWYU pragma: friend gmock/.*

#ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_FILEPATH_H_
#define GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_FILEPATH_H_

#include <string>
#include <utility>

#include "gtest/internal/gtest-port.h"
#include "gtest/internal/gtest-string.h"

GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \
/* class A needs to have dll-interface to be used by clients of class B */)

#if GTEST_HAS_FILE_SYSTEM

namespace testing {
namespace internal {

// FilePath - a class for file and directory pathname manipulation which
// handles platform-specific conventions (like the pathname separator).
// Used for helper functions for naming files in a directory for xml output.
// Except for Set methods, all methods are const or static, which provides an
// "immutable value object" -- useful for peace of mind.
// A FilePath with a value ending in a path separator ("like/this/") represents
// a directory, otherwise it is assumed to represent a file. In either case,
// it may or may not represent an actual file or directory in the file system.
// Names are NOT checked for syntax correctness -- no checking for illegal
// characters, malformed paths, etc.

class GTEST_API_ FilePath {
 public:
  FilePath() : pathname_("") {}
  FilePath(const FilePath& rhs) : pathname_(rhs.pathname_) {}
  FilePath(FilePath&& rhs) noexcept : pathname_(std::move(rhs.pathname_)) {}

  explicit FilePath(std::string pathname) : pathname_(std::move(pathname)) {
    Normalize();
  }

  FilePath& operator=(const FilePath& rhs) {
    Set(rhs);
    return *this;
  }
  FilePath& operator=(FilePath&& rhs) noexcept {
    pathname_ = std::move(rhs.pathname_);
    return *this;
  }

  void Set(const FilePath& rhs) { pathname_ = rhs.pathname_; }

  const std::string& string() const { return pathname_; }
  const char* c_str() const { return pathname_.c_str(); }

  // Returns the current working directory, or "" if unsuccessful.
  static FilePath GetCurrentDir();

  // Given directory = "dir", base_name = "test", number = 0,
  // extension = "xml", returns "dir/test.xml". If number is greater
  // than zero (e.g., 12), returns "dir/test_12.xml".
  // On Windows platform, uses \ as the separator rather than /.

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/internal/gtest-param-util.h =====
// Copyright 2008 Google Inc.
// All Rights Reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Type and function utilities for implementing parameterized tests.

// IWYU pragma: private, include "gtest/gtest.h"
// IWYU pragma: friend gtest/.*
// IWYU pragma: friend gmock/.*

#ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_H_
#define GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_H_

#include <ctype.h>

#include <cassert>
#include <iterator>
#include <map>
#include <memory>
#include <ostream>
#include <set>
#include <string>
#include <tuple>
#include <type_traits>
#include <unordered_map>
#include <utility>
#include <vector>

#include "gtest/gtest-printers.h"
#include "gtest/gtest-test-part.h"
#include "gtest/internal/gtest-internal.h"
#include "gtest/internal/gtest-port.h"

namespace testing {
// Input to a parameterized test name generator, describing a test parameter.
// Consists of the parameter value and the integer parameter index.
template <class ParamType>
struct TestParamInfo {
  TestParamInfo(const ParamType& a_param, size_t an_index)
      : param(a_param), index(an_index) {}
  ParamType param;
  size_t index;
};

// A builtin parameterized test name generator which returns the result of
// testing::PrintToString.
struct PrintToStringParamName {
  template <class ParamType>
  std::string operator()(const TestParamInfo<ParamType>& info) const {
    return PrintToString(info.param);
  }
};

namespace internal {

// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.
// Utility Functions

// Outputs a message explaining invalid registration of different
// fixture class for the same test suite. This may happen when
// TEST_P macro is used to define two tests with the same name
// but in different namespaces.
GTEST_API_ void ReportInvalidTestSuiteType(const char* test_suite_name,
                                           const CodeLocation& code_location);

template <typename>
class ParamGeneratorInterface;
template <typename>
class ParamGenerator;

// Interface for iterating over elements provided by an implementation
// of ParamGeneratorInterface<T>.
template <typename T>
class ParamIteratorInterface {
 public:

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/internal/custom/gtest.h =====
// Copyright 2015, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Injection point for custom user configurations. See README for details
//
// ** Custom implementation starts here **

#ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_H_
#define GOOGLETEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_H_

#endif  // GOOGLETEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_H_

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/internal/custom/gtest-printers.h =====
// Copyright 2015, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// This file provides an injection point for custom printers in a local
// installation of gTest.
// It will be included from gtest-printers.h and the overrides in this file
// will be visible to everyone.
//
// Injection point for custom user configurations. See README for details
//
// ** Custom implementation starts here **

#ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PRINTERS_H_
#define GOOGLETEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PRINTERS_H_

#endif  // GOOGLETEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PRINTERS_H_

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/internal/custom/gtest-port.h =====
// Copyright 2015, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Injection point for custom user configurations. See README for details
//
// ** Custom implementation starts here **

#ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PORT_H_
#define GOOGLETEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PORT_H_

#endif  // GOOGLETEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PORT_H_

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/internal/gtest-string.h =====
// Copyright 2005, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// The Google C++ Testing and Mocking Framework (Google Test)
//
// This header file declares the String class and functions used internally by
// Google Test.  They are subject to change without notice. They should not used
// by code external to Google Test.
//
// This header file is #included by gtest-internal.h.
// It should not be #included by other files.

// IWYU pragma: private, include "gtest/gtest.h"
// IWYU pragma: friend gtest/.*
// IWYU pragma: friend gmock/.*

#ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_STRING_H_
#define GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_STRING_H_

#ifdef __BORLANDC__
// string.h is not guaranteed to provide strcpy on C++ Builder.
#include <mem.h>
#endif

#include <string.h>

#include <cstdint>
#include <sstream>
#include <string>

#include "gtest/internal/gtest-port.h"

namespace testing {
namespace internal {

// String - an abstract class holding static string utilities.
class GTEST_API_ String {
 public:
  // Static utility methods

  // Clones a 0-terminated C string, allocating memory using new.  The
  // caller is responsible for deleting the return value using
  // delete[].  Returns the cloned string, or NULL if the input is
  // NULL.
  //
  // This is different from strdup() in string.h, which allocates
  // memory using malloc().
  static const char* CloneCString(const char* c_str);

#ifdef GTEST_OS_WINDOWS_MOBILE
  // Windows CE does not have the 'ANSI' versions of Win32 APIs. To be
  // able to pass strings to Win32 APIs on CE we need to convert them
  // to 'Unicode', UTF-16.

  // Creates a UTF-16 wide string from the given ANSI string, allocating
  // memory using new. The caller is responsible for deleting the return
  // value using delete[]. Returns the wide string, or NULL if the
  // input is NULL.
  //
  // The wide string is created using the ANSI codepage (CP_ACP) to
  // match the behaviour of the ANSI versions of Win32 calls and the
  // C runtime.
  static LPCWSTR AnsiToUtf16(const char* c_str);

  // Creates an ANSI string from the given wide string, allocating
  // memory using new. The caller is responsible for deleting the return
  // value using delete[]. Returns the ANSI string, or NULL if the
  // input is NULL.
  //
  // The returned string is created using the ANSI codepage (CP_ACP) to
  // match the behaviour of the ANSI versions of Win32 calls and the
  // C runtime.
  static const char* Utf16ToAnsi(LPCWSTR utf16_str);
#endif

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/internal/gtest-death-test-internal.h =====
// Copyright 2005, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// The Google C++ Testing and Mocking Framework (Google Test)
//
// This header file defines internal utilities needed for implementing
// death tests.  They are subject to change without notice.

// IWYU pragma: private, include "gtest/gtest.h"
// IWYU pragma: friend gtest/.*
// IWYU pragma: friend gmock/.*

#ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_
#define GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_

#include <stdio.h>

#include <memory>
#include <string>

#include "gtest/gtest-matchers.h"
#include "gtest/internal/gtest-internal.h"
#include "gtest/internal/gtest-port.h"

GTEST_DECLARE_string_(internal_run_death_test);

namespace testing {
namespace internal {

// Name of the flag (needed for parsing Google Test flag).
const char kInternalRunDeathTestFlag[] = "internal_run_death_test";

// A string passed to EXPECT_DEATH (etc.) is caught by one of these overloads
// and interpreted as a regex (rather than an Eq matcher) for legacy
// compatibility.
inline Matcher<const ::std::string&> MakeDeathTestMatcher(
    ::testing::internal::RE regex) {
  return ContainsRegex(regex.pattern());
}
inline Matcher<const ::std::string&> MakeDeathTestMatcher(const char* regex) {
  return ContainsRegex(regex);
}
inline Matcher<const ::std::string&> MakeDeathTestMatcher(
    const ::std::string& regex) {
  return ContainsRegex(regex);
}

// If a Matcher<const ::std::string&> is passed to EXPECT_DEATH (etc.), it's
// used directly.
inline Matcher<const ::std::string&> MakeDeathTestMatcher(
    Matcher<const ::std::string&> matcher) {
  return matcher;
}

#ifdef GTEST_HAS_DEATH_TEST

GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \
/* class A needs to have dll-interface to be used by clients of class B */)

// DeathTest is a class that hides much of the complexity of the
// GTEST_DEATH_TEST_ macro.  It is abstract; its static Create method
// returns a concrete class that depends on the prevailing death test
// style, as defined by the --gtest_death_test_style and/or
// --gtest_internal_run_death_test flags.

// In describing the results of death tests, these terms are used with
// the corresponding definitions:
//
// exit status:  The integer exit information in the format specified
//               by wait(2)
// exit code:    The integer code passed to exit(3), _Exit(2), or
//               returned from main()
class GTEST_API_ DeathTest {
 public:

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h =====
// Copyright 2005, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// The Google C++ Testing and Mocking Framework (Google Test)
//
// This header file declares functions and macros used internally by
// Google Test.  They are subject to change without notice.

// IWYU pragma: private, include "gtest/gtest.h"
// IWYU pragma: friend gtest/.*
// IWYU pragma: friend gmock/.*

#ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_
#define GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_

#include "gtest/internal/gtest-port.h"

#ifdef GTEST_OS_LINUX
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#endif  // GTEST_OS_LINUX

#if GTEST_HAS_EXCEPTIONS
#include <stdexcept>
#endif

#include <ctype.h>
#include <float.h>
#include <string.h>

#include <cstdint>
#include <functional>
#include <limits>
#include <map>
#include <set>
#include <string>
#include <type_traits>
#include <utility>
#include <vector>

#include "gtest/gtest-message.h"
#include "gtest/internal/gtest-filepath.h"
#include "gtest/internal/gtest-string.h"
#include "gtest/internal/gtest-type-util.h"

// Due to C++ preprocessor weirdness, we need double indirection to
// concatenate two tokens when one of them is __LINE__.  Writing
//
//   foo ## __LINE__
//
// will result in the token foo__LINE__, instead of foo followed by
// the current line number.  For more details, see
// https://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.6
#define GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar)
#define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo##bar

// Stringifies its argument.
// Work around a bug in visual studio which doesn't accept code like this:
//
//   #define GTEST_STRINGIFY_(name) #name
//   #define MACRO(a, b, c) ... GTEST_STRINGIFY_(a) ...
//   MACRO(, x, y)
//
// Complaining about the argument to GTEST_STRINGIFY_ being empty.
// This is allowed by the spec.
#define GTEST_STRINGIFY_HELPER_(name, ...) #name
#define GTEST_STRINGIFY_(...) GTEST_STRINGIFY_HELPER_(__VA_ARGS__, )

namespace proto2 {
class MessageLite;
}


===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/internal/gtest-port.h =====
// Copyright 2005, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Low-level types and utilities for porting Google Test to various
// platforms.  All macros ending with _ and symbols defined in an
// internal namespace are subject to change without notice.  Code
// outside Google Test MUST NOT USE THEM DIRECTLY.  Macros that don't
// end with _ are part of Google Test's public API and can be used by
// code outside Google Test.
//
// This file is fundamental to Google Test.  All other Google Test source
// files are expected to #include this.  Therefore, it cannot #include
// any other Google Test header.

// IWYU pragma: private, include "gtest/gtest.h"
// IWYU pragma: friend gtest/.*
// IWYU pragma: friend gmock/.*

#ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_
#define GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_

// Environment-describing macros
// -----------------------------
//
// Google Test can be used in many different environments.  Macros in
// this section tell Google Test what kind of environment it is being
// used in, such that Google Test can provide environment-specific
// features and implementations.
//
// Google Test tries to automatically detect the properties of its
// environment, so users usually don't need to worry about these
// macros.  However, the automatic detection is not perfect.
// Sometimes it's necessary for a user to define some of the following
// macros in the build script to override Google Test's decisions.
//
// If the user doesn't define a macro in the list, Google Test will
// provide a default definition.  After this header is #included, all
// macros in this list will be defined to either 1 or 0.
//
// Notes to maintainers:
//   - Each macro here is a user-tweakable knob; do not grow the list
//     lightly.
//   - Use #if to key off these macros.  Don't use #ifdef or "#if
//     defined(...)", which will not work as these macros are ALWAYS
//     defined.
//
//   GTEST_HAS_CLONE          - Define it to 1/0 to indicate that clone(2)
//                              is/isn't available.
//   GTEST_HAS_EXCEPTIONS     - Define it to 1/0 to indicate that exceptions
//                              are enabled.
//   GTEST_HAS_POSIX_RE       - Define it to 1/0 to indicate that POSIX regular
//                              expressions are/aren't available.
//   GTEST_HAS_PTHREAD        - Define it to 1/0 to indicate that <pthread.h>
//                              is/isn't available.
//   GTEST_HAS_RTTI           - Define it to 1/0 to indicate that RTTI is/isn't
//                              enabled.
//   GTEST_HAS_STD_WSTRING    - Define it to 1/0 to indicate that
//                              std::wstring does/doesn't work (Google Test can
//                              be used where std::wstring is unavailable).
//   GTEST_HAS_FILE_SYSTEM    - Define it to 1/0 to indicate whether or not a
//                              file system is/isn't available.
//   GTEST_HAS_SEH            - Define it to 1/0 to indicate whether the
//                              compiler supports Microsoft's "Structured
//                              Exception Handling".
//   GTEST_HAS_STREAM_REDIRECTION
//                            - Define it to 1/0 to indicate whether the
//                              platform supports I/O stream redirection using
//                              dup() and dup2().
//   GTEST_LINKED_AS_SHARED_LIBRARY
//                            - Define to 1 when compiling tests that use
//                              Google Test as a shared library (known as
//                              DLL on Windows).
//   GTEST_CREATE_SHARED_LIBRARY
//                            - Define to 1 when compiling Google Test itself

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/gtest-assertion-result.h =====
// Copyright 2005, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// The Google C++ Testing and Mocking Framework (Google Test)
//
// This file implements the AssertionResult type.

// IWYU pragma: private, include "gtest/gtest.h"
// IWYU pragma: friend gtest/.*
// IWYU pragma: friend gmock/.*

#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_ASSERTION_RESULT_H_
#define GOOGLETEST_INCLUDE_GTEST_GTEST_ASSERTION_RESULT_H_

#include <memory>
#include <ostream>
#include <string>
#include <type_traits>

#include "gtest/gtest-message.h"
#include "gtest/internal/gtest-port.h"

GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251                                   \
/* class A needs to have dll-interface to be used by clients of class B */)

namespace testing {

// A class for indicating whether an assertion was successful.  When
// the assertion wasn't successful, the AssertionResult object
// remembers a non-empty message that describes how it failed.
//
// To create an instance of this class, use one of the factory functions
// (AssertionSuccess() and AssertionFailure()).
//
// This class is useful for two purposes:
//   1. Defining predicate functions to be used with Boolean test assertions
//      EXPECT_TRUE/EXPECT_FALSE and their ASSERT_ counterparts
//   2. Defining predicate-format functions to be
//      used with predicate assertions (ASSERT_PRED_FORMAT*, etc).
//
// For example, if you define IsEven predicate:
//
//   testing::AssertionResult IsEven(int n) {
//     if ((n % 2) == 0)
//       return testing::AssertionSuccess();
//     else
//       return testing::AssertionFailure() << n << " is odd";
//   }
//
// Then the failed expectation EXPECT_TRUE(IsEven(Fib(5)))
// will print the message
//
//   Value of: IsEven(Fib(5))
//     Actual: false (5 is odd)
//   Expected: true
//
// instead of a more opaque
//
//   Value of: IsEven(Fib(5))
//     Actual: false
//   Expected: true
//
// in case IsEven is a simple Boolean predicate.
//
// If you expect your predicate to be reused and want to support informative
// messages in EXPECT_FALSE and ASSERT_FALSE (negative assertions show up
// about half as often as positive ones in our tests), supply messages for
// both success and failure cases:
//
//   testing::AssertionResult IsEven(int n) {
//     if ((n % 2) == 0)
//       return testing::AssertionSuccess() << n << " is even";
//     else
//       return testing::AssertionFailure() << n << " is odd";

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/gtest-typed-test.h =====
// Copyright 2008 Google Inc.
// All Rights Reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// IWYU pragma: private, include "gtest/gtest.h"
// IWYU pragma: friend gtest/.*
// IWYU pragma: friend gmock/.*

#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_TYPED_TEST_H_
#define GOOGLETEST_INCLUDE_GTEST_GTEST_TYPED_TEST_H_

// This header implements typed tests and type-parameterized tests.

// Typed (aka type-driven) tests repeat the same test for types in a
// list.  You must know which types you want to test with when writing
// typed tests. Here's how you do it:

#if 0

// First, define a fixture class template.  It should be parameterized
// by a type.  Remember to derive it from testing::Test.
template <typename T>
class FooTest : public testing::Test {
 public:
  ...
  typedef std::list<T> List;
  static T shared_;
  T value_;
};

// Next, associate a list of types with the test suite, which will be
// repeated for each type in the list.  The typedef is necessary for
// the macro to parse correctly.
typedef testing::Types<char, int, unsigned int> MyTypes;
TYPED_TEST_SUITE(FooTest, MyTypes);

// If the type list contains only one type, you can write that type
// directly without Types<...>:
//   TYPED_TEST_SUITE(FooTest, int);

// Then, use TYPED_TEST() instead of TEST_F() to define as many typed
// tests for this test suite as you want.
TYPED_TEST(FooTest, DoesBlah) {
  // Inside a test, refer to the special name TypeParam to get the type
  // parameter.  Since we are inside a derived class template, C++ requires
  // us to visit the members of FooTest via 'this'.
  TypeParam n = this->value_;

  // To visit static members of the fixture, add the TestFixture::
  // prefix.
  n += TestFixture::shared_;

  // To refer to typedefs in the fixture, add the "typename
  // TestFixture::" prefix.
  typename TestFixture::List values;
  values.push_back(n);
  ...
}

TYPED_TEST(FooTest, HasPropertyA) { ... }

// TYPED_TEST_SUITE takes an optional third argument which allows to specify a
// class that generates custom test name suffixes based on the type. This should
// be a class which has a static template function GetName(int index) returning
// a string for each type. The provided integer index equals the index of the
// type in the provided type list. In many cases the index can be ignored.
//
// For example:
//   class MyTypeNames {
//    public:
//     template <typename T>
//     static std::string GetName(int) {
//       if (std::is_same<T, char>()) return "char";
//       if (std::is_same<T, int>()) return "int";
//       if (std::is_same<T, unsigned int>()) return "unsignedInt";

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/gtest-death-test.h =====
// Copyright 2005, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// The Google C++ Testing and Mocking Framework (Google Test)
//
// This header file defines the public API for death tests.  It is
// #included by gtest.h so a user doesn't need to include this
// directly.

// IWYU pragma: private, include "gtest/gtest.h"
// IWYU pragma: friend gtest/.*
// IWYU pragma: friend gmock/.*

#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_DEATH_TEST_H_
#define GOOGLETEST_INCLUDE_GTEST_GTEST_DEATH_TEST_H_

#include "gtest/internal/gtest-death-test-internal.h"

// This flag controls the style of death tests.  Valid values are "threadsafe",
// meaning that the death test child process will re-execute the test binary
// from the start, running only a single death test, or "fast",
// meaning that the child process will execute the test logic immediately
// after forking.
GTEST_DECLARE_string_(death_test_style);

namespace testing {

#ifdef GTEST_HAS_DEATH_TEST

namespace internal {

// Returns a Boolean value indicating whether the caller is currently
// executing in the context of the death test child process.  Tools such as
// Valgrind heap checkers may need this to modify their behavior in death
// tests.  IMPORTANT: This is an internal utility.  Using it may break the
// implementation of death tests.  User code MUST NOT use it.
GTEST_API_ bool InDeathTestChild();

}  // namespace internal

// The following macros are useful for writing death tests.

// Here's what happens when an ASSERT_DEATH* or EXPECT_DEATH* is
// executed:
//
//   1. It generates a warning if there is more than one active
//   thread.  This is because it's safe to fork() or clone() only
//   when there is a single thread.
//
//   2. The parent process clone()s a sub-process and runs the death
//   test in it; the sub-process exits with code 0 at the end of the
//   death test, if it hasn't exited already.
//
//   3. The parent process waits for the sub-process to terminate.
//
//   4. The parent process checks the exit code and error message of
//   the sub-process.
//
// Examples:
//
//   ASSERT_DEATH(server.SendMessage(56, "Hello"), "Invalid port number");
//   for (int i = 0; i < 5; i++) {
//     EXPECT_DEATH(server.ProcessRequest(i),
//                  "Invalid request .* in ProcessRequest()")
//                  << "Failed to die on request " << i;
//   }
//
//   ASSERT_EXIT(server.ExitNow(), ::testing::ExitedWithCode(0), "Exiting");
//
//   bool KilledBySIGHUP(int exit_code) {
//     return WIFSIGNALED(exit_code) && WTERMSIG(exit_code) == SIGHUP;
//   }
//
//   ASSERT_EXIT(client.HangUpServer(), KilledBySIGHUP, "Hanging up!");

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/gtest_prod.h =====
// Copyright 2006, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Google C++ Testing and Mocking Framework definitions useful in production
// code.

#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_PROD_H_
#define GOOGLETEST_INCLUDE_GTEST_GTEST_PROD_H_

// When you need to test the private or protected members of a class,
// use the FRIEND_TEST macro to declare your tests as friends of the
// class.  For example:
//
// class MyClass {
//  private:
//   void PrivateMethod();
//   FRIEND_TEST(MyClassTest, PrivateMethodWorks);
// };
//
// class MyClassTest : public testing::Test {
//   // ...
// };
//
// TEST_F(MyClassTest, PrivateMethodWorks) {
//   // Can call MyClass::PrivateMethod() here.
// }
//
// Note: The test class must be in the same namespace as the class being tested.
// For example, putting MyClassTest in an anonymous namespace will not work.

#define FRIEND_TEST(test_case_name, test_name) \
  friend class test_case_name##_##test_name##_Test

#endif  // GOOGLETEST_INCLUDE_GTEST_GTEST_PROD_H_

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/gtest.h =====
// Copyright 2005, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// The Google C++ Testing and Mocking Framework (Google Test)
//
// This header file defines the public API for Google Test.  It should be
// included by any test program that uses Google Test.
//
// IMPORTANT NOTE: Due to limitation of the C++ language, we have to
// leave some internal implementation details in this header file.
// They are clearly marked by comments like this:
//
//   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.
//
// Such code is NOT meant to be used by a user directly, and is subject
// to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user
// program!
//
// Acknowledgment: Google Test borrowed the idea of automatic test
// registration from Barthelemy Dagenais' (barthelemy@prologique.com)
// easyUnit framework.

#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_H_
#define GOOGLETEST_INCLUDE_GTEST_GTEST_H_

#include <cstddef>
#include <cstdint>
#include <limits>
#include <memory>
#include <ostream>
#include <set>
#include <sstream>
#include <string>
#include <type_traits>
#include <vector>

#include "gtest/gtest-assertion-result.h"  // IWYU pragma: export
#include "gtest/gtest-death-test.h"  // IWYU pragma: export
#include "gtest/gtest-matchers.h"  // IWYU pragma: export
#include "gtest/gtest-message.h"  // IWYU pragma: export
#include "gtest/gtest-param-test.h"  // IWYU pragma: export
#include "gtest/gtest-printers.h"  // IWYU pragma: export
#include "gtest/gtest-test-part.h"  // IWYU pragma: export
#include "gtest/gtest-typed-test.h"  // IWYU pragma: export
#include "gtest/gtest_pred_impl.h"  // IWYU pragma: export
#include "gtest/gtest_prod.h"  // IWYU pragma: export
#include "gtest/internal/gtest-internal.h"
#include "gtest/internal/gtest-string.h"

GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \
/* class A needs to have dll-interface to be used by clients of class B */)

// Declares the flags.

// This flag temporary enables the disabled tests.
GTEST_DECLARE_bool_(also_run_disabled_tests);

// This flag brings the debugger on an assertion failure.
GTEST_DECLARE_bool_(break_on_failure);

// This flag controls whether Google Test catches all test-thrown exceptions
// and logs them as failures.
GTEST_DECLARE_bool_(catch_exceptions);

// This flag enables using colors in terminal output. Available values are
// "yes" to enable colors, "no" (disable colors), or "auto" (the default)
// to let Google Test decide.
GTEST_DECLARE_string_(color);

// This flag controls whether the test runner should continue execution past
// first failure.
GTEST_DECLARE_bool_(fail_fast);

// This flag sets up the filter to select by name using a glob pattern

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/gtest-message.h =====
// Copyright 2005, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// The Google C++ Testing and Mocking Framework (Google Test)
//
// This header file defines the Message class.
//
// IMPORTANT NOTE: Due to limitation of the C++ language, we have to
// leave some internal implementation details in this header file.
// They are clearly marked by comments like this:
//
//   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.
//
// Such code is NOT meant to be used by a user directly, and is subject
// to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user
// program!

// IWYU pragma: private, include "gtest/gtest.h"
// IWYU pragma: friend gtest/.*
// IWYU pragma: friend gmock/.*

#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_MESSAGE_H_
#define GOOGLETEST_INCLUDE_GTEST_GTEST_MESSAGE_H_

#include <limits>
#include <memory>
#include <ostream>
#include <sstream>
#include <string>

#include "gtest/internal/gtest-port.h"

#ifdef GTEST_HAS_ABSL
#include <type_traits>

#include "absl/strings/has_absl_stringify.h"
#include "absl/strings/str_cat.h"
#endif  // GTEST_HAS_ABSL

GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \
/* class A needs to have dll-interface to be used by clients of class B */)

// Ensures that there is at least one operator<< in the global namespace.
// See Message& operator<<(...) below for why.
void operator<<(const testing::internal::Secret&, int);

namespace testing {

// The Message class works like an ostream repeater.
//
// Typical usage:
//
//   1. You stream a bunch of values to a Message object.
//      It will remember the text in a stringstream.
//   2. Then you stream the Message object to an ostream.
//      This causes the text in the Message to be streamed
//      to the ostream.
//
// For example;
//
//   testing::Message foo;
//   foo << 1 << " != " << 2;
//   std::cout << foo;
//
// will print "1 != 2".
//
// Message is not intended to be inherited from.  In particular, its
// destructor is not virtual.
//
// Note that stringstream behaves differently in gcc and in MSVC.  You
// can stream a NULL char pointer to it in the former, but not in the
// latter (it causes an access violation if you do).  The Message
// class hides this difference by treating a NULL char pointer as
// "(null)".

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/gtest-param-test.h =====
// Copyright 2008, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Macros and functions for implementing parameterized tests
// in Google C++ Testing and Mocking Framework (Google Test)

// IWYU pragma: private, include "gtest/gtest.h"
// IWYU pragma: friend gtest/.*
// IWYU pragma: friend gmock/.*

#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_
#define GOOGLETEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_

// Value-parameterized tests allow you to test your code with different
// parameters without writing multiple copies of the same test.
//
// Here is how you use value-parameterized tests:

#if 0

// To write value-parameterized tests, first you should define a fixture
// class. It is usually derived from testing::TestWithParam<T> (see below for
// another inheritance scheme that's sometimes useful in more complicated
// class hierarchies), where the type of your parameter values.
// TestWithParam<T> is itself derived from testing::Test. T can be any
// copyable type. If it's a raw pointer, you are responsible for managing the
// lifespan of the pointed values.

class FooTest : public ::testing::TestWithParam<const char*> {
  // You can implement all the usual class fixture members here.
};

// Then, use the TEST_P macro to define as many parameterized tests
// for this fixture as you want. The _P suffix is for "parameterized"
// or "pattern", whichever you prefer to think.

TEST_P(FooTest, DoesBlah) {
  // Inside a test, access the test parameter with the GetParam() method
  // of the TestWithParam<T> class:
  EXPECT_TRUE(foo.Blah(GetParam()));
  ...
}

TEST_P(FooTest, HasBlahBlah) {
  ...
}

// Finally, you can use INSTANTIATE_TEST_SUITE_P to instantiate the test
// case with any set of parameters you want. Google Test defines a number
// of functions for generating test parameters. They return what we call
// (surprise!) parameter generators. Here is a summary of them, which
// are all in the testing namespace:
//
//
//  Range(begin, end [, step]) - Yields values {begin, begin+step,
//                               begin+step+step, ...}. The values do not
//                               include end. step defaults to 1.
//  Values(v1, v2, ..., vN)    - Yields values {v1, v2, ..., vN}.
//  ValuesIn(container)        - Yields values from a C-style array, an STL
//  ValuesIn(begin,end)          container, or an iterator range [begin, end).
//  Bool()                     - Yields sequence {false, true}.
//  Combine(g1, g2, ..., gN)   - Yields all combinations (the Cartesian product
//                               for the math savvy) of the values generated
//                               by the N generators.
//
// For more details, see comments at the definitions of these functions below
// in this file.
//
// The following statement will instantiate tests from the FooTest test suite
// each with parameter values "meeny", "miny", and "moe".

INSTANTIATE_TEST_SUITE_P(InstantiationName,
                         FooTest,
                         Values("meeny", "miny", "moe"));

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/gtest-printers.h =====
// Copyright 2007, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Google Test - The Google C++ Testing and Mocking Framework
//
// This file implements a universal value printer that can print a
// value of any type T:
//
//   void ::testing::internal::UniversalPrinter<T>::Print(value, ostream_ptr);
//
// A user can teach this function how to print a class type T by
// defining either operator<<() or PrintTo() in the namespace that
// defines T.  More specifically, the FIRST defined function in the
// following list will be used (assuming T is defined in namespace
// foo):
//
//   1. foo::PrintTo(const T&, ostream*)
//   2. operator<<(ostream&, const T&) defined in either foo or the
//      global namespace.
// * Prefer AbslStringify(..) to operator<<(..), per https://abseil.io/tips/215.
// * Define foo::PrintTo(..) if the type already has AbslStringify(..), but an
//   alternative presentation in test results is of interest.
//
// However if T is an STL-style container then it is printed element-wise
// unless foo::PrintTo(const T&, ostream*) is defined. Note that
// operator<<() is ignored for container types.
//
// If none of the above is defined, it will print the debug string of
// the value if it is a protocol buffer, or print the raw bytes in the
// value otherwise.
//
// To aid debugging: when T is a reference type, the address of the
// value is also printed; when T is a (const) char pointer, both the
// pointer value and the NUL-terminated string it points to are
// printed.
//
// We also provide some convenient wrappers:
//
//   // Prints a value to a string.  For a (const or not) char
//   // pointer, the NUL-terminated string (but not the pointer) is
//   // printed.
//   std::string ::testing::PrintToString(const T& value);
//
//   // Prints a value tersely: for a reference type, the referenced
//   // value (but not the address) is printed; for a (const or not) char
//   // pointer, the NUL-terminated string (but not the pointer) is
//   // printed.
//   void ::testing::internal::UniversalTersePrint(const T& value, ostream*);
//
//   // Prints value using the type inferred by the compiler.  The difference
//   // from UniversalTersePrint() is that this function prints both the
//   // pointer and the NUL-terminated string for a (const or not) char pointer.
//   void ::testing::internal::UniversalPrint(const T& value, ostream*);
//
//   // Prints the fields of a tuple tersely to a string vector, one
//   // element for each field. Tuple support must be enabled in
//   // gtest-port.h.
//   std::vector<string> UniversalTersePrintTupleFieldsToStrings(
//       const Tuple& value);
//
// Known limitation:
//
// The print primitives print the elements of an STL-style container
// using the compiler-inferred type of *iter where iter is a
// const_iterator of the container.  When const_iterator is an input
// iterator but not a forward iterator, this inferred type may not
// match value_type, and the print output may be incorrect.  In
// practice, this is rarely a problem as for most containers
// const_iterator is a forward iterator.  We'll fix this if there's an
// actual need for it.  Note that this fix cannot rely on value_type
// being defined as many user-defined container types don't have
// value_type.

// IWYU pragma: private, include "gtest/gtest.h"

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/gtest_pred_impl.h =====
// Copyright 2006, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Implements a family of generic predicate assertion macros.

// IWYU pragma: private, include "gtest/gtest.h"
// IWYU pragma: friend gtest/.*
// IWYU pragma: friend gmock/.*

#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_PRED_IMPL_H_
#define GOOGLETEST_INCLUDE_GTEST_GTEST_PRED_IMPL_H_

#include "gtest/gtest-assertion-result.h"
#include "gtest/internal/gtest-internal.h"
#include "gtest/internal/gtest-port.h"

namespace testing {

// This header implements a family of generic predicate assertion
// macros:
//
//   ASSERT_PRED_FORMAT1(pred_format, v1)
//   ASSERT_PRED_FORMAT2(pred_format, v1, v2)
//   ...
//
// where pred_format is a function or functor that takes n (in the
// case of ASSERT_PRED_FORMATn) values and their source expression
// text, and returns a testing::AssertionResult.  See the definition
// of ASSERT_EQ in gtest.h for an example.
//
// If you don't care about formatting, you can use the more
// restrictive version:
//
//   ASSERT_PRED1(pred, v1)
//   ASSERT_PRED2(pred, v1, v2)
//   ...
//
// where pred is an n-ary function or functor that returns bool,
// and the values v1, v2, ..., must support the << operator for
// streaming to std::ostream.
//
// We also define the EXPECT_* variations.
//
// For now we only support predicates whose arity is at most 5.
// Please email googletestframework@googlegroups.com if you need
// support for higher arities.

// GTEST_ASSERT_ is the basic statement to which all of the assertions
// in this file reduce.  Don't use this in your code.

#define GTEST_ASSERT_(expression, on_failure)                   \
  GTEST_AMBIGUOUS_ELSE_BLOCKER_                                 \
  if (const ::testing::AssertionResult gtest_ar = (expression)) \
    ;                                                           \
  else                                                          \
    on_failure(gtest_ar.failure_message())

// Helper function for implementing {EXPECT|ASSERT}_PRED1.  Don't use
// this in your code.
template <typename Pred, typename T1>
AssertionResult AssertPred1Helper(const char* pred_text, const char* e1,
                                  Pred pred, const T1& v1) {
  if (pred(v1)) return AssertionSuccess();

  return AssertionFailure()
         << pred_text << "(" << e1 << ") evaluates to false, where"
         << "\n"
         << e1 << " evaluates to " << ::testing::PrintToString(v1);
}

// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT1.
// Don't use this in your code.
#define GTEST_PRED_FORMAT1_(pred_format, v1, on_failure) \
  GTEST_ASSERT_(pred_format(#v1, v1), on_failure)

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/gtest-matchers.h =====
// Copyright 2007, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// The Google C++ Testing and Mocking Framework (Google Test)
//
// This file implements just enough of the matcher interface to allow
// EXPECT_DEATH and friends to accept a matcher argument.

// IWYU pragma: private, include "gtest/gtest.h"
// IWYU pragma: friend gtest/.*
// IWYU pragma: friend gmock/.*

#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_MATCHERS_H_
#define GOOGLETEST_INCLUDE_GTEST_GTEST_MATCHERS_H_

#include <atomic>
#include <functional>
#include <memory>
#include <ostream>
#include <string>
#include <type_traits>

#include "gtest/gtest-printers.h"
#include "gtest/internal/gtest-internal.h"
#include "gtest/internal/gtest-port.h"

// MSVC warning C5046 is new as of VS2017 version 15.8.
#if defined(_MSC_VER) && _MSC_VER >= 1915
#define GTEST_MAYBE_5046_ 5046
#else
#define GTEST_MAYBE_5046_
#endif

GTEST_DISABLE_MSC_WARNINGS_PUSH_(
    4251 GTEST_MAYBE_5046_ /* class A needs to have dll-interface to be used by
                              clients of class B */
    /* Symbol involving type with internal linkage not defined */)

namespace testing {

// To implement a matcher Foo for type T, define:
//   1. a class FooMatcherMatcher that implements the matcher interface:
//     using is_gtest_matcher = void;
//     bool MatchAndExplain(const T&, std::ostream*);
//       (MatchResultListener* can also be used instead of std::ostream*)
//     void DescribeTo(std::ostream*);
//     void DescribeNegationTo(std::ostream*);
//
//   2. a factory function that creates a Matcher<T> object from a
//      FooMatcherMatcher.

class MatchResultListener {
 public:
  // Creates a listener object with the given underlying ostream.  The
  // listener does not own the ostream, and does not dereference it
  // in the constructor or destructor.
  explicit MatchResultListener(::std::ostream* os) : stream_(os) {}
  virtual ~MatchResultListener() = 0;  // Makes this class abstract.

  // Streams x to the underlying ostream; does nothing if the ostream
  // is NULL.
  template <typename T>
  MatchResultListener& operator<<(const T& x) {
    if (stream_ != nullptr) *stream_ << x;
    return *this;
  }

  // Returns the underlying ostream.
  ::std::ostream* stream() { return stream_; }

  // Returns true if and only if the listener is interested in an explanation
  // of the match result.  A matcher's MatchAndExplain() method can use
  // this information to avoid generating the explanation when no one
  // intends to hear it.

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/include/gtest/gtest-test-part.h =====
// Copyright 2008, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// IWYU pragma: private, include "gtest/gtest.h"
// IWYU pragma: friend gtest/.*
// IWYU pragma: friend gmock/.*

#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_TEST_PART_H_
#define GOOGLETEST_INCLUDE_GTEST_GTEST_TEST_PART_H_

#include <iosfwd>
#include <ostream>
#include <string>
#include <vector>

#include "gtest/internal/gtest-internal.h"
#include "gtest/internal/gtest-string.h"

GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \
/* class A needs to have dll-interface to be used by clients of class B */)

namespace testing {

// A copyable object representing the result of a test part (i.e. an
// assertion or an explicit FAIL(), ADD_FAILURE(), or SUCCESS()).
//
// Don't inherit from TestPartResult as its destructor is not virtual.
class GTEST_API_ TestPartResult {
 public:
  // The possible outcomes of a test part (i.e. an assertion or an
  // explicit SUCCEED(), FAIL(), or ADD_FAILURE()).
  enum Type {
    kSuccess,          // Succeeded.
    kNonFatalFailure,  // Failed but the test can continue.
    kFatalFailure,     // Failed and the test should be terminated.
    kSkip              // Skipped.
  };

  // C'tor.  TestPartResult does NOT have a default constructor.
  // Always use this constructor (with parameters) to create a
  // TestPartResult object.
  TestPartResult(Type a_type, const char* a_file_name, int a_line_number,
                 const char* a_message)
      : type_(a_type),
        file_name_(a_file_name == nullptr ? "" : a_file_name),
        line_number_(a_line_number),
        summary_(ExtractSummary(a_message)),
        message_(a_message) {}

  // Gets the outcome of the test part.
  Type type() const { return type_; }

  // Gets the name of the source file where the test part took place, or
  // NULL if it's unknown.
  const char* file_name() const {
    return file_name_.empty() ? nullptr : file_name_.c_str();
  }

  // Gets the line in the source file where the test part took place,
  // or -1 if it's unknown.
  int line_number() const { return line_number_; }

  // Gets the summary of the failure message.
  const char* summary() const { return summary_.c_str(); }

  // Gets the message associated with the test part.
  const char* message() const { return message_.c_str(); }

  // Returns true if and only if the test part was skipped.
  bool skipped() const { return type_ == kSkip; }

  // Returns true if and only if the test part passed.
  bool passed() const { return type_ == kSuccess; }


===== FILE: ./tests/md/build/_deps/googletest-src/googletest/test/production.h =====
// Copyright 2006, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//
// This is part of the unit test for gtest_prod.h.

#ifndef GOOGLETEST_TEST_PRODUCTION_H_
#define GOOGLETEST_TEST_PRODUCTION_H_

#include "gtest/gtest_prod.h"

class PrivateCode {
 public:
  // Declares a friend test that does not use a fixture.
  FRIEND_TEST(PrivateCodeTest, CanAccessPrivateMembers);

  // Declares a friend test that uses a fixture.
  FRIEND_TEST(PrivateCodeFixtureTest, CanAccessPrivateMembers);

  PrivateCode();

  int x() const { return x_; }

 private:
  void set_x(int an_x) { x_ = an_x; }
  int x_;
};

#endif  // GOOGLETEST_TEST_PRODUCTION_H_

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/test/googletest-param-test-test.h =====
// Copyright 2008, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// The Google C++ Testing and Mocking Framework (Google Test)
//
// This header file provides classes and functions used internally
// for testing Google Test itself.

#ifndef GOOGLETEST_TEST_GOOGLETEST_PARAM_TEST_TEST_H_
#define GOOGLETEST_TEST_GOOGLETEST_PARAM_TEST_TEST_H_

#include "gtest/gtest.h"

// Test fixture for testing definition and instantiation of a test
// in separate translation units.
class ExternalInstantiationTest : public ::testing::TestWithParam<int> {};

// Test fixture for testing instantiation of a test in multiple
// translation units.
class InstantiationInMultipleTranslationUnitsTest
    : public ::testing::TestWithParam<int> {};

#endif  // GOOGLETEST_TEST_GOOGLETEST_PARAM_TEST_TEST_H_

===== FILE: ./tests/md/build/_deps/googletest-src/googletest/test/gtest-typed-test_test.h =====
// Copyright 2008 Google Inc.
// All Rights Reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#ifndef GOOGLETEST_TEST_GTEST_TYPED_TEST_TEST_H_
#define GOOGLETEST_TEST_GTEST_TYPED_TEST_TEST_H_

#include "gtest/gtest.h"

using testing::Test;

// For testing that the same type-parameterized test case can be
// instantiated in different translation units linked together.
// ContainerTest will be instantiated in both gtest-typed-test_test.cc
// and gtest-typed-test2_test.cc.

template <typename T>
class ContainerTest : public Test {};

TYPED_TEST_SUITE_P(ContainerTest);

TYPED_TEST_P(ContainerTest, CanBeDefaultConstructed) { TypeParam container; }

TYPED_TEST_P(ContainerTest, InitialSizeIsZero) {
  TypeParam container;
  EXPECT_EQ(0U, container.size());
}

REGISTER_TYPED_TEST_SUITE_P(ContainerTest, CanBeDefaultConstructed,
                            InitialSizeIsZero);

#endif  // GOOGLETEST_TEST_GTEST_TYPED_TEST_TEST_H_

===== FILE: ./tests/md/test_md_core.cpp =====
#include "../../b3-md-connector/src/core/BookSnapshot.hpp"
#include "../../b3-md-connector/src/core/SnapshotQueueSpsc.hpp"
#include <gtest/gtest.h>
#include <thread>
#include <vector>
#include <atomic>

using b3::md::BookSnapshot;
using b3::md::SnapshotQueueSpsc;

// ============================================================================
// TopNBookSnapshot Tests
// ============================================================================

TEST(TopNBookSnapshotTests, IsTriviallyCopyable) {
    EXPECT_TRUE(std::is_trivially_copyable_v<BookSnapshot>);
}

TEST(TopNBookSnapshotTests, IsTriviallyDestructible) {
    EXPECT_TRUE(std::is_trivially_destructible_v<BookSnapshot>);
}

TEST(TopNBookSnapshotTests, DefaultConstruction) {
    BookSnapshot s{};

    EXPECT_EQ(s.instrumentId, 0);
    EXPECT_EQ(s.exchangeTsNs, 0);
    EXPECT_EQ(s.bidCount, 0);
    EXPECT_EQ(s.askCount, 0);

    // Verify all levels are zeroed
    for (int i = 0; i < 5; ++i) {
        EXPECT_EQ(s.bids[i].price, 0);
        EXPECT_EQ(s.bids[i].qty, 0);
        EXPECT_EQ(s.asks[i].price, 0);
        EXPECT_EQ(s.asks[i].qty, 0);
    }
}

TEST(TopNBookSnapshotTests, DataAssignment) {
    BookSnapshot snapshot;

    snapshot.instrumentId = 12345;
    snapshot.exchangeTsNs = 1234567890123456789ULL;
    snapshot.bidCount = 3;
    snapshot.askCount = 2;

    // Set bid levels
    snapshot.bids[0] = {100000, 1000};
    snapshot.bids[1] = {99500, 1500};
    snapshot.bids[2] = {99000, 2000};

    // Set ask levels
    snapshot.asks[0] = {100500, 800};
    snapshot.asks[1] = {101000, 1200};

    EXPECT_EQ(snapshot.instrumentId, 12345);
    EXPECT_EQ(snapshot.exchangeTsNs, 1234567890123456789ULL);
    EXPECT_EQ(snapshot.bidCount, 3);
    EXPECT_EQ(snapshot.askCount, 2);

    EXPECT_EQ(snapshot.bids[0].price, 100000);
    EXPECT_EQ(snapshot.bids[0].qty, 1000);
    EXPECT_EQ(snapshot.bids[1].price, 99500);
    EXPECT_EQ(snapshot.bids[1].qty, 1500);
    EXPECT_EQ(snapshot.bids[2].price, 99000);
    EXPECT_EQ(snapshot.bids[2].qty, 2000);

    EXPECT_EQ(snapshot.asks[0].price, 100500);
    EXPECT_EQ(snapshot.asks[0].qty, 800);
    EXPECT_EQ(snapshot.asks[1].price, 101000);
    EXPECT_EQ(snapshot.asks[1].qty, 1200);
}

// ============================================================================
// SnapshotQueueSpsc Tests - Single Thread
// ============================================================================

TEST(SnapshotQueueSpscTests, EmptyQueueBehavior) {
    SnapshotQueueSpsc<BookSnapshot, 1024> q;
    BookSnapshot out{};

    EXPECT_EQ(q.size_approx(), 0);
    EXPECT_FALSE(q.try_pop(out));
}

TEST(SnapshotQueueSpscTests, FifoSingleThread) {
    SnapshotQueueSpsc<BookSnapshot, 1024> q;
    BookSnapshot a{}, b{}, out{};
    a.instrumentId = 10;
    b.instrumentId = 11;

    EXPECT_TRUE(q.try_push(a));
    EXPECT_TRUE(q.try_push(b));
    EXPECT_GE(q.size_approx(), 2);

    EXPECT_TRUE(q.try_pop(out));
    EXPECT_EQ(out.instrumentId, 10);

    EXPECT_TRUE(q.try_pop(out));

===== FILE: ./tests/md/test_mbo_to_mbp_aggregator.cpp =====
#include <gtest/gtest.h>

#include "../../b3-md-connector/src/core/OrdersSnapshot.hpp"
#include "../../b3-md-connector/src/core/BookSnapshot.hpp"
#include "../../b3-md-connector/src/core/MboToMbpAggregator.hpp"

using namespace b3::md;

TEST(MboToMbpAggregatorTests, AggregatesSamePriceIntoSingleLevel) {
    OrdersSnapshot in{};
    in.instrumentId = 42;
    in.exchangeTsNs = 123;

    // Bid side: 3 órdenes mismo precio, + 1 orden otro precio
    in.bidCountRaw = 4;
    in.bids[0] = { .priceMantissa = 1000, .qty = 10 };
    in.bids[1] = { .priceMantissa = 1000, .qty = 20 };
    in.bids[2] = { .priceMantissa = 1000, .qty = 30 };
    in.bids[3] = { .priceMantissa =  900, .qty =  5 };

    // Ask side: 2 precios distintos
    in.askCountRaw = 3;
    in.asks[0] = { .priceMantissa = 1100, .qty = 7 };
    in.asks[1] = { .priceMantissa = 1100, .qty = 8 };
    in.asks[2] = { .priceMantissa = 1200, .qty = 1 };

    BookSnapshot out{};
    aggregateMboWindowToMbpTopN(in, out);

    EXPECT_EQ(out.instrumentId, 42u);
    EXPECT_EQ(out.exchangeTsNs, 123u);

    ASSERT_EQ(out.bidCount, 2u);
    EXPECT_EQ(out.bids[0].price, 1000);
    EXPECT_EQ(out.bids[0].qty,   60);
    EXPECT_EQ(out.bids[1].price,  900);
    EXPECT_EQ(out.bids[1].qty,    5);

    ASSERT_EQ(out.askCount, 2u);
    EXPECT_EQ(out.asks[0].price, 1100);
    EXPECT_EQ(out.asks[0].qty,   15);
    EXPECT_EQ(out.asks[1].price, 1200);
    EXPECT_EQ(out.asks[1].qty,    1);
}

TEST(MboToMbpAggregatorTests, ProducesAtMostTopNLevels) {
    OrdersSnapshot in{};
    in.instrumentId = 1;
    in.exchangeTsNs = 1;

    // Generar 10 precios distintos (más que Top-5)
    in.bidCountRaw = 10;
    for (int i = 0; i < 10; ++i) {
        in.bids[i] = { .priceMantissa = 1000 - i, .qty = 1 };
    }

    in.askCountRaw = 10;
    for (int i = 0; i < 10; ++i) {
        in.asks[i] = { .priceMantissa = 2000 + i, .qty = 1 };
    }

    BookSnapshot out{};
    aggregateMboWindowToMbpTopN(in, out);

    EXPECT_EQ(out.bidCount, BookSnapshot::DEPTH);
    EXPECT_EQ(out.askCount, BookSnapshot::DEPTH);

    // Solo chequeamos que no exceda DEPTH y que los primeros existan
    EXPECT_NE(out.bids[0].price, 0);
    EXPECT_NE(out.asks[0].price, 0);
}

TEST(MboToMbpAggregatorTests, IgnoresZeroQtyOrders) {
    OrdersSnapshot in{};
    in.instrumentId = 9;
    in.exchangeTsNs = 9;

    in.bidCountRaw = 3;
    in.bids[0] = { .priceMantissa = 1000, .qty = 0 };   // ignorar
    in.bids[1] = { .priceMantissa = 1000, .qty = 10 };  // sumar
    in.bids[2] = { .priceMantissa =  900, .qty = 0 };   // ignorar

    in.askCountRaw = 0;

    BookSnapshot out{};
    aggregateMboWindowToMbpTopN(in, out);

    ASSERT_EQ(out.bidCount, 1u);
    EXPECT_EQ(out.bids[0].price, 1000);
    EXPECT_EQ(out.bids[0].qty,   10);
    EXPECT_EQ(out.askCount, 0u);
}

===== FILE: ./tests/md/FakeOrderBook.hpp =====
#pragma once
#include "../../b3-md-connector/src/core/IOrderBookView.hpp"
#include <array>

namespace b3::md::test {

class FakeOrderBook final : public b3::md::IOrderBookView {
public:
    void setInstrumentId(uint32_t v) { instrumentId_ = v; }
    void setExchangeTsNs(uint64_t v) { exchangeTsNs_ = v; }

    void setBidCount(uint32_t c) { bidCount_ = c; }
    void setAskCount(uint32_t c) { askCount_ = c; }

    void setBidLevel(uint32_t i, b3::md::Level lv) { bids_.at(i) = lv; }
    void setAskLevel(uint32_t i, b3::md::Level lv) { asks_.at(i) = lv; }

    uint32_t instrumentId() const noexcept override { return instrumentId_; }
    uint64_t exchangeTsNs() const noexcept override { return exchangeTsNs_; }

    uint32_t bidCount() const noexcept override { return bidCount_; }
    uint32_t askCount() const noexcept override { return askCount_; }

    b3::md::Level bidLevel(uint32_t i) const noexcept override { return bids_.at(i); }
    b3::md::Level askLevel(uint32_t i) const noexcept override { return asks_.at(i); }

private:
    uint32_t instrumentId_{0};
    uint64_t exchangeTsNs_{0};
    uint32_t bidCount_{0};
    uint32_t askCount_{0};
    std::array<b3::md::Level, 10> bids_{};
    std::array<b3::md::Level, 10> asks_{};
};

} // namespace b3::md::test

===== FILE: ./tests/md/test_md_pipeline.cpp =====
#include <gtest/gtest.h>

#include "../../b3-md-connector/src/core/MdPublishPipeline.hpp"
#include "../../b3-md-connector/src/core/MdPublishWorker.hpp"
#include "../../b3-md-connector/src/testsupport/FakePublisher.hpp"
#include "../../b3-md-connector/src/mapping/MdSnapshotMapper.hpp"

#include <chrono>
#include <thread>
#include <unordered_map>
#include <vector>
#include <string>
#include <memory>

using namespace b3::md;

namespace {

uint64_t ParseTs(const std::string& bytes) {
    auto pos = bytes.find(";ts=");
    EXPECT_NE(pos, std::string::npos);
    if (pos == std::string::npos) return 0;

    pos += 4;
    auto end = bytes.find(';', pos);
    EXPECT_NE(end, std::string::npos);
    if (end == std::string::npos) return 0;

    return std::stoull(bytes.substr(pos, end - pos));
}

uint32_t ParseIid(const std::string& bytes) {
    auto pos = bytes.find("iid=");
    EXPECT_EQ(pos, 0u);
    if (pos != 0u) return 0;

    pos += 4;
    auto end = bytes.find(';', pos);
    EXPECT_NE(end, std::string::npos);
    if (end == std::string::npos) return 0;

    return static_cast<uint32_t>(std::stoul(bytes.substr(pos, end - pos)));
}

MdPublishPipeline BuildPipeline(uint32_t shards,
                               MdSnapshotMapper& mapper,
                               testsupport::FakePublisher &pub) {
    std::vector<std::unique_ptr<MdPublishWorker>> workers;
    workers.reserve(shards);

    for (uint32_t i = 0; i < shards; ++i) {
        workers.emplace_back(
            std::make_unique<MdPublishWorker>(i, mapper, pub));
    }

    return MdPublishPipeline(std::move(workers));
}

} // namespace

TEST(MdPublishPipelineTests, PreservesFifoOrderPerInstrument) {
    testsupport::FakePublisher pub;
    MdSnapshotMapper mapper;


    auto pipeline = BuildPipeline(4, mapper, pub);
    pipeline.start();

    constexpr int EVENTS_PER_INSTRUMENT = 10'000;
    const std::vector<uint32_t> instruments = {1, 2, 3, 4, 5, 6};

    for (uint32_t iid : instruments) {
        for (int i = 0; i < EVENTS_PER_INSTRUMENT; ++i) {
            OrdersSnapshot s{};
            s.instrumentId = iid;
            s.exchangeTsNs = static_cast<uint64_t>(i);

            // Para que el agregador produzca bid/askCount > 0 (opcional):
            s.bidCountRaw = 1;
            s.askCountRaw = 1;
            s.bids[0] = { .priceMantissa = 1000 + i, .qty = 1 };
            s.asks[0] = { .priceMantissa = 2000 + i, .qty = 1 };

            while (!pipeline.tryEnqueue(s)) {
                std::this_thread::yield();
            }
        }
    }

    const size_t expected =
        instruments.size() * static_cast<size_t>(EVENTS_PER_INSTRUMENT);

    const auto deadline =
        std::chrono::steady_clock::now() + std::chrono::seconds(5);

    while (pub.count() < expected &&
           std::chrono::steady_clock::now() < deadline) {
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }


===== FILE: ./tests/md/test_md_engine.cpp =====
#include <gtest/gtest.h>

#include "../../b3-md-connector/src/core/MarketDataEngine.hpp"
#include "../../b3-md-connector/src/core/MdPublishPipeline.hpp"
#include "../../b3-md-connector/src/core/MdPublishWorker.hpp"
#include "../../b3-md-connector/src/testsupport/FakePublisher.hpp"
#include "../../b3-md-connector/src/testsupport/OrdersSnapshotFromMbpView.hpp"
#include "FakeOrderBook.hpp"

#include <atomic>
#include <chrono>
#include <thread>
#include <memory>
#include <vector>

using namespace b3::md;
using namespace b3::md::test;


// Publisher que cuenta publicaciones (thread-safe).
struct CountingPublisher final : IMdPublisher {
    void publish(std::string_view, const uint8_t*, size_t) override {
        published.fetch_add(1, std::memory_order_relaxed);
    }
    std::atomic<uint64_t> published{0};
};

// Mapper de test: no aloca pesado, solo dispara publish.
struct TestMapper final : MdSnapshotMapper {
    void mapAndSerialize(const BookSnapshot&, std::string& out) const {
        out.assign("x");
    }
};


TEST(MarketDataEngineTests, EnqueuesAndPublishes) {
    TestMapper mapper;
    CountingPublisher publisher;

    auto worker = std::make_unique<MdPublishWorker>(0, mapper, publisher);
    std::vector<std::unique_ptr<MdPublishWorker>> workers;
    workers.push_back(std::move(worker));

    MdPublishPipeline pipeline(std::move(workers));
    pipeline.start();

    FakeOrderBook book;
    book.setInstrumentId(42);
    book.setExchangeTsNs(123);
    book.setBidCount(1);
    book.setAskCount(1);
    book.setBidLevel(0, b3::md::Level{10, 5});
    book.setAskLevel(0, b3::md::Level{11, 7});

    auto snapshot =
        b3::md::testsupport::makeOrdersSnapshotFromMbpView(book);

    pipeline.tryEnqueue(snapshot);

    const auto deadline =
        std::chrono::steady_clock::now() + std::chrono::milliseconds(200);

    while (publisher.published.load(std::memory_order_relaxed) < 1 &&
           std::chrono::steady_clock::now() < deadline)
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }

    pipeline.stop(true);

    EXPECT_GE(publisher.published.load(), 1u);
}


TEST(MarketDataEngineTests, EnqueueNeverBlocks) {
    testsupport::FakePublisher pub;
    MdSnapshotMapper mapper;

    std::vector<std::unique_ptr<MdPublishWorker>> workers;
    workers.emplace_back(std::make_unique<MdPublishWorker>(0, mapper, pub));

    MdPublishPipeline pipeline(std::move(workers));
    pipeline.start();

    FakeOrderBook book;
    book.setInstrumentId(1);
    book.setExchangeTsNs(1);
    book.setBidCount(0);
    book.setAskCount(0);

    for (int i = 0; i < 100000; ++i) {
        auto snapshot =
            b3::md::testsupport::makeOrdersSnapshotFromMbpView(book);
        pipeline.tryEnqueue(snapshot);
    }

    pipeline.stop(false);
    SUCCEED();
}


===== FILE: ./tests/md/test_md_worker.cpp =====
#include "../../b3-md-connector/src/core/MdPublishWorker.hpp"
#include "../../b3-md-connector/src/testsupport/FakePublisher.hpp"
#include "../../b3-md-connector/src/mapping/MdSnapshotMapper.hpp"
#include "../../b3-md-connector/src/core/OrdersSnapshot.hpp"
#include <gtest/gtest.h>

#include <chrono>
#include <thread>

using namespace b3::md;

static uint64_t parse_ts(const std::string& bytes) {
    auto pos = bytes.find(";ts=");
    EXPECT_NE(pos, std::string::npos);
    pos += 4;
    auto end = bytes.find(';', pos);
    EXPECT_NE(end, std::string::npos);
    return std::stoull(bytes.substr(pos, end - pos));
}

TEST(MdPublishWorkerTests, PublishesFifoOrder) {
    testsupport::FakePublisher pub;
    MdSnapshotMapper mapper;
    uint32_t shard = 1;

    MdPublishWorker worker(shard, mapper, pub);
    worker.start();

    constexpr int N = 100000;
    for (int i = 0; i < N; ++i) {
        OrdersSnapshot orderSnapshot{};
        orderSnapshot.instrumentId = 77;
        orderSnapshot.exchangeTsNs = static_cast<uint64_t>(i);

        // opcional para bid/ask count:
        orderSnapshot.bidCountRaw = 1;
        orderSnapshot.askCountRaw = 1;
        orderSnapshot.bids[0] = { .priceMantissa = 1000, .qty = 1 };
        orderSnapshot.asks[0] = { .priceMantissa = 2000, .qty = 1 };

        while (!worker.tryEnqueue(orderSnapshot)) {
            std::this_thread::yield();
        }
    }

    const auto deadline = std::chrono::steady_clock::now() + std::chrono::seconds(5);
    while (pub.count() < static_cast<size_t>(N) && std::chrono::steady_clock::now() < deadline) {
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }

    worker.stop(true);

    ASSERT_EQ(pub.count(), static_cast<size_t>(N));

    uint64_t last = 0;
    for (int i = 0; i < N; ++i) {
        auto m = pub.at(i);
        EXPECT_EQ(m.topic, "b3.md.book"); // topic fijo del worker
        uint64_t ts = parse_ts(m.bytes);
        if (i == 0) EXPECT_EQ(ts, 0);
        else EXPECT_EQ(ts, last + 1);
        last = ts;
    }
}

TEST(MdPublishWorkerTests, StopClean) {
    testsupport::FakePublisher pub;
    MdSnapshotMapper mapper;
    uint32_t shard = 1;

    MdPublishWorker worker(shard, mapper, pub);
    worker.start();
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
    worker.stop(false);
    SUCCEED();
}

TEST(MdPublishWorkerTests, StopWithoutDrainDropsPending) {
    testsupport::FakePublisher pub;
    MdSnapshotMapper mapper;

    MdPublishWorker worker(0, mapper, pub);
    worker.start();

    for (int i = 0; i < 1000; ++i) {
        OrdersSnapshot s{};
        s.instrumentId = 77;
        s.exchangeTsNs = static_cast<uint64_t>(i);

        // opcional para bid/ask count:
        s.bidCountRaw = 1;
        s.askCountRaw = 1;
        s.bids[0] = { .priceMantissa = 1000, .qty = 1 };
        s.asks[0] = { .priceMantissa = 2000, .qty = 1 };
        worker.tryEnqueue(s);
    }

    worker.stop(false);

    EXPECT_LT(pub.count(), 1000u); // no drenó todo

===== FILE: ./tests/md/test_spdlog_log_publisher.cpp =====
#include <gtest/gtest.h>

#include "../../b3-md-connector/src/telemetry/SpdlogLogPublisher.hpp"
#include "../../b3-md-connector/src/telemetry/LogEvent.hpp"

#include <chrono>
#include <thread>

using namespace b3::md::telemetry;

TEST(SpdlogLogPublisherTests, StartStopClean) {
    SpdlogLogPublisher<64> pub;
    pub.start();
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
    pub.stop();
    SUCCEED();
}

TEST(SpdlogLogPublisherTests, DropsWhenQueueIsFull) {
    // Capacidad chica a propósito para forzar saturación
    SpdlogLogPublisher<8> pub;
    pub.start();

    LogEvent e{};
    e.level = LogLevel::Info;
    e.component = Component::Worker;
    e.code = Code::HealthTick;

    // Encolamos mucho sin dormir: inevitablemente se llena y dropea
    constexpr int N = 5000;
    for (int i = 0; i < N; ++i) {
        e.arg0 = static_cast<uint64_t>(i);
        (void)pub.try_publish(e);
    }

    // Dejá que el thread consuma un poco
    std::this_thread::sleep_for(std::chrono::milliseconds(20));
    pub.stop();

    // Con capacidad 8 y N=5000, casi seguro dropeó algo
    EXPECT_GT(pub.dropped(), 0u);
}

TEST(SpdlogLogPublisherTests, DoesNotDropUnderLightLoad) {
    SpdlogLogPublisher<1024> pub;
    pub.start();

    LogEvent e{};
    e.level = LogLevel::Info;
    e.component = Component::Core;
    e.code = Code::Startup;

    // Carga liviana + pequeñas pausas -> no debería dropear
    constexpr int N = 200;
    for (int i = 0; i < N; ++i) {
        e.arg0 = static_cast<uint64_t>(i);
        ASSERT_TRUE(pub.try_publish(e));
        std::this_thread::sleep_for(std::chrono::microseconds(200));
    }

    std::this_thread::sleep_for(std::chrono::milliseconds(10));
    pub.stop();

    EXPECT_EQ(pub.dropped(), 0u);
}

===== FILE: ./tests/oe/Test_OrderEngine.cpp =====
#include "OrderEngine.hpp"
#include <gtest/gtest.h>


TEST(OrderEngineTests, CanInstantiate) {
    OrderEngine* engine = nullptr; // placeholder hasta que tengas ctor
    SUCCEED();
}

===== FILE: ./libs/markethub/messaging/include/servers/SubscriberPublisher.h =====
#ifndef MARKETHUB_MESSAGING_SERVERS_SUBSCRIBERPUBLISHER_H
#define MARKETHUB_MESSAGING_SERVERS_SUBSCRIBERPUBLISHER_H

#include <string>
#include <memory>
#include <functional>
#include <chrono>
#include "../sockets/Subscriber.h"
#include "../sockets/Publisher.h"
#include "../models/messages.pb.h"

namespace markethub::messaging::servers {

  /**
   * @brief Base class for servers that receive requests (Subscriber) and send responses
   * (Publisher).
   *
   * Server-side pattern: listens for incoming requests and publishes responses.
   */
  class SubscriberPublisher {
   public:
    /**
     * @brief Callback type for logging.
     */
    using LogCallback = std::function<void(const std::string &level, const std::string &message)>;

    /**
     * @brief Constructor.
     *
     * @param serverEndpoint Endpoint to listen for requests (BIND mode)
     * @param publishingEndpoint Endpoint to publish responses (BIND mode)
     * @param logCallback Optional callback for logging
     */
    SubscriberPublisher(const std::string &serverEndpoint, const std::string &publishingEndpoint,
                        LogCallback logCallback = nullptr);

    /**
     * @brief Virtual destructor. Automatically stops if running.
     */
    virtual ~SubscriberPublisher();

    // Non-copyable
    SubscriberPublisher(const SubscriberPublisher &) = delete;
    SubscriberPublisher &operator=(const SubscriberPublisher &) = delete;

    /**
     * @brief Starts the server. Begins receiving requests and is ready to send responses.
     *
     * Automatically subscribes to all topics ("").
     */
    virtual void Start();

    /**
     * @brief Stops the server. Stops receiving requests and sending responses.
     */
    virtual void Stop();

    /**
     * @brief Gets the startup delay (wait time after Start before operating).
     *
     * @return The startup delay in milliseconds
     */
    std::chrono::milliseconds GetStartDelay() const;

    /**
     * @brief Sets the startup delay. Applies to both Subscriber and Publisher.
     *
     * Default: 1000ms (1 second).
     * @param delay The startup delay in milliseconds
     */
    void SetStartDelay(std::chrono::milliseconds delay);

    /**
     * @brief Gets the delay after sending each message.
     *
     * @return The delay in milliseconds
     */
    std::chrono::milliseconds GetDelayAfterSendMessage() const;

    /**
     * @brief Sets the delay after sending each message.
     *
     * Default: 0ms (no delay).
     * @param delay The delay in milliseconds
     */
    void SetDelayAfterSendMessage(std::chrono::milliseconds delay);

    /**
     * @brief Sends a message (response) via Publisher.
     *
     * @param message The message to send
     */
    void SendMessage(const WrapperMessage &message);

   protected:
    /**
     * @brief Abstract method that must be implemented by derived classes.
     *
     * Processes a request and returns a response (or nullptr if no response).
     * @param request The received request message

===== FILE: ./libs/markethub/messaging/include/sockets/Publisher.h =====
#pragma once

#include <string>
#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <chrono>
#include <functional>
#include <zmq.hpp>
#include "../models/messages.pb.h"

namespace markethub::messaging::sockets {

  /**
   * @brief Base class for implementing servers that publish messages.
   *
   * Thread-safe publisher that sends WrapperMessage objects via ZeroMQ PUB socket.
   */
  class Publisher {
   public:
    using LogCallback = std::function<void(const std::string &level, const std::string &message)>;

    /**
     * @brief Creates a new instance of Publisher.
     * @param publishingEndPoint ZMQ endpoint (e.g., "tcp://*:5555" or "tcp://localhost:5555")
     * @param isMultiplePublisher If false, uses Bind (single publisher). If true, uses Connect
     * (multiple publishers).
     * @param logCallback Optional callback for logging. nullptr for no logging.
     */
    Publisher(const std::string &publishingEndPoint, bool isMultiplePublisher,
              LogCallback logCallback = nullptr);

    /**
     * @brief Destructor. Automatically stops the publisher and cleans up resources (RAII).
     */
    virtual ~Publisher();

    // Delete copy constructor and assignment operator (non-copyable)
    Publisher(const Publisher &) = delete;
    Publisher &operator=(const Publisher &) = delete;

    /**
     * @brief Starts the publisher background thread.
     *
     * Blocks until the socket is initialized and ready.
     * @throws std::runtime_error If socket initialization fails
     */
    virtual void Start();

    /**
     * @brief Stops the publisher background thread and cleans up resources.
     *
     * Thread-safe, can be called multiple times.
     */
    virtual void Stop();

    /**
     * @brief Enqueues a message for sending.
     *
     * Thread-safe method that adds the message to the send queue.
     * @param message The WrapperMessage to send
     * @throws std::runtime_error If publisher is already disposed
     */
    virtual void SendMessage(const WrapperMessage &message);

    /**
     * @brief Enqueues a message for sending (move version).
     *
     * Thread-safe method that moves the message into the send queue, avoiding copy.
     * @param message The WrapperMessage to send (will be moved)
     * @throws std::runtime_error If publisher is already disposed
     */
    virtual void SendMessage(WrapperMessage &&message);

    /**
     * @brief Gets the startup delay (slow joiner mitigation).
     *
     * Default: 1.5 seconds
     * @return Startup delay in milliseconds
     */
    virtual std::chrono::milliseconds GetStartDelay() const;

    /**
     * @brief Sets the startup delay (slow joiner mitigation).
     *
     * Must be >= 0. Applied after socket bind/connect.
     * @param delay Startup delay in milliseconds
     */
    virtual void SetStartDelay(std::chrono::milliseconds delay);

    /**
     * @brief Gets the delay after sending each message.
     *
     * Default: 0 (no delay)
     * @return Delay in milliseconds
     */
    virtual std::chrono::milliseconds GetDelayAfterSendMessage() const;


===== FILE: ./libs/markethub/messaging/include/sockets/Subscriber.h =====
#pragma once

#include <string>
#include <vector>
#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <chrono>
#include <functional>
#include <zmq.hpp>
#include "../models/messages.pb.h"

namespace markethub::messaging::sockets {

  /**
   * @brief Base class for implementing clients that subscribe to messages.
   *
   * Thread-safe subscriber that receives WrapperMessage objects via ZeroMQ SUB socket.
   */
  class Subscriber {
   public:
    using MessageReceivedCallback = std::function<void(const WrapperMessage &)>;
    using LogCallback = std::function<void(const std::string &level, const std::string &message)>;

    /**
     * @brief Creates a new instance of Subscriber.
     * @param serverEndPoint ZMQ endpoint (e.g., "tcp://localhost:5555")
     * @param isMultipleSubscriber If false, uses Bind (single subscriber). If true, uses Connect
     * (multiple subscribers).
     * @param logCallback Optional callback for logging. nullptr for no logging.
     */
    Subscriber(const std::string &serverEndPoint, bool isMultipleSubscriber,
               LogCallback logCallback = nullptr);

    /**
     * @brief Destructor. Automatically stops the subscriber and cleans up resources (RAII).
     */
    virtual ~Subscriber();

    // Delete copy constructor and assignment operator (non-copyable)
    Subscriber(const Subscriber &) = delete;
    Subscriber &operator=(const Subscriber &) = delete;

    /**
     * @brief Starts the subscriber background thread.
     *
     * Blocks until the socket is initialized and ready.
     * @throws std::runtime_error If socket initialization fails
     */
    virtual void Start();

    /**
     * @brief Stops the subscriber background thread and cleans up resources.
     *
     * Thread-safe, can be called multiple times.
     */
    virtual void Stop();

    /**
     * @brief Subscribes to a topic (thread-safe).
     *
     * The subscription will be processed asynchronously by the background thread.
     * @param topic Topic to subscribe to. Empty string subscribes to all messages.
     */
    virtual void Subscribe(const std::string &topic);

    /**
     * @brief Unsubscribes from a topic (thread-safe).
     *
     * The unsubscription will be processed asynchronously by the background thread.
     * @param topic Topic to unsubscribe from
     */
    virtual void Unsubscribe(const std::string &topic);

    /**
     * @brief Unsubscribes from all currently subscribed topics.
     */
    virtual void UnsubscribeAll();

    /**
     * @brief Sets the callback that will be invoked when a message is received.
     *
     * Not thread-safe - should be set before calling Start().
     * @param callback Callback function to invoke on message reception
     */
    void SetMessageReceivedCallback(MessageReceivedCallback callback) {
      _messageReceivedCallback = callback;
    }

    /**
     * @brief Gets the startup delay (slow joiner mitigation).
     *
     * Default: 1.5 seconds
     * @return Startup delay in milliseconds
     */
    virtual std::chrono::milliseconds GetStartDelay() const;

    /**

===== FILE: ./libs/markethub/messaging/include/clients/PublisherSubscriber.h =====
#pragma once

#include <string>
#include <memory>
#include <vector>
#include <chrono>
#include "../sockets/Publisher.h"
#include "../sockets/Subscriber.h"
#include "../models/messages.pb.h"

namespace markethub::messaging::clients {

  /**
   * @brief Base class for a client that publishes requests and subscribes to responses.
   *
   * Combines Publisher and Subscriber functionality with automatic ClientId management.
   */
  class PublisherSubscriber {
   public:
    using MessageReceivedCallback = std::function<void(const WrapperMessage &)>;
    using LogCallback = std::function<void(const std::string &level, const std::string &message)>;

    /**
     * @brief Creates a new instance of PublisherSubscriber.
     *
     * @param clientId Unique client identifier. All messages sent will have this ClientId.
     * @param requestsEndPoint Endpoint where requests will be sent (Publisher connects here)
     * @param listeningEndPoint Endpoint where responses will be received (Subscriber connects here)
     * @param logCallback Optional callback for logging
     */
    PublisherSubscriber(const std::string &clientId, const std::string &requestsEndPoint,
                        const std::string &listeningEndPoint, LogCallback logCallback = nullptr);

    /**
     * @brief Destructor. Automatically stops and cleans up resources (RAII).
     */
    virtual ~PublisherSubscriber();

    // Delete copy constructor and assignment operator (non-copyable)
    PublisherSubscriber(const PublisherSubscriber &) = delete;
    PublisherSubscriber &operator=(const PublisherSubscriber &) = delete;

    /**
     * @brief Starts the client (both Publisher and Subscriber).
     *
     * Subscriber starts first, then configures subscription, then Publisher starts.
     */
    virtual void Start();

    /**
     * @brief Stops the client (both Publisher and Subscriber).
     */
    virtual void Stop();

    /**
     * @brief Sends a message. Automatically sets the ClientId field before sending.
     *
     * Thread-safe.
     * @param message Message to send (ClientId will be overwritten)
     */
    virtual void SendMessage(WrapperMessage &message);

    /**
     * @brief Sends a message (move version - preferred for performance).
     *
     * Automatically sets the ClientId field before sending. Thread-safe.
     * @param message Message to send (will be moved, ClientId will be set)
     */
    virtual void SendMessage(WrapperMessage &&message);

    /**
     * @brief Sets the callback that will be invoked when a response message is received.
     *
     * Should be set before calling Start().
     * @param callback Callback function to invoke on message receipt
     */
    void SetMessageReceivedCallback(MessageReceivedCallback callback) {
      _messageReceivedCallback = callback;
    }

    /**
     * @brief Gets the client ID associated with this instance.
     *
     * All messages sent by this instance will have this ClientId.
     * @return The client ID string
     */
    const std::string &GetClientId() const { return _clientId; }

    /**
     * @brief Gets the startup delay for both Publisher and Subscriber.
     *
     * Default: 1.5 seconds
     * @return The startup delay in milliseconds
     */
    virtual std::chrono::milliseconds GetStartDelay() const;

    /**
     * @brief Sets the startup delay for both Publisher and Subscriber.
     *
     * @param delay The startup delay in milliseconds

===== FILE: ./libs/markethub/messaging/include/clients/Heartbeat.h =====
#ifndef MARKETHUB_MESSAGING_CLIENTS_HEARTBEAT_H
#define MARKETHUB_MESSAGING_CLIENTS_HEARTBEAT_H

#include <string>
#include <thread>
#include <atomic>
#include <functional>
#include <chrono>
#include <mutex>
#include "../models/messages.pb.h"

namespace markethub::messaging::clients {

  /**
   * @brief Periodic heartbeat generator.
   *
   * Generates heartbeat messages at configurable intervals and notifies via callback.
   */
  class HeartbeatGenerator {
   public:
    /**
     * @brief Callback type invoked when generating a heartbeat.
     */
    using HeartbeatCallback = std::function<void(const WrapperMessage &)>;

    /**
     * @brief Callback type for logging.
     */
    using LogCallback = std::function<void(const std::string &level, const std::string &message)>;

    /**
     * @brief Constructor.
     *
     * @param clientId Client ID to include in heartbeat messages
     * @param logCallback Optional callback for logging
     */
    HeartbeatGenerator(const std::string &clientId, LogCallback logCallback = nullptr);

    /**
     * @brief Destructor. Automatically stops the generator if running.
     */
    virtual ~HeartbeatGenerator();

    // Non-copyable
    HeartbeatGenerator(const HeartbeatGenerator &) = delete;
    HeartbeatGenerator &operator=(const HeartbeatGenerator &) = delete;

    /**
     * @brief Starts heartbeat generation.
     */
    virtual void Start();

    /**
     * @brief Stops heartbeat generation.
     */
    virtual void Stop();

    /**
     * @brief Gets the interval between heartbeat transmissions.
     *
     * @return Interval in seconds
     */
    std::chrono::seconds GetHeartbeatPeriod() const;

    /**
     * @brief Sets the interval between heartbeat transmissions.
     *
     * Template method that accepts any std::chrono::duration type (seconds, milliseconds, hours, etc.)
     * Mimics C# TimeSpan behavior where any duration can be passed and validation occurs at runtime.
     *
     * @tparam Rep Arithmetic type representing the number of ticks
     * @tparam Period std::ratio representing the tick period
     * @param period Interval as a std::chrono::duration (minimum 1 second)
     * @throws std::invalid_argument if period is less than 1 second
     */
    template <typename Rep, typename Period>
    void SetHeartbeatPeriod(std::chrono::duration<Rep, Period> period) {
      // Convert to seconds for comparison and storage
      auto periodInSeconds = std::chrono::duration_cast<std::chrono::seconds>(period);

      // Validate: must be at least 1 second (matching C# behavior)
      if (periodInSeconds.count() < 1) {
        throw std::invalid_argument("Heartbeat period cannot be less than 1 second.");
      }

      std::lock_guard<std::mutex> lock(_mutex);
      _heartbeatPeriod = periodInSeconds;

      Log("Info", "Heartbeat period set to " + std::to_string(_heartbeatPeriod.count()) + " seconds");
    }

    /**
     * @brief Sets the callback to be invoked when generating a heartbeat.
     *
     * @param callback Callback function
     */
    void SetHeartbeatCallback(HeartbeatCallback callback);

   protected:
    /**

===== FILE: ./libs/markethub/messaging/include/models/rofex.pb.h =====
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: rofex.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_rofex_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_rofex_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "trading.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_rofex_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_rofex_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_rofex_2eproto;
namespace markethub {
namespace messaging {
namespace rofex {
class Account;
struct AccountDefaultTypeInternal;
extern AccountDefaultTypeInternal _Account_default_instance_;
class AccountListIncremental;
struct AccountListIncrementalDefaultTypeInternal;
extern AccountListIncrementalDefaultTypeInternal _AccountListIncremental_default_instance_;
class AccountListRequest;
struct AccountListRequestDefaultTypeInternal;
extern AccountListRequestDefaultTypeInternal _AccountListRequest_default_instance_;
class AccountListResponse;
struct AccountListResponseDefaultTypeInternal;
extern AccountListResponseDefaultTypeInternal _AccountListResponse_default_instance_;
class MarketAlias;
struct MarketAliasDefaultTypeInternal;
extern MarketAliasDefaultTypeInternal _MarketAlias_default_instance_;
}  // namespace rofex
}  // namespace messaging
}  // namespace markethub
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace markethub {
namespace messaging {
namespace rofex {
enum AccountListRequestType : int {
  ACCOUNT_LIST_REQUEST_TYPE_UNSPECIFIED = 0,
  ACCOUNT = 1,
  ACCOUNT_TYPE = 2,
  ALL_ACCOUNTS = 3,
  AccountListRequestType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AccountListRequestType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AccountListRequestType_IsValid(int value);
extern const uint32_t AccountListRequestType_internal_data_[];
constexpr AccountListRequestType AccountListRequestType_MIN = static_cast<AccountListRequestType>(0);
constexpr AccountListRequestType AccountListRequestType_MAX = static_cast<AccountListRequestType>(3);
constexpr int AccountListRequestType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
AccountListRequestType_descriptor();

===== FILE: ./libs/markethub/messaging/include/models/risk_management.pb.h =====
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: risk_management.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_risk_5fmanagement_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_risk_5fmanagement_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_risk_5fmanagement_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_risk_5fmanagement_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_risk_5fmanagement_2eproto;
namespace markethub {
namespace messaging {
namespace risk_management {
class HoldingReport;
struct HoldingReportDefaultTypeInternal;
extern HoldingReportDefaultTypeInternal _HoldingReport_default_instance_;
class HoldingReportRequest;
struct HoldingReportRequestDefaultTypeInternal;
extern HoldingReportRequestDefaultTypeInternal _HoldingReportRequest_default_instance_;
class HoldingReportResponse;
struct HoldingReportResponseDefaultTypeInternal;
extern HoldingReportResponseDefaultTypeInternal _HoldingReportResponse_default_instance_;
class InitialPositionUpdateRequest;
struct InitialPositionUpdateRequestDefaultTypeInternal;
extern InitialPositionUpdateRequestDefaultTypeInternal _InitialPositionUpdateRequest_default_instance_;
class PNLReport;
struct PNLReportDefaultTypeInternal;
extern PNLReportDefaultTypeInternal _PNLReport_default_instance_;
class PNLReportRequest;
struct PNLReportRequestDefaultTypeInternal;
extern PNLReportRequestDefaultTypeInternal _PNLReportRequest_default_instance_;
class PNLReportResponse;
struct PNLReportResponseDefaultTypeInternal;
extern PNLReportResponseDefaultTypeInternal _PNLReportResponse_default_instance_;
}  // namespace risk_management
}  // namespace messaging
}  // namespace markethub
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace markethub {
namespace messaging {
namespace risk_management {

// ===================================================================


// -------------------------------------------------------------------

class PNLReportRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:markethub.messaging.risk_management.PNLReportRequest) */ {
 public:
  inline PNLReportRequest() : PNLReportRequest(nullptr) {}
  ~PNLReportRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PNLReportRequest(
      ::google::protobuf::internal::ConstantInitialized);

===== FILE: ./libs/markethub/messaging/include/models/messages.pb.h =====
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: messages.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_messages_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_messages_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "system.pb.h"
#include "trading.pb.h"
#include "rofex.pb.h"
#include "risk_management.pb.h"
#include "otc.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_messages_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_messages_2eproto;
namespace markethub {
namespace messaging {
class WrapperMessage;
struct WrapperMessageDefaultTypeInternal;
extern WrapperMessageDefaultTypeInternal _WrapperMessage_default_instance_;
}  // namespace messaging
}  // namespace markethub
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace markethub {
namespace messaging {

// ===================================================================


// -------------------------------------------------------------------

class WrapperMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:markethub.messaging.WrapperMessage) */ {
 public:
  inline WrapperMessage() : WrapperMessage(nullptr) {}
  ~WrapperMessage() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WrapperMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline WrapperMessage(const WrapperMessage& from) : WrapperMessage(nullptr, from) {}
  inline WrapperMessage(WrapperMessage&& from) noexcept
      : WrapperMessage(nullptr, std::move(from)) {}
  inline WrapperMessage& operator=(const WrapperMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline WrapperMessage& operator=(WrapperMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);

===== FILE: ./libs/markethub/messaging/include/models/system.pb.h =====
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: system.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_system_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_system_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_system_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_system_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_system_2eproto;
namespace markethub {
namespace messaging {
namespace system {
class AddServiceRequest;
struct AddServiceRequestDefaultTypeInternal;
extern AddServiceRequestDefaultTypeInternal _AddServiceRequest_default_instance_;
class AddServiceResponse;
struct AddServiceResponseDefaultTypeInternal;
extern AddServiceResponseDefaultTypeInternal _AddServiceResponse_default_instance_;
class AllInstrumentsRequest;
struct AllInstrumentsRequestDefaultTypeInternal;
extern AllInstrumentsRequestDefaultTypeInternal _AllInstrumentsRequest_default_instance_;
class AllInstrumentsResponse;
struct AllInstrumentsResponseDefaultTypeInternal;
extern AllInstrumentsResponseDefaultTypeInternal _AllInstrumentsResponse_default_instance_;
class AllSymbolsRequest;
struct AllSymbolsRequestDefaultTypeInternal;
extern AllSymbolsRequestDefaultTypeInternal _AllSymbolsRequest_default_instance_;
class AllSymbolsResponse;
struct AllSymbolsResponseDefaultTypeInternal;
extern AllSymbolsResponseDefaultTypeInternal _AllSymbolsResponse_default_instance_;
class Contract;
struct ContractDefaultTypeInternal;
extern ContractDefaultTypeInternal _Contract_default_instance_;
class Country;
struct CountryDefaultTypeInternal;
extern CountryDefaultTypeInternal _Country_default_instance_;
class Currency;
struct CurrencyDefaultTypeInternal;
extern CurrencyDefaultTypeInternal _Currency_default_instance_;
class DiscoverServicesRequest;
struct DiscoverServicesRequestDefaultTypeInternal;
extern DiscoverServicesRequestDefaultTypeInternal _DiscoverServicesRequest_default_instance_;
class EventManagerOptions;
struct EventManagerOptionsDefaultTypeInternal;
extern EventManagerOptionsDefaultTypeInternal _EventManagerOptions_default_instance_;
class EventWorkerConnection;
struct EventWorkerConnectionDefaultTypeInternal;
extern EventWorkerConnectionDefaultTypeInternal _EventWorkerConnection_default_instance_;
class FeeDefinition;
struct FeeDefinitionDefaultTypeInternal;
extern FeeDefinitionDefaultTypeInternal _FeeDefinition_default_instance_;
class FilterSymbolsRequest;
struct FilterSymbolsRequestDefaultTypeInternal;

===== FILE: ./libs/markethub/messaging/include/models/otc.pb.h =====
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: otc.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_otc_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_otc_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "trading.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_otc_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_otc_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_otc_2eproto;
namespace markethub {
namespace messaging {
namespace otc {
class OTCTradeReport;
struct OTCTradeReportDefaultTypeInternal;
extern OTCTradeReportDefaultTypeInternal _OTCTradeReport_default_instance_;
class PositionCorrectionNotification;
struct PositionCorrectionNotificationDefaultTypeInternal;
extern PositionCorrectionNotificationDefaultTypeInternal _PositionCorrectionNotification_default_instance_;
class PositionUpdateNotification;
struct PositionUpdateNotificationDefaultTypeInternal;
extern PositionUpdateNotificationDefaultTypeInternal _PositionUpdateNotification_default_instance_;
}  // namespace otc
}  // namespace messaging
}  // namespace markethub
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace markethub {
namespace messaging {
namespace otc {

// ===================================================================


// -------------------------------------------------------------------

class PositionUpdateNotification final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:markethub.messaging.otc.PositionUpdateNotification) */ {
 public:
  inline PositionUpdateNotification() : PositionUpdateNotification(nullptr) {}
  ~PositionUpdateNotification() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PositionUpdateNotification(
      ::google::protobuf::internal::ConstantInitialized);

  inline PositionUpdateNotification(const PositionUpdateNotification& from) : PositionUpdateNotification(nullptr, from) {}
  inline PositionUpdateNotification(PositionUpdateNotification&& from) noexcept
      : PositionUpdateNotification(nullptr, std::move(from)) {}
  inline PositionUpdateNotification& operator=(const PositionUpdateNotification& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionUpdateNotification& operator=(PositionUpdateNotification&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()

===== FILE: ./libs/markethub/messaging/include/models/messageTypes.h =====
#pragma once
#include <string_view>

namespace markethub::messaging::models {

  /// <summary>
  /// Tipos de mensajes que soporta la librería.
  /// </summary>
  struct MessageTypes {
    static constexpr std::string_view Ping = "Ping";
    static constexpr std::string_view Pong = "Pong";

    static constexpr std::string_view SecurityDefinitionRequest = "SecurityDefinitionRequest";
    static constexpr std::string_view SecurityDefinitionResponse = "SecurityDefinitionResponse";

    static constexpr std::string_view SecurityListRequest = "SecurityListRequest";
    static constexpr std::string_view SecurityListResponse = "SecurityListResponse";

    static constexpr std::string_view MarketDataSuscriptionRequest = "MarketDataSuscriptionRequest";
    static constexpr std::string_view MarketDataSuscriptionResponse =
        "MarketDataSuscriptionResponse";

    static constexpr std::string_view PreviousClosePriceRequest = "PreviousClosePriceRequest";
    static constexpr std::string_view PreviousClosePriceResponse = "PreviousClosePriceResponse";

    static constexpr std::string_view MarketDataUpdate = "MarketData";

    static constexpr std::string_view NewOrderRequest = "NewOrderRequest";
    static constexpr std::string_view CancelOrderRequest = "CancelOrderRequest";
    static constexpr std::string_view ReplaceOrderRequest = "ReplaceOrderRequest";

    static constexpr std::string_view MassCancelRequest = "MassCancelRequest";
    static constexpr std::string_view MassCancelReport = "MassCancelReport";

    static constexpr std::string_view OrderStatusRequest = "OrderStatusRequest";
    static constexpr std::string_view TradeSessionStatusRequest = "TradeSessionStatusRequest";
    static constexpr std::string_view TradingSessionStatus = "TradingSessionStatus";

    static constexpr std::string_view MassOrderStatusRequest = "MassOrderStatusRequest";
    static constexpr std::string_view MassOrderStatusResponse = "MassOrderStatusResponse";

    static constexpr std::string_view TradeCaptureReportRequest = "TradeCaptureReportRequest";
    static constexpr std::string_view TradeCaptureReportResponse = "TradeCaptureReportResponse";
    static constexpr std::string_view TradeCaptureReport = "TradeCaptureReport";

    static constexpr std::string_view ExecutionReport = "ExecutionReport";

    static constexpr std::string_view SecurityStatusRequest = "SecurityStatusRequest";
    static constexpr std::string_view SecurityStatusResponse = "SecurityStatusResponse";

    static constexpr std::string_view AccountListRequest = "AccountListRequest";
    static constexpr std::string_view AccountListResponse = "AccountListResponse";
    static constexpr std::string_view AccountListIncremental = "AccountListIncremental";

    static constexpr std::string_view AllSymbolsRequest = "AllSymbolsRequest";
    static constexpr std::string_view AllSymbolsResponse = "AllSymbolsResponse";

    static constexpr std::string_view Stop = "Stop";

    static constexpr std::string_view AddServiceRequest = "AddServiceRequest";
    static constexpr std::string_view AddServiceResponse = "AddServiceResponse";

    static constexpr std::string_view Heartbeat = "Heartbeat";

    static constexpr std::string_view RemoveServiceRequest = "RemoveServiceRequest";
    static constexpr std::string_view NodesBroadcast = "NodesBroadcast";

    static constexpr std::string_view FindNodeRequest = "FindNodeRequest";
    static constexpr std::string_view FindNodeResponse = "FindNodeResponse";

    static constexpr std::string_view DiscoverServicesRequest = "DiscoverServicesRequest";

    static constexpr std::string_view FilterSymbolsRequest = "FilterSymbolsRequest";
    static constexpr std::string_view FilterSymbolsResponse = "FilterSymbolsResponse";

    static constexpr std::string_view AllInstrumentsRequest = "AllInstrumentsRequest";
    static constexpr std::string_view AllInstrumentsResponse = "AllInstrumentsResponse";

    static constexpr std::string_view HoldingReportRequest = "HoldingReportRequest";
    static constexpr std::string_view HoldingReportResponse = "HoldingReportResponse";

    static constexpr std::string_view PNLReportRequest = "PNLReportRequest";
    static constexpr std::string_view PNLReportResponse = "PNLReportResponse";

    static constexpr std::string_view HoldingReport = "HoldingReport";
    static constexpr std::string_view PNLReport = "PNLReport";

    static constexpr std::string_view NextBusinessDayRequest = "NextBusinessDayRequest";
    static constexpr std::string_view NextBusinessDayResponse = "NextBusinessDayResponse";

    static constexpr std::string_view ReposMappingRequest = "ReposMappingRequest";
    static constexpr std::string_view ReposMappingResponse = "ReposMappingResponse";

    static constexpr std::string_view OTCTradeReport = "OTCTradeReport";

    static constexpr std::string_view PositionUpdateNotification = "PositionUpdateNotification";
    static constexpr std::string_view PositionCorrectionNotification =
        "PositionCorrectionNotification";
  };


===== FILE: ./libs/markethub/messaging/include/models/trading.pb.h =====
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: trading.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_trading_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_trading_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_trading_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_trading_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_trading_2eproto;
namespace markethub {
namespace messaging {
namespace trading {
class Book;
struct BookDefaultTypeInternal;
extern BookDefaultTypeInternal _Book_default_instance_;
class BookLine;
struct BookLineDefaultTypeInternal;
extern BookLineDefaultTypeInternal _BookLine_default_instance_;
class CancelOrderRequest;
struct CancelOrderRequestDefaultTypeInternal;
extern CancelOrderRequestDefaultTypeInternal _CancelOrderRequest_default_instance_;
class ExecutionReport;
struct ExecutionReportDefaultTypeInternal;
extern ExecutionReportDefaultTypeInternal _ExecutionReport_default_instance_;
class Instrument;
struct InstrumentDefaultTypeInternal;
extern InstrumentDefaultTypeInternal _Instrument_default_instance_;
class MarketDataSuscriptionRequest;
struct MarketDataSuscriptionRequestDefaultTypeInternal;
extern MarketDataSuscriptionRequestDefaultTypeInternal _MarketDataSuscriptionRequest_default_instance_;
class MarketDataSuscriptionResponse;
struct MarketDataSuscriptionResponseDefaultTypeInternal;
extern MarketDataSuscriptionResponseDefaultTypeInternal _MarketDataSuscriptionResponse_default_instance_;
class MassCancelRequest;
struct MassCancelRequestDefaultTypeInternal;
extern MassCancelRequestDefaultTypeInternal _MassCancelRequest_default_instance_;
class MassCancelResponse;
struct MassCancelResponseDefaultTypeInternal;
extern MassCancelResponseDefaultTypeInternal _MassCancelResponse_default_instance_;
class MassOrderStatusRequest;
struct MassOrderStatusRequestDefaultTypeInternal;
extern MassOrderStatusRequestDefaultTypeInternal _MassOrderStatusRequest_default_instance_;
class MassOrderStatusResponse;
struct MassOrderStatusResponseDefaultTypeInternal;
extern MassOrderStatusResponseDefaultTypeInternal _MassOrderStatusResponse_default_instance_;
class NewOrderRequest;
struct NewOrderRequestDefaultTypeInternal;
extern NewOrderRequestDefaultTypeInternal _NewOrderRequest_default_instance_;
class OrderStatusRequest;
struct OrderStatusRequestDefaultTypeInternal;
extern OrderStatusRequestDefaultTypeInternal _OrderStatusRequest_default_instance_;
class ReplaceOrderRequest;
struct ReplaceOrderRequestDefaultTypeInternal;
extern ReplaceOrderRequestDefaultTypeInternal _ReplaceOrderRequest_default_instance_;

===== FILE: ./libs/markethub/messaging/include/models/events.pb.h =====
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: events.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_events_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_events_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "events/connector.pb.h"
#include "events/strategy.pb.h"
#include "trading.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_events_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_events_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_events_2eproto;
namespace markethub {
namespace messaging {
namespace events {
class EventWrapper;
struct EventWrapperDefaultTypeInternal;
extern EventWrapperDefaultTypeInternal _EventWrapper_default_instance_;
}  // namespace events
}  // namespace messaging
}  // namespace markethub
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace markethub {
namespace messaging {
namespace events {

// ===================================================================


// -------------------------------------------------------------------

class EventWrapper final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:markethub.messaging.events.EventWrapper) */ {
 public:
  inline EventWrapper() : EventWrapper(nullptr) {}
  ~EventWrapper() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EventWrapper(
      ::google::protobuf::internal::ConstantInitialized);

  inline EventWrapper(const EventWrapper& from) : EventWrapper(nullptr, from) {}
  inline EventWrapper(EventWrapper&& from) noexcept
      : EventWrapper(nullptr, std::move(from)) {}
  inline EventWrapper& operator=(const EventWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventWrapper& operator=(EventWrapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {

===== FILE: ./libs/markethub/messaging/include/models/events/strategy.pb.h =====
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: events/strategy.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_events_2fstrategy_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_events_2fstrategy_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h" // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "system.pb.h"
#include "trading.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_events_2fstrategy_2eproto

namespace google {
  namespace protobuf {
    namespace internal {
      class AnyMetadata;
    } // namespace internal
  } // namespace protobuf
} // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_events_2fstrategy_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_events_2fstrategy_2eproto;
namespace markethub {
  namespace messaging {
    namespace events {
      namespace strategy {
        class BookSequenceNumber;
        struct BookSequenceNumberDefaultTypeInternal;
        extern BookSequenceNumberDefaultTypeInternal _BookSequenceNumber_default_instance_;
        class EndOnData;
        struct EndOnDataDefaultTypeInternal;
        extern EndOnDataDefaultTypeInternal _EndOnData_default_instance_;
        class OnData;
        struct OnDataDefaultTypeInternal;
        extern OnDataDefaultTypeInternal _OnData_default_instance_;
        class OnExecutionReport;
        struct OnExecutionReportDefaultTypeInternal;
        extern OnExecutionReportDefaultTypeInternal _OnExecutionReport_default_instance_;
        class OnParamsChanged;
        struct OnParamsChangedDefaultTypeInternal;
        extern OnParamsChangedDefaultTypeInternal _OnParamsChanged_default_instance_;
        class Statistics;
        struct StatisticsDefaultTypeInternal;
        extern StatisticsDefaultTypeInternal _Statistics_default_instance_;
        class StrategyExecutionStarted;
        struct StrategyExecutionStartedDefaultTypeInternal;
        extern StrategyExecutionStartedDefaultTypeInternal
            _StrategyExecutionStarted_default_instance_;
      } // namespace strategy
    } // namespace events
  } // namespace messaging
} // namespace markethub
namespace google {
  namespace protobuf {} // namespace protobuf
} // namespace google

namespace markethub {
  namespace messaging {
    namespace events {
      namespace strategy {

        // ===================================================================

        // -------------------------------------------------------------------

        class Statistics final : public ::google::protobuf::Message
        /* @@protoc_insertion_point(class_definition:markethub.messaging.events.strategy.Statistics)
         */
        {

===== FILE: ./libs/markethub/messaging/include/models/events/eventTypes.h =====
#pragma once
#include <string_view>

namespace markethub::messaging::events {

  /// <summary>
  /// Tipos de eventos
  /// </summary>
  struct EventTypes {
    /// Evento disparado cuando se genera un libro.
    static constexpr std::string_view ON_BOOK_GENERATED = "on_book_generated";

    /// Evento disparado cuando se genera un execution report.
    static constexpr std::string_view EXECUTION_REPORT = "execution_report";

    /// Evento disparado cuando se inicia la ejecución de una estrategia.
    static constexpr std::string_view STRATEGY_EXECUTION_STARTED = "strategy_execution_started";

    /// Evento disparado cuando se reciben nuevos datos.
    static constexpr std::string_view ON_DATA = "on_data";

    /// Evento disparado cuando finalizan los datos.
    static constexpr std::string_view END_ON_DATA = "end_on_data";

    /// Evento disparado cuando se recibe un execution report.
    static constexpr std::string_view ON_EXECUTION_REPORT = "on_execution_report";

    /// Evento disparado cuando se generan estadísticas.
    static constexpr std::string_view STATISTICS = "statistics";

    /// Evento disparado cuando se genera un libro para almacenar datos históricos.
    static constexpr std::string_view ON_BOOK_GENERATED_HISTORICAL = "on_book_generated_historical";

    /// Evento disparado cuando se recibe un cambio en los parámetros de la estrategia.
    static constexpr std::string_view ON_PARAMS_CHANGED = "on_params_changed";
  };

} // namespace markethub::messaging::events

===== FILE: ./libs/markethub/messaging/include/models/events/connector.pb.h =====
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: events/connector.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_events_2fconnector_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_events_2fconnector_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/repeated_field.h" // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "trading.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_events_2fconnector_2eproto

namespace google {
  namespace protobuf {
    namespace internal {
      class AnyMetadata;
    } // namespace internal
  } // namespace protobuf
} // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_events_2fconnector_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_events_2fconnector_2eproto;
namespace google {
  namespace protobuf {} // namespace protobuf
} // namespace google

namespace markethub {
  namespace messaging {
    namespace events {
      namespace connector {

        // ===================================================================

        // ===================================================================

        // ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__

        // @@protoc_insertion_point(namespace_scope)
      } // namespace connector
    } // namespace events
  } // namespace messaging
} // namespace markethub

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif // GOOGLE_PROTOBUF_INCLUDED_events_2fconnector_2eproto_2epb_2eh

===== FILE: ./b3-oe-connector/src/OrderMessagingServer.hpp =====
#pragma once

class OrderMessagingServer {
public:
    OrderMessagingServer() = default;
};

===== FILE: ./b3-oe-connector/src/main.cpp =====
#include "OrderMessagingServer.hpp"
#include "OrderEngine.hpp"

int main() {
    OrderMessagingServer messaging;
    OrderEngine engine(&messaging);
    return 0;
}

===== FILE: ./b3-oe-connector/src/OrderEngine.hpp =====
#pragma once

class OrderMessagingServer;

class OrderEngine {
public:
    explicit OrderEngine(OrderMessagingServer* messaging) {}
};

===== FILE: ./b3-oe-connector/src/OrderEngine.cpp =====
#include "OrderEngine.hpp"
#include "OrderMessagingServer.hpp"

// empty stub

===== FILE: ./b3-oe-connector/src/OrderMessagingServer.cpp =====
#include "OrderMessagingServer.hpp"

// empty stub

===== FILE: ./external/B3/BOE/samples/GatewayEmulator/stdafx.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

===== FILE: ./external/B3/BOE/samples/GatewayEmulator/GatewayEmulator.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)

//! [GatewayEmulatorSample]

#include "../Common/Helpers.h"
#include "../Common/Listener.h"

using namespace Samples;

/// Send `ExecutionReportNew` for an incoming `NewOrderSingle` or `BusinessReject` for any other message.
class GatewaySampleListener : public GatewayListener
{
public:
    void onNewOrderSingle(const NewOrderSingle102 & msg, Testing::Gateway* gateway) override
    {
        std::clog << "\nReceived:\n" << msg << std::endl;

        updateReport(msg);

        gateway->send(report_, ++reportsCounter_);
        gateway->outSeqNum(reportsCounter_ + 1);

        std::clog << "\nSent:\n" << report_.message() << std::endl;
    }

    void onSimpleNewOrder(const Messaging::SimpleNewOrder100& msg, Testing::Gateway* gateway) override
    {
        onMessage(msg, gateway);
    }

    void onSimpleModifyOrder(const Messaging::SimpleModifyOrder101& msg, Testing::Gateway* gateway) override
    {
        onMessage(msg, gateway);
    }

    void onOrderCancelReplaceRequest(const Messaging::OrderCancelReplaceRequest104& msg, Testing::Gateway* gateway) override
    {
        onMessage(msg, gateway);
    }

    void onOrderCancelRequest(const Messaging::OrderCancelRequest105& msg, Testing::Gateway* gateway) override
    {
        onMessage(msg, gateway);
    }

    void onNewOrderCross(const Messaging::NewOrderCross106& msg, Testing::Gateway* gateway) override
    {
        onMessage(msg, gateway);
    }

    void onSecurityDefinitionRequest(const Messaging::SecurityDefinitionRequest300& msg, Testing::Gateway* gateway) override
    {
        onMessage(msg, gateway);
    }

    void onQuoteRequest(const Messaging::QuoteRequest401& msg, Testing::Gateway* gateway) override
    {
        onMessage(msg, gateway);
    }

    void onQuoteStatusReport(const Messaging::QuoteStatusReport402& msg, Testing::Gateway* gateway) override
    {
        onMessage(msg, gateway);
    }

    void onQuote(const Messaging::Quote403& msg, Testing::Gateway* gateway) override
    {
        onMessage(msg, gateway);
    }

    void onQuoteCancel(const Messaging::QuoteCancel404& msg, Testing::Gateway* gateway) override
    {
        onMessage(msg, gateway);
    }

    void onQuoteRequestReject(const Messaging::QuoteRequestReject405& msg, Testing::Gateway* gateway) override
    {
        onMessage(msg, gateway);
    }

===== FILE: ./external/B3/BOE/samples/GatewayEmulator/stdafx.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/BOE/B3BOE.h>

#include <iostream>
#include <string>
#include <cstdio>
#include <sstream>
#include <time.h>
#include <fstream>

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
#include <thread>
#include <future>
#include <functional>
#include <chrono>
#endif

using namespace std;
using namespace OnixS::B3::BOE;
using namespace OnixS::B3::BOE::Messaging;

===== FILE: ./external/B3/BOE/samples/TCPDirectGettingStarted/stdafx.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

===== FILE: ./external/B3/BOE/samples/TCPDirectGettingStarted/stdafx.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/BOE/B3BOE.h>

#include <iostream>
#include <string>
#include <cstdio>
#include <sstream>
#include <time.h>
#include <fstream>

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
#include <thread>
#include <future>
#include <functional>
#include <chrono>
#endif

using namespace std;
using namespace OnixS::B3::BOE;
using namespace OnixS::B3::BOE::Messaging;

===== FILE: ./external/B3/BOE/samples/TCPDirectGettingStarted/TCPDirectGettingStarted.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

//! [TCPDirectGettingStartedSample]
#include <OnixS/B3/BOE/TcpDirectStack.h>

#include "../Common/Helpers.h"
#include "../Common/Listener.h"
#include "../Settings/Defaults.h"

using namespace Samples;
using namespace Threading;

SecurityID securityId;
Int64 priceMantissa;
MarketSegmentID marketSegmentId;

int main(int argc, char * argv[]) {
    clog << "B3 BOE TCPDirect Getting Started Sample." << endl << endl;

    marketSegmentId = DefaultMarketSegmentId;
    // Use the IP address belonging to the TcpDirectStack interface in emulator mode.
    string host = "192.168.0.1";
    Port port = 62000;

    bool useEmulator = false;

    if(argc < 4) {
#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
        useEmulator = true;
#else
        std::cerr << "usage: [MarketSegmentId] [Host] [Port] (SecurityId) (PriceMantissa)" << std::endl;
        return 1;
#endif
    }
    else {
        marketSegmentId = atoi(argv[1]);
        host = argv[2];
        port = atoi(argv[3]);
    }

    securityId = argc > 4 ? fromStr<SecurityID>(argv[4]) : DefaultSecurityId;
    priceMantissa = argc > 5 ? fromStr<Int64>(argv[5]) : DefaultPriceMantissa;

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
    std::unique_ptr<GatewayEmulatorThread> gateway;
#endif

    int result = 0;

    try {
        SignalHelper::manageLinuxSignals();

        const SessionSettings settings = fillSettings(useEmulator);

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
        if(useEmulator)
            gateway.reset(new GatewayEmulatorThread(settings.licenseStores(), host, port));
#endif

        TcpDirectAttr attr;

        // The default interface name could be provided by the environment variable
        //     ZF_ATTR="interface=<interface-name>", see TCPDirect specs,
        //
        // or could be set manually:
        //     attr.set("interface", "interface-name");

        TcpDirectStack tcpDirectStack(attr);

        bool finished = false;

        class TcpDirectListener : public Listener
        {
        public:
            explicit TcpDirectListener(bool & finished)
                : finished_(finished) {}

            void onStateChange(SessionStateId::Enum newState, SessionStateId::Enum prevState, Session * session) ONIXS_B3_BOE_OVERRIDE
            {
                Listener::onStateChange(newState, prevState, session);


===== FILE: ./external/B3/BOE/samples/SessionScheduler/SessionScheduler.cpp =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/
#include "stdafx.h"

//! [SessionSchedulerSample]
#include <OnixS/B3/BOE/Session.h>
#include <OnixS/B3/BOE/scheduling/SessionScheduler.h>
#include <OnixS/B3/BOE/threading/Thread.h>

#include "../Common/Helpers.h"

using namespace OnixS::B3::BOE;
using namespace OnixS::B3::BOE::Scheduling;
using namespace Samples;

TimeOfDay operator+ (TimeOfDay time, Scheduling::Seconds seconds)
{
    const Scheduling::Seconds SecondsPerMinute = 60;
    const int MinutesPerHour = 60;
    const Scheduling::Seconds SecondsPerHour = SecondsPerMinute * MinutesPerHour;

    const Scheduling::Seconds sinceMidnight = time.sinceMidnight() + seconds;

    return TimeOfDay(
        sinceMidnight / SecondsPerHour,
        (sinceMidnight / SecondsPerMinute) % MinutesPerHour,
        sinceMidnight % SecondsPerMinute);
}

class SessionStateChangeTracer : public SessionListener
{
    void onStateChange(SessionStateId::Enum newState, SessionStateId::Enum /*prevState*/, Session * session) ONIXS_B3_BOE_OVERRIDE
    {
        std::cout << session->toString() << " changed its state to " << SessionStateId::toString(newState) << '.' << std::endl;
    }
};

class SchedulingIssueDetector : public SessionSchedulerListener
{
public:
    SchedulingIssueDetector() ONIXS_B3_BOE_DEFAULT;

    ~SchedulingIssueDetector() ONIXS_B3_BOE_OVERRIDE ONIXS_B3_BOE_DEFAULT;

    void onLoggingOut(const SessionScheduler & /*scheduler*/, Session * /*session*/, bool * /*allowLogout*/) ONIXS_B3_BOE_OVERRIDE
    {
    }

    void onWarning(const SessionScheduler & /*scheduler*/, Session * session, const std::string & warningReason) ONIXS_B3_BOE_OVERRIDE
    {
        std::cout << "Scheduler reported a warning for the session " << session->toString() << ": " << warningReason;
    }

    void onError(const SessionScheduler & /*scheduler*/, Session * session, const std::string & errorReason) ONIXS_B3_BOE_OVERRIDE
    {
        std::cout << "Error occurred while scheduling session " << session->toString() << ": " << errorReason;
    }
};

class Sample
{
public:
    Sample()
        : session_(ONIXS_B3_BOE_NULLPTR)
        , scheduler_(ONIXS_B3_BOE_NULLPTR)
    {
        about();
    }

    ~Sample()
    {
        if(session_)
            session_->disconnect();

        delete session_;
        delete scheduler_;
    }

    void run(const std::string& host, Scheduling::Port port)
    {
        constructSession();

        constructScheduler();


===== FILE: ./external/B3/BOE/samples/SessionScheduler/stdafx.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/BOE/B3BOE.h>

#include <iostream>
#include <string>
#include <cstdio>
#include <sstream>
#include <time.h>
#include <fstream>

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
#include <thread>
#include <future>
#include <functional>
#include <chrono>
#endif

using namespace std;
using namespace OnixS::B3::BOE::Messaging;

===== FILE: ./external/B3/BOE/samples/Common/BenchmarkSessionListener.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/BOE/CompilerDetection.h>

#include "PerformanceCounter.h"
#include "BenchmarkData.h"
#include "Helpers.h"

#define ONIXS_USE_HUGE_PAGE 1

#if ONIXS_USE_HUGE_PAGE
# ifndef _WIN32
#  include <sys/mman.h>
#  ifdef MAP_FAILED
#   undef MAP_FAILED
#  endif
# define MAP_FAILED reinterpret_cast<void*>(-1)
# endif
#endif

#ifndef MAP_HUGETLB
#  undef ONIXS_USE_HUGE_PAGE
#  define ONIXS_USE_HUGE_PAGE 0
#  undef MAP_FAILED
#endif

#ifdef __GNUC__
# define ONIXS_B3_BOE_PREFETCH(ptr) __builtin_prefetch(ptr, 1, 1);
#else
# define ONIXS_B3_BOE_PREFETCH(ptr) /**/
#endif

class Allocator
{
public:
    Allocator()
        : chunk_(init())
        , ptr_(chunk_)
        , available_(HugePageSize)
    {
    }

    ~Allocator()
    {
        fini(chunk_);
    }

    void* allocate(size_t size)
    {
        size = roundToCasheLine(size);

        if(size > available_)
            throwAllocatorExhausted();

        void* const ptr = ptr_;
        available_ -= size;
        ptr_ = Messaging::advanceByBytes(ptr_, size);

        return ptr;
    }

    template <typename T>
    T* allocate(size_t n)
    {
        return static_cast<T*>(allocate(sizeof(T) * n));
    }

private:
    enum { HugePageSize = 1 << 21 };

    void* init()
    {
        const std::size_t size = HugePageSize;
        void* ptr = ONIXS_B3_BOE_NULLPTR;

#ifdef _WIN32
        ptr = _aligned_malloc(size, 4096);
#else

#  if ONIXS_USE_HUGE_PAGE
        const int flags =  MAP_PRIVATE | MAP_ANONYMOUS | MAP_LOCKED | MAP_POPULATE | MAP_HUGETLB;

===== FILE: ./external/B3/BOE/samples/Common/Helpers.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

//! [Helpers]

#include <OnixS/B3/BOE/B3BOE.h>

#include "../Settings/Defaults.h"

#include <string>
#include <sstream>
#include <iostream>
#include <cstdio>
#include <fstream>

#ifdef _WIN32
#include <conio.h>
#else
#include <pthread.h>
#include <csignal>
#include <cstdlib>
#include <vector>
#include <sys/poll.h>
#endif

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
#include <thread>
#include <future>
#include <functional>
#include <chrono>
#endif

namespace Samples
{
using namespace OnixS::B3::BOE::Messaging;

typedef MessageHolder<NewOrderSingle102> NewOrderSingle;
typedef MessageHolder<OrderCancelReplaceRequest104> OrderCancelReplaceRequest;
typedef MessageHolder<OrderCancelRequest105> OrderCancelRequest;
typedef MessageHolder<OrderMassActionRequest701> OrderMassActionRequest;
typedef MessageHolder<QuoteRequest401> RequestForQuote;
typedef MessageHolder<SecurityDefinitionRequest300> SecurityDefinitionRequest;
typedef MessageHolder<NewOrderCross106> NewOrderCross;

class Helper
{
public:
    static void setOrderFields(NewOrderSingle & order, MarketSegmentID marketSegmentId, SecurityID securityId, Messaging::Account account, Int64 priceMantissa) ONIXS_B3_BOE_NOTHROW
    {
        InboundBusinessHeader & header = order->businessHeader();
        header.setMarketSegmentId(marketSegmentId);

        order->setOrdTagId(100)
            .setMmProtectionReset(Boolean::FalseValue)
            .setClOrdId(1)
            .setAccount(account)
            .setSenderLocation("DMA")
            .setEnteringTrader("TADA")
            .setSelfTradePreventionInstruction(SelfTradePreventionInstruction::None)
            .setSecurityId(securityId)
            .setSide(Side::Buy)
            .setOrdType(OrdType::Limit)
            .setTimeInForce(TimeInForce::Day)
            .setRoutingInstructionToNull()
            .setOrderQty(100)
            .setPrice(PriceOptional(priceMantissa))
            .setInvestorIdToNull()
            .setMemo("VALE3 1714479423613")
            .setDeskId("1");

        InvestorID iid;
        iid.setPrefix(300);
        iid.setDocument(123456);
        order->setInvestorId(iid);
    }

    static void waitUntilEnterKey(const std::string& message)
    {
        std::clog << "\nPress the ENTER key to " << message << ".." << std::endl;

#ifdef _WIN32
        _getch();

===== FILE: ./external/B3/BOE/samples/Common/BenchmarkGatewayListener.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/BOE/testing/Gateway.h>

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)

class BenchmarkGatewayListener : public OnixS::B3::BOE::Testing::ClientMessageListener
{
public:
    void onNewOrderSingle(const NewOrderSingle102 & msg, OnixS::B3::BOE::Testing::Gateway * gateway) override
    {
        report_->businessHeader().setSessionId(msg.businessHeader().sessionId());
        report_->setClOrdId(msg.clOrdId());
        gateway->send(report_, ++reportsCounter_);
        gateway->outSeqNum(reportsCounter_ + 1);
    }

private:
    MessageHolder<ExecutionReportNew200> report_;
    UInt32 reportsCounter_ { 0 };
};

#endif

===== FILE: ./external/B3/BOE/samples/Common/Listener.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/BOE/SessionListener.h>

#include <functional>

namespace Samples
{
    using namespace OnixS::B3::BOE;
    using namespace OnixS::B3::BOE::Messaging;

    struct MessagePrinter
    {
        template <typename MessageType>
        void operator()(const MessageType& msg) const
        {
            std::clog << msg << std::endl;
        }

        static void printMsg(const Messaging::SbeMessage msg)
        {
            if (!processTypified(msg, MessagePrinter()))
                std::clog << "Unknown message type";
        }
    };

class Listener : public SessionListener
{
public:

    ~Listener() ONIXS_B3_BOE_OVERRIDE ONIXS_B3_BOE_DEFAULT;

    void onMessageSending(char* bytes, size_t size, Session*) ONIXS_B3_BOE_OVERRIDE
    {
        std::clog << "\nOutbound message:\n";
        MessagePrinter::printMsg(SbeMessage(bytes, static_cast<Messaging::MessageSize>(size)));
    }

    void onBusinessMessageReject(const BusinessMessageReject206& msg, Session* /*sn*/) ONIXS_B3_BOE_OVERRIDE
    {
        std::clog << "\nReceived:\n" << msg << std::endl << "\tReject reason: " << msg.businessRejectReason() << std::endl;
    }

    void onNegotiateResponse(const NegotiateResponse2& msg, Session* /*sn*/) ONIXS_B3_BOE_OVERRIDE
    {
        std::clog << "\nReceived:\n" << msg << std::endl;
    }

    void onNegotiateReject(const NegotiateReject3& msg, Session* /*sn*/) ONIXS_B3_BOE_OVERRIDE
    {
        std::clog << "\nReceived:\n" << msg << std::endl;
    }

    void onEstablishAck(const EstablishAck5& msg, Session* /*sn*/) ONIXS_B3_BOE_OVERRIDE
    {
        std::clog << "\nReceived:\n" << msg << std::endl;
    }

    void onEstablishReject(const EstablishReject6& msg, Session* /*sn*/) ONIXS_B3_BOE_OVERRIDE
    {
        std::clog << "\nReceived:\n" << msg << std::endl;
    }

    void onSequence(const Sequence9& msg, Session* /*sn*/) ONIXS_B3_BOE_OVERRIDE
    {
        std::clog << "\nReceived:\n"
             << msg << std::endl;
    }

    void onTerminate(const Terminate7& msg, Session* /*sn*/) ONIXS_B3_BOE_OVERRIDE
    {
        std::clog << "\nReceived:\n" << msg << std::endl;
    }

    void onRetransmitReject(const RetransmitReject14& msg, Session* /*sn*/) ONIXS_B3_BOE_OVERRIDE
    {
        std::clog << "\nReceived:\n" << msg << std::endl;
    }

    void onRetransmission(const Retransmission13& msg, Session* /*sn*/) ONIXS_B3_BOE_OVERRIDE
    {

===== FILE: ./external/B3/BOE/samples/Common/PerformanceCounter.inc.h =====
/*
* Copyright Onix Solutions Limited [OnixS].
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#ifdef _WIN32
namespace {
PerformanceCounter::Count getFrequency()
{
    PerformanceCounter::Count result;
    ::QueryPerformanceFrequency(&result);
    return result;
}
}

PerformanceCounter::Count PerformanceCounter::frequency_ = getFrequency();

#endif

std::ostream & operator<<(std::ostream & os, const PerformanceCounter::Count & value)
{
#ifdef _WIN32
    os << value.HighPart << value.LowPart;
#else
    os << '[' << value.tv_sec << '.' << value.tv_nsec << ']';
#endif

    return os;
}

===== FILE: ./external/B3/BOE/samples/Common/PerformanceCounter.h =====
#pragma once
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#include <iosfwd>

#ifdef _WIN32
#include <Windows.h>
#else
#include <time.h>
#endif

/// High-resolution performance counter.
class PerformanceCounter
{
public:
#ifdef _WIN32
    typedef LARGE_INTEGER Count;
#else
    typedef timespec Count;
#endif

    static void setToUndefinedValue(Count * value);

    static bool isUndefinedValue(const Count & value);

    /// Retrieves the current value of the high-resolution performance counter.
    static Count current();

    static void current(Count * result) ONIXS_B3_BOE_NOTHROW;

    typedef long long Span;

    static Span nsSpan(const PerformanceCounter::Count & stop,
                       const PerformanceCounter::Count & start);

    static Span usSpan(const PerformanceCounter::Count & stop,
                       const PerformanceCounter::Count & start);

    static Span elapsedNanoseconds(const PerformanceCounter::Count & start);

    static Span elapsedMicroseconds(const PerformanceCounter::Count & start);

private:
#ifdef _WIN32
    typedef LARGE_INTEGER Frequency;
    static Frequency frequency_;
#endif
};

std::ostream & operator<< (std::ostream & os, const PerformanceCounter::Count & value);

inline bool operator == (const PerformanceCounter::Count & left,
                         const PerformanceCounter::Count & right)
{
#ifdef _WIN32
    return (left.LowPart == right.LowPart && left.HighPart == right.HighPart);
#else
    return (left.tv_nsec == right.tv_nsec && left.tv_sec == right.tv_sec);
#endif
}

inline bool operator != (const PerformanceCounter::Count & left,
                         const PerformanceCounter::Count & right)
{
    return !(left == right);
}


inline
PerformanceCounter::Span PerformanceCounter::nsSpan(const PerformanceCounter::Count & stop,
                                                    const PerformanceCounter::Count & start)
{
#ifdef _WIN32
    return static_cast<PerformanceCounter::Span>((stop.QuadPart - start.QuadPart) * 1000000000.0 /
                                      frequency_.QuadPart);
#else
    return static_cast<PerformanceCounter::Span>((stop.tv_sec - start.tv_sec) * 1000000000 +
                                      (stop.tv_nsec - start.tv_nsec));
#endif
}

inline
PerformanceCounter::Span PerformanceCounter::usSpan(const PerformanceCounter::Count & stop,

===== FILE: ./external/B3/BOE/samples/Common/BenchmarkData.h =====
#pragma once
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#include "PerformanceCounter.h"

#include <numeric>

#ifndef _WIN32
#include <stdlib.h>
#endif

struct BenchmarkData
{
    struct SendMarks {
        PerformanceCounter::Count sendStart;
        PerformanceCounter::Count sendFinish;
        PerformanceCounter::Count overallSendFinish; // includes the OS kernel ::send(..) time

        SendMarks()
            : sendStart()
            , sendFinish()
            , overallSendFinish()
        {}

        PerformanceCounter::Span sendSpanNano() const {
            return PerformanceCounter::nsSpan(sendFinish, sendStart);
        }

        PerformanceCounter::Span overallSendSpanNano() const {
            return PerformanceCounter::nsSpan(overallSendFinish, sendStart);
        }
    };

    struct ReceiveMarks {
        PerformanceCounter::Count recvStart;
        PerformanceCounter::Count recvFinish;

        ReceiveMarks()
            : recvStart()
            , recvFinish()
        {}

        PerformanceCounter::Span recvSpanNano() const {
            return PerformanceCounter::nsSpan(recvFinish, recvStart);
        }
    };

    // Measurement overhead
    struct Overhead
    {
        PerformanceCounter::Span receive;
        PerformanceCounter::Span send;
        PerformanceCounter::Span overallSend;
        PerformanceCounter::Span oneWay;

        Overhead()
            : receive()
            , send()
            , overallSend()
            , oneWay()
        {}
    };

    static PerformanceCounter::Span oneWaySpanNano(const SendMarks & sm, const ReceiveMarks & rm) {
        return PerformanceCounter::nsSpan(rm.recvFinish, sm.sendStart);
    }

    typedef vector<PerformanceCounter::Span> Latencies;

    struct SquareVariance
    {
        explicit SquareVariance(double mean)
            : mean_(mean)
        {}

        double operator()(double sum, PerformanceCounter::Span value) const {
            return sum + std::pow(static_cast<double>(value) - mean_, 2u);
        }

        double mean_;
    };

    static double stdDev(const Latencies& data) {

===== FILE: ./external/B3/BOE/samples/ExternalThreadMode/stdafx.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

===== FILE: ./external/B3/BOE/samples/ExternalThreadMode/ExternalThreadMode.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

//! [ExternalThreadModeSample]
#include "../Common/Helpers.h"
#include "../Common/Listener.h"

int main(int argc, char * argv[])
{
    clog << "B3 BOE ExternalThreadMode Sample." << endl << endl;

    MarketSegmentID marketSegmentId = DefaultMarketSegmentId;
    string host = "127.0.0.1";
    Port port = 62000;

    bool useEmulator = false;

    if (argc < 4)
    {
#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
        useEmulator = true;
#else
        std::cerr << "usage: [MarketSegmentId] [Host] [Port] (SecurityId) (PriceMantissa)" << std::endl;
        return 1;
#endif
    }
    else
    {
        marketSegmentId = atoi(argv[1]);
        host = argv[2];
        port = atoi(argv[3]);
    }

    const SecurityID securityId = argc > 4 ? static_cast<SecurityID>(atoi(argv[4])) : DefaultSecurityId;
    const Int64 priceMantissa = argc > 5 ? fromStr<Int64>(argv[5]) : DefaultPriceMantissa;

    try
    {
        SignalHelper::manageLinuxSignals();

        SessionSettings settings = fillSettings(useEmulator);

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
        std::unique_ptr<GatewayEmulatorThread> gateway;

        if (useEmulator)
            gateway.reset(new GatewayEmulatorThread(settings.licenseStores(), host, port));
#endif

        settings.threadingModel(ThreadingModel::External);

        NewOrderSingle order;
        Helper::setOrderFields(order, marketSegmentId, securityId, DefaultAccount, priceMantissa);
        //Messaging::validate(order);

        TcpStandardStack stack;

        Listener listener;
        Session session(stack, settings, &listener);

        Threading::SharedFuture<void> connectTask = session.connectAsync(host, port);

        while(!connectTask.is_ready())
            stack.dispatchEvents();

        if(connectTask.has_exception())
            connectTask.get();

        session.send(order);

        clog << "\nThe order was sent." << endl;

        clog << "\nPress any key to disconnect the session and terminate the application." << endl;

        while(!Helper::keyPressed())
            stack.dispatchEvents();

        Threading::SharedFuture<void> disconnectTask = session.disconnectAsync();

        while(!disconnectTask.is_ready() || !stack.isQuiescent())
            stack.dispatchEvents();
    }

===== FILE: ./external/B3/BOE/samples/ExternalThreadMode/stdafx.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include "../Settings/Defaults.h"

#include <OnixS/B3/BOE/B3BOE.h>

#include <iostream>
#include <string>
#include <cstdio>
#include <sstream>
#include <time.h>
#include <fstream>

using namespace std;
using namespace Samples;
using namespace OnixS::B3::BOE::Messaging;

===== FILE: ./external/B3/BOE/samples/TCPDirectBenchmark/TCPDirectBenchmark.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

//! [TCPDirectBenchmarkSample]
#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
#include "../Common/BenchmarkGatewayListener.h"
#endif

#include "../Common/BenchmarkSessionListener.h"
#include "../Common/Helpers.h"
#include "../Common/PerformanceCounter.h"

#include "../Settings/Defaults.h"

#ifndef _WIN32
#include <sched.h>      /* header file for POSIX scheduling */
#endif

#include <algorithm>

// #define DEBUGGING

using namespace Samples;

void usage()
{
    clog << "Usage: Benchmark [MarketSegmentId] [Host] [Port] (MainThreadAffinity)"
           " (NumberOfMessages) (IntervalBetweenSendingUsec) (WarmupIntervalUsec)" << endl;
}

int main(int argc, char* argv[])
{
    clog << "B3 BOE TCPDirectBenchmark Sample, version " << Session::version() << "." << endl << endl;

#if !defined(NDEBUG) && !defined(DEBUGGING)
    cerr << "Please use the RELEASE build to measure latency." << endl;
    return 1;
#endif

    MarketSegmentID marketSegmentId = DefaultMarketSegmentId;

    // use the IP address belonging to the TcpDirectStack interface
    string host = "192.168.0.50";

    Port port = 49152;

    bool useEmulator = false;

    if (argc < 4)
    {
#if defined(_WIN32)
        useEmulator = true;
#else
        usage();
        return 1;
#endif
    }
    else
    {
        marketSegmentId = atoi(argv[1]);
        host = argv[2];
        port = atoi(argv[3]);
    }

    const Threading::CpuIndex MainThreadAffinity = argc > 4 ? atoi(argv[4]) : 1u;
    const unsigned int NumberOfMessages = argc > 5 ? atoi(argv[5]) : 300u;
    const unsigned int WarmupIntervalUsec = argc > 7 ? atoi(argv[7]) : 10u;
    const unsigned int IntervalBetweenSendingUsec = std::max(argc > 6 ? atoi(argv[6]) : 10000u, WarmupIntervalUsec);

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
    BenchmarkGatewayListener gatewayListener;
    std::unique_ptr<GatewayEmulatorThread> gateway;
#endif

    int result = 0;

    try
    {
        SignalHelper::manageLinuxSignals();

        SessionSettings settings = fillSettings(useEmulator);


===== FILE: ./external/B3/BOE/samples/TCPDirectBenchmark/stdafx.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

===== FILE: ./external/B3/BOE/samples/TCPDirectBenchmark/stdafx.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/BOE/testing/ABI.h>
#include <OnixS/B3/BOE/threading/Thread.h>
#include <OnixS/B3/BOE/Session.h>
#include <OnixS/B3/BOE/TcpDirectStack.h>

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <iomanip>
#include <cmath>

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
#include <chrono>
#include <functional>
#include <future>
#include <thread>
#endif

#ifdef _WIN32
#include <conio.h>
#else
#include <cstdlib>
#endif

using namespace std;
using namespace OnixS::B3::BOE;
using namespace OnixS::B3::BOE::Messaging;
using namespace OnixS::B3::BOE::Threading;

#ifdef max
#undef max
#endif

===== FILE: ./external/B3/BOE/samples/TradingClient/Settings.cpp =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#include "stdafx.h"

//! [SettingsCpp]
#include "Settings.h"

namespace
{
    void trimSpaces(std::string* str)
    {
        const char whiteSpace[] = " \t\r";

        size_t found = str->find_last_not_of(whiteSpace);

        if (std::string::npos == found)
            str->resize(0);
        else
            str->resize(found + 1);

        found = str->find_first_not_of(whiteSpace);

        if (std::string::npos != found && 0 != found)
            str->erase(0, found);
    }

    int lexicalCompare(const std::string& left, const std::string& right)
    {
#if defined(_WIN32)
        return _stricmp(left.c_str(), right.c_str());
#else
        return strcasecmp(left.c_str(), right.c_str());
#endif
    }
}

namespace Samples
{

Settings::Settings(const std::string& filePath)
{
    std::ifstream in(filePath.c_str());

    if (!in)
    {
        std::string errReason("Cannot open the settings file '");

        errReason += filePath;
        errReason += "'";

        throw std::domain_error(errReason);
    }

    std::string line;

    while (getline(in, line))
    {
        const std::string::size_type comment = line.find('#');

        if (std::string::npos != comment)
            line.resize(comment);

        std::string::size_type separator = line.find('=');

        if (std::string::npos == separator)
            continue;

        std::string key = line.substr(0, separator);

        trimSpaces(&key);

        std::string value = line.substr(separator + 1);

        trimSpaces(&value);

        map_.insert(make_pair(key, value));
    }
}

std::string Settings::get(const std::string& key) const
{
    const Key2ValueMapEntry it = map_.find(key);


===== FILE: ./external/B3/BOE/samples/TradingClient/stdafx.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

===== FILE: ./external/B3/BOE/samples/TradingClient/Main.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

//! [MainCpp]
#include "Settings.h"
#include "TradingClient.h"

using namespace Samples;

namespace
{
    void ensureSettingsAreUpToDate(const Settings& appSettings)
    {
        const std::string upToDateParameter("settingsAreUpToDate");

        if (!appSettings.getAsBool(upToDateParameter))
        {
            std::string errReason("Please update the configuration file (settings.ini) with values received from B3 Support Team and set the '");

            errReason += upToDateParameter;

            errReason += "' configuration parameter to 'true'";

            throw std::domain_error(errReason);
        }
    }
}

int main(int argc, char * argv[])
{
    try
    {
        std::cout << "B3 BOE Trading Client sample." << std::endl
            << "Usage: " << argv[0] << " {ConfigurationFileName}" << std::endl;

        std::string configurationFileName = (argc > 1) ? argv[1] : "settings.ini";

        Settings settings(configurationFileName);

        ensureSettingsAreUpToDate(settings);

        TradingClient client(settings);

        client.run();
    }
    catch (const std::exception& ex)
    {
        std::cerr << std::endl << "Error: " << ex.what() << "." << std::endl;
        return 1;
    }

    return 0;
}
//! [MainCpp]

===== FILE: ./external/B3/BOE/samples/TradingClient/Order.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/
#pragma once

//! [OrderH]
#include <OnixS/B3/BOE/messaging/Integral.h>

#include <string>

namespace Samples
{

struct Order
{
    // Initializes an order.
    Order();

    // Human-readable presentation of the most interesting fields stored in the order.
    std::string toString() const;

    // Returns a unique order id.
    ClOrdID id() const;

    // Setters.
    Order& cIOrdId(ClOrdID value);
    Order& orderId(OrderID value);
    Order& price(UInt64 value);
    Order& orderQty(Quantity value);
    Order& minQty(Quantity value);
    Order& leavesQty(Quantity value);
    Order& cumQty(Quantity value);
    Order& securityId(SecurityID value);
    Order& side(Side::Enum value);
    Order& ordType(OrdType::Enum value);
    Order& stopPx(Int64 value);
    Order& timeInForce(TimeInForce::Enum value);
    Order& expireDate(LocalMktDate value);
    Order& orderStatus(OrdStatus::Enum value);
    Order& lastPx(Int64 value);
    Order& transactTime(UInt64 value);

    ClOrdID cIOrdId_;
    OrderID orderId_;
    Int64 price_;
    QuantityOptional orderQty_;
    QuantityOptional minQty_;
    QuantityOptional leavesQty_;
    QuantityOptional cumQty_;
    SecurityID securityId_;
    Side::Enum side_;
    OrdType::Enum ordType_;
    Int64 stopPx_;
    TimeInForce::Enum timeInForce_;
    LocalMktDate expireDate_;
    OrdStatus::Enum orderStatus_;
    Int64 lastPx_;
    UInt64 transactTime_;
};

}
//! [OrderH]

===== FILE: ./external/B3/BOE/samples/TradingClient/stdafx.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/BOE/B3BOE.h>

#include <iostream>
#include <string>
#include <fstream>
#include <sstream>

using namespace OnixS::B3::BOE;
using namespace OnixS::B3::BOE::Messaging;

===== FILE: ./external/B3/BOE/samples/TradingClient/CUI.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

//! [CuiH]
#include <OnixS/B3/BOE/threading/Thread.h>
#include <OnixS/B3/BOE/threading/Mutex.h>
#include <OnixS/B3/BOE/threading/Guard.h>
#include <OnixS/B3/BOE/messaging/Typification.h>

#include "Book.h"

#include <iostream>
#include <string>
#include <vector>

namespace CUI {

// Utility class which provides facilities to notify a user
// about important events like an incoming message receipt.
struct Screen
{
    struct MessagePrinter
    {
        explicit MessagePrinter(const std::string& prefix) : prefix_(prefix) {}

        template <typename MessageType>
        void operator()(const MessageType& msg) const
        {
            info(prefix_, msg.toString());
        }

        std::string prefix_;
    };

    typedef Threading::Mutex Mutex;
    typedef Threading::Guard<Threading::Mutex> Guard;

    static Mutex& mutex()
    {
        static Mutex mutex;
        return mutex;
    }

    static std::string getInput()
    {
        std::string userInput;
        std::getline(std::cin, userInput);
        return userInput;
    }

    template <typename T>
    static T getInput(const T & defaultValue = T())
    {
        std::string userInput;
        std::getline(std::cin, userInput);

        if (userInput.empty())
            return defaultValue;
        else
        {
            Messaging::Int64 converted = Messaging::Int64();
            std::istringstream ss(userInput);
            ss >> converted;
            return static_cast<T>(converted);
        }
    }

    template <typename T>
    static void getInput(T & value, const T & defaultValue = T())
    {
        std::string userInput;
        std::getline(std::cin, userInput);

        if (userInput.empty())
            value = defaultValue;
        else
        {
            Messaging::Int64 converted = Messaging::Int64();
            std::istringstream ss(userInput);
            ss >> converted;
            value = static_cast<T>(converted);
        }

===== FILE: ./external/B3/BOE/samples/TradingClient/Settings.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

//! [SettingsH]
#include <string>
#include <map>

namespace Samples
{

class Settings
{
public:
    explicit Settings(const std::string& filePath);

    std::string get(const std::string& key) const;
    std::string get(const std::string& key, const std::string& defaultValue) const;

    std::string getIfAny(const std::string& key) const;

    int getAsInt(const std::string& key) const;
    int getAsInt(const std::string& key, int defaultValue) const;

    bool getAsBool(const std::string& key) const;
    bool getAsBool(const std::string& key, bool defaultValue) const;

    bool isSet(const std::string& key) const;

private:
    typedef std::map<std::string, std::string> Key2ValueMap;
    typedef Key2ValueMap::const_iterator Key2ValueMapEntry;

    Key2ValueMap map_;
};

}
//! [SettingsH]

===== FILE: ./external/B3/BOE/samples/TradingClient/TradingClient.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

//! [TradingClientSampleH]
#include <OnixS/B3/BOE/Session.h>

#include "MessageFactory.h"
#include "Settings.h"
#include "CUI.h"
#include "Order.h"
#include "Book.h"

namespace Samples
{
// Sample console-based trading client which sends orders to counterparty
// allows modifying and canceling them. It also handles all other issues
// like handling messages from the counterparty.
class TradingClient ONIXS_B3_BOE_FINAL : private SessionListener
{
public:
    // Initializes the client with a given behavior.
    explicit TradingClient(const Settings& settings);

    // Performs trading by processing user requests.
    void run();

private:
    // Set of control parameters that affect trading.
    const Settings& settings_;

    // Primary BOE session with the counterparty.
    PtrTraits<Session>::UniquePtr session_;

    bool connected_;

    // Store of orders sent to the counterparty.
    Book<Order> orderBook_;
    typedef Book<Order>::EntryList OrderList;

    // Creates SBE messages to be sent to the counterparty.
    MessageFactory messageFactory_;

    // UI-specific part of the trading client.
    typedef CUI::Menu<TradingClient> Menu;

    Menu menu_;

    void constructMenu();

    void createSessions();

    void processSendSequence(CUI::CommandExecutionStatus*);
    void processExit(CUI::CommandExecutionStatus*);
    void processOrderCancelRequest(CUI::CommandExecutionStatus*);
    void processOrderMassActionRequest(CUI::CommandExecutionStatus*);
    void processOrderModifyRequest(CUI::CommandExecutionStatus*);
    void processSendNewOrder(CUI::CommandExecutionStatus*);
    void processViewOrders(CUI::CommandExecutionStatus*);
    void processViewSessions(CUI::CommandExecutionStatus*);
    void processSecurityDefinitionRequest(CUI::CommandExecutionStatus*);
    void processCrossOrder(CUI::CommandExecutionStatus*);
    void resetSequenceNumbers(CUI::CommandExecutionStatus*);
    void processEstablishConnection(CUI::CommandExecutionStatus*);
    void processDisconnect(CUI::CommandExecutionStatus*);

    bool checkSessionConnected();

    template <typename SbeMessageType, size_t MaxMessageSize, typename MessageInitializer>
    void send(Messaging::MessageHolder<SbeMessageType, MaxMessageSize, MessageInitializer> &msg);

    Order* findByOrderId(ClOrdID clOrdId);
    Order newOrder();

    // Listener part.
    void onMessageSending(char* bytes, size_t size, Session*) ONIXS_B3_BOE_OVERRIDE;
    void onNegotiateResponse(const NegotiateResponse2 & msg, Session * sn) ONIXS_B3_BOE_OVERRIDE;
    void onNegotiateReject(const NegotiateReject3 & msg, Session * sn) ONIXS_B3_BOE_OVERRIDE;
    void onEstablishAck(const EstablishAck5 & msg, Session * sn) ONIXS_B3_BOE_OVERRIDE;
    void onEstablishReject(const EstablishReject6 & msg, Session * sn) ONIXS_B3_BOE_OVERRIDE;
    void onSequence(const Sequence9 & msg, Session * sn) ONIXS_B3_BOE_OVERRIDE;
    void onTerminate(const Terminate7 & msg, Session * sn) ONIXS_B3_BOE_OVERRIDE;
    void onRetransmitReject(const Messaging::RetransmitReject14 & msg, Session * sn) ONIXS_B3_BOE_OVERRIDE;

===== FILE: ./external/B3/BOE/samples/TradingClient/Order.cpp =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#include "stdafx.h"

//! [OrderCpp]
#include "Order.h"

#include "../Common/Helpers.h"

namespace Samples
{

Order::Order()
    : cIOrdId_(IdGenerator::newId())
    , orderId_()
    , price_(NullPriceOptional::NullMantissa().value())
    , orderQty_()
    , minQty_(NullQuantityOptional().value())
    , leavesQty_(NullQuantityOptional().value())
    , cumQty_(NullQuantityOptional().value())
    , securityId_()
    , side_(Side::Buy)
    , ordType_(OrdType::Limit)
    , stopPx_(NullPriceOptional::NullMantissa().value())
    , timeInForce_(TimeInForce::Day)
    , expireDate_(NullUInt16().value())
    , orderStatus_(OrdStatus::New)
    , lastPx_()
    , transactTime_()
{
}

template<typename T>
std::string toStrOptional(T value, T emptyValue)
{
    return value == emptyValue ? std::string() : toStr(value);
}

std::string Order::toString() const
{
    std::ostringstream builder;

    builder
        << "ClOrdID = " << cIOrdId_
        << ", OrderID = " << toStr(orderId_)
        << ", SecurityId = " << toStr(securityId_)
        << ", OrderStatus = " << toStr(orderStatus_)
        << ", Type = " << toStr(ordType_)
        << ", Price = " << toStr(price_)
        << ", Quantity = " << toStr(orderQty_)
        << ", MinQty = " << toStrOptional(minQty_, NullQuantityOptional().value())
        << ", LeavesQty = " << toStrOptional(leavesQty_, NullQuantityOptional().value())
        << ", CumQty = " << toStrOptional(cumQty_, NullQuantityOptional().value())
        << ", Side = " << toStr(side_)
        << ", StopPx = " << toStrOptional(stopPx_, NullPriceOptional::NullMantissa().value())
        << ", LastFillPrice = " << toStr(lastPx_)
        << ", TimeInForce = " << toStr(timeInForce_)
        << ", ExpireDate = " << toStr(localMktDateToTimestamp(expireDate_), TimestampFormat::YYYYMMDD)
        << ", TransactTime = " << Timestamp(transactTime_).toString();

    return builder.str();
}

ClOrdID Order::id() const
{
    return cIOrdId_;
}

Order& Order::cIOrdId(ClOrdID value)
{
    cIOrdId_ = value;
    return *this;
}

Order& Order::orderId(OrderID value)
{
    orderId_ = value;
    return *this;
}

Order& Order::price(UInt64 value)
{
    price_ = value;

===== FILE: ./external/B3/BOE/samples/TradingClient/TradingClient.cpp =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#include "stdafx.h"

//! [TradingClientSampleCpp]
#include "../Settings/Defaults.h"

#include "TradingClient.h"

namespace Samples
{
Session* createSession(
    const SessionSettings& settings, SessionListener* listener,
    UInt64 sessionVerId = Session::UndefinedSessionVerID, const std::string& customKey = "")
{
    return new Session(settings, listener, SessionStorageType::FileBased, ONIXS_B3_BOE_NULLPTR, sessionVerId, customKey);
}

template <typename MsgType>
bool isRetransmitted(const MsgType& msg)
{
    return msg.businessHeader().eventIndicator().possResend();
}

template <typename MsgType>
void setCommonFields(Order * order, const MsgType& msg)
{
    order->
         orderQty(msg.orderQty())
        .securityId(msg.securityId())
        .transactTime(msg.transactTime().time());
}

template <>
void setCommonFields<ExecutionReportReject204>(Order * order, const ExecutionReportReject204 & msg)
{
    QuantityOptional orderQty;

    if(msg.orderQty(orderQty))
        order->orderQty(orderQty);

    order->
        securityId(msg.securityId())
        .transactTime(msg.transactTime().time());
}

template <typename MsgType>
void setExpireDate(Order * order, const MsgType& msg)
{
    Timestamp expireDate;
    if(msg.expireDate(expireDate))
        order->expireDate_ = timestampToLocalMktDate(expireDate);
}

template <typename MsgType>
void setOrdStatus(OrdStatus::Enum & ordStatus, const MsgType& msg)
{
    ordStatus = msg.ordStatus();
}

using namespace CUI;

typedef ListViewer<Order> OrdersViewer;

template <typename SbeMessageType, size_t MaxMessageSize, typename MessageInitializer>
void TradingClient::send(Messaging::MessageHolder<SbeMessageType, MaxMessageSize, MessageInitializer> &msg)
{
    if (!checkSessionConnected())
        return;

    session_->send(msg);
}

Order* TradingClient::findByOrderId(ClOrdID clOrdId)
{
    Order* const msg = orderBook_.find(clOrdId);

    if (!msg)
    {
        std::stringstream ss;
        ss
            << "Cannot process received Execution Report. No order was sent with ClOrdID (tag = 11) equal to '"
            << clOrdId

===== FILE: ./external/B3/BOE/samples/TradingClient/MessageFactory.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

//! [MessageFactoryH]
#include "../Common/Helpers.h"

#include "Order.h"

namespace Samples {

// Constructs SBE messages of specific types according to the given parameters.
class MessageFactory
{
public:
    explicit MessageFactory(MarketSegmentID marketSegmentId);

    // Constructs a reusable NewOrderSingle message according to the given order traits.
    NewOrderSingle & getNewOrder(const Order& order) const;

    // Constructs a reusable OrderCancelReplaceRequest message for the given order.
    OrderCancelReplaceRequest & getModifyRequest(const Order& order) const;

    // Constructs a reusable OrderCancelRequest message for the given order.
    OrderCancelRequest & getCancelRequest(const Order& order) const;

    // Constructs a reusable NewOrderCross message according to the given order traits.
    NewOrderCross & getNewOrderCross(const Order& buySideOrder, const Order& sellSideOrder) const;

    // Constructs a reusable OrderMassActionRequest message.
    OrderMassActionRequest & getOrderMassActionRequest() const;

    // Constructs a reusable SecurityDefinitionRequest message.
    SecurityDefinitionRequest & getSecurityDefinitionRequest() const;

private:
    NewOrderSingle initNewOrder() const;
    OrderCancelReplaceRequest initOrderCancelReplaceRequest() const;
    OrderCancelRequest initOrderCancelRequest() const;
    NewOrderCross initNewOrderCross() const;
    OrderMassActionRequest initOrderMassActionRequest() const;
    SecurityDefinitionRequest initSecurityDefinitionRequest() const;

    InvestorID iid_;
    MarketSegmentID marketSegmentId_;
};

}
//! [MessageFactoryH]

===== FILE: ./external/B3/BOE/samples/TradingClient/MessageFactory.cpp =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#include "stdafx.h"

//! [MessageFactoryCpp]
#include "../Settings/Defaults.h"

#include "MessageFactory.h"

namespace Samples {

const char* Location = "DMA";
const char* EnteringTrader = "TADA";
const char* DeskId = "1";
const OrdTagID OrderTag = 100;
const Account Account = 10101;

template<typename MessageType>
void setMarketSegmentId(MessageType & msg, MarketSegmentID marketSegmentId)
{
    msg->businessHeader().setMarketSegmentId(marketSegmentId);
}

MessageFactory::MessageFactory(MarketSegmentID marketSegmentId)
{
    iid_.setPrefix(300);
    iid_.setDocument(123456);
    marketSegmentId_ = marketSegmentId;
}

NewOrderSingle MessageFactory::initNewOrder() const
{
    NewOrderSingle msg;

    setMarketSegmentId(msg, marketSegmentId_);

    msg->setOrdTagId(OrderTag)
        .setMmProtectionReset(Boolean::FalseValue)
        .setSenderLocation(Location)
        .setEnteringTrader(EnteringTrader)
        .setSelfTradePreventionInstruction(SelfTradePreventionInstruction::None)
        .setMemo("ONIXS 123456789")
        .setDeskId(DeskId)
        .setAccount(Account)
        .setInvestorId(iid_);

    return msg;
}

NewOrderSingle & MessageFactory::getNewOrder(const Order& order) const
{
    static NewOrderSingle msg = initNewOrder();

    msg->setPrice(PriceOptional(order.price_))
        .setOrderQty(order.orderQty_)
        .setSecurityId(order.securityId_)
        .setClOrdId(order.cIOrdId_)
        .setStopPx(PriceOptional(order.stopPx_))
        .setMinQty(order.minQty_)
        .setOrdType(order.ordType_)
        .setTimeInForce(order.timeInForce_)
        .setSide(order.side_);

    if (order.timeInForce_ == TimeInForce::GoodTillDate)
        msg->setExpireDate(localMktDateToTimestamp(order.expireDate_));

    return msg;
}

OrderCancelReplaceRequest MessageFactory::initOrderCancelReplaceRequest() const
{
    OrderCancelReplaceRequest msg;

    setMarketSegmentId(msg, marketSegmentId_);

    msg->setOrdTagId(OrderTag)
        .setMmProtectionReset(Boolean::FalseValue)
        .setSenderLocation(Location)
        .setEnteringTrader(EnteringTrader)
        .setSelfTradePreventionInstruction(SelfTradePreventionInstruction::None)
        .setMemo("ONIXS 123456789")
        .setInvestorId(iid_)
        .setAccount(Account)

===== FILE: ./external/B3/BOE/samples/TradingClient/Book.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

//! [BookH]
#include <string>
#include <vector>
#include <map>

namespace Samples
{

// Collection of book entries (e.g., orders) currently manipulated by the trading client.
template <typename EntryType>
class Book
{
public:
    typedef std::map<ClOrdID, EntryType> BookEntries;
    typedef typename BookEntries::iterator EntryIter;

    // Adds an entry to the book.
    Book& store(const EntryType& entry);
    Book& store(const EntryType& entry, ClOrdID id);

    // Finds an instance of the entry by its identifier.
    // If there's no entry available, returns NULL.
    EntryType* find(ClOrdID id);

    typedef std::vector<EntryType*> EntryList;

    // Returns a collection of stored book entries.
    void getEntries(EntryList & list);

private:
    typedef Threading::Mutex Mutex;
    typedef Threading::Guard<Threading::Mutex> Guard;

    Mutex mutex_;
    BookEntries entries_;
};

template <typename EntryType>
Book<EntryType>& Book<EntryType>::store(const EntryType& newEntry)
{
    return store(newEntry, newEntry.id());
}

template <typename EntryType>
Book<EntryType>& Book<EntryType>::store(const EntryType& newEntry, ClOrdID id)
{
    const Guard guard(mutex_);

    const std::pair<EntryIter, bool> result = entries_.insert(std::make_pair(id, newEntry));

    if (!result.second)
    {
        std::stringstream ss;
        ss << "Book already has an entry registered under ID = '" << id << "'.";
        throw std::domain_error(ss.str());
    }

    return *this;
}

template <typename EntryType>
EntryType* Book<EntryType>::find(ClOrdID id)
{
    const Guard guard(mutex_);

    const EntryIter entry = entries_.find(id);
    return entry == entries_.end() ? ONIXS_B3_BOE_NULLPTR : &entry->second;
}

template <typename EntryType>
void Book<EntryType>::getEntries(Book<EntryType>::EntryList & list)
{
    const Guard guard(mutex_);

    for (EntryIter iter = entries_.begin(); iter != entries_.end(); ++iter)
        list.push_back(&iter->second);
}

}

===== FILE: ./external/B3/BOE/samples/TCPStandardBenchmark/stdafx.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

===== FILE: ./external/B3/BOE/samples/TCPStandardBenchmark/stdafx.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/BOE/testing/ABI.h>
#include <OnixS/B3/BOE/threading/Thread.h>
#include <OnixS/B3/BOE/Session.h>
#include <OnixS/B3/BOE/TcpStandardStack.h>

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <iomanip>
#include <cmath>

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
#include <chrono>
#include <functional>
#include <future>
#include <thread>
#endif

#ifdef _WIN32
#include <conio.h>
#else
#include <cstdlib>
#endif

using namespace std;
using namespace OnixS::B3::BOE;
using namespace OnixS::B3::BOE::Messaging;
using namespace OnixS::B3::BOE::Threading;

#ifdef max
#undef max
#endif

===== FILE: ./external/B3/BOE/samples/TCPStandardBenchmark/TCPStandardBenchmark.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

//! [TCPStandardBenchmarkSample]
#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
#include "../Common/BenchmarkGatewayListener.h"
#endif

#include "../Common/BenchmarkSessionListener.h"
#include "../Common/Helpers.h"
#include "../Common/PerformanceCounter.h"

#include "../Settings/Defaults.h"

#ifndef _WIN32
#include <sched.h>      /* header file for POSIX scheduling */
#endif

#include <algorithm>

// #define DEBUGGING

using namespace Samples;

void usage()
{
    clog << "Usage: Benchmark [MarketSegmentId] [Host] [Port] (MainThreadAffinity)"
           " (NumberOfMessages) (IntervalBetweenSendingUsec) (WarmupIntervalUsec)" << endl;
}

int main(int argc, char* argv[])
{
    clog << "B3 BOE TCPStandardBenchmark Sample, version " << Session::version() << "." << endl << endl;

#if !defined(NDEBUG) && !defined(DEBUGGING)
    cerr << "Please use the RELEASE build to measure latency." << endl;
    return 1;
#endif

    MarketSegmentID marketSegmentId = DefaultMarketSegmentId;

    string host = "127.0.0.1";
    Port port = 49152;

    bool useEmulator = false;

    if (argc < 4)
    {
#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
        useEmulator = true;
        clog << "WARNING: gateway emulator is used!" << endl;
#else
        usage();
        return 1;
#endif
    }
    else
    {
        marketSegmentId = atoi(argv[1]);
        host = argv[2];
        port = atoi(argv[3]);
    }

    const Threading::CpuIndex MainThreadAffinity = argc > 4 ? atoi(argv[4]) : 1u;
    const unsigned int NumberOfMessages = argc > 5 ? atoi(argv[5]) : 300u;
    const unsigned int WarmupIntervalUsec = argc > 7 ? atoi(argv[7]) : 10u;
    const unsigned int IntervalBetweenSendingUsec = std::max(argc > 6 ? atoi(argv[6]) : 10000u, WarmupIntervalUsec);

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
    BenchmarkGatewayListener gatewayListener;
    std::unique_ptr<GatewayEmulatorThread> gateway;
#endif

    int result = 0;

    try
    {
        SignalHelper::manageLinuxSignals();

        SessionSettings settings = fillSettings(useEmulator);

        settings

===== FILE: ./external/B3/BOE/samples/ThreadPoolMode/stdafx.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

===== FILE: ./external/B3/BOE/samples/ThreadPoolMode/stdafx.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include "../Settings/Defaults.h"

#include <OnixS/B3/BOE/B3BOE.h>

#include <iostream>
#include <string>
#include <cstdio>
#include <sstream>
#include <time.h>
#include <fstream>

using namespace std;
using namespace Samples;
using namespace OnixS::B3::BOE;
using namespace OnixS::B3::BOE::Messaging;

===== FILE: ./external/B3/BOE/samples/ThreadPoolMode/ThreadPoolMode.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

//! [ThreadPoolModeSample]
#include "../Common/Helpers.h"
#include "../Common/Listener.h"

int main(int argc, char * argv[])
{
    clog << "B3 BOE ThreadPoolMode Sample." << endl << endl;

    MarketSegmentID marketSegmentId = DefaultMarketSegmentId;
    string host = "127.0.0.1";
    Port port = 49152;

    bool useEmulator = false;

    if (argc < 4)
    {
#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
        useEmulator = true;
#else
        std::cerr << "usage: [MarketSegmentId] [Host] [Port] (SecurityId) (PriceMantissa)" << std::endl;
        return 1;
#endif
    }
    else
    {
        marketSegmentId = atoi(argv[1]);
        host = argv[2];
        port = atoi(argv[3]);
    }

    const SecurityID securityId = argc > 4 ? static_cast<SecurityID>(atoi(argv[4])) : DefaultSecurityId;
    const Int64 priceMantissa = argc > 5 ? fromStr<Int64>(argv[5]) : DefaultPriceMantissa;

    try
    {
        SignalHelper::manageLinuxSignals();

        SessionSettings settings = fillSettings(useEmulator);

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
        std::unique_ptr<GatewayEmulatorThread> gateway;

        if (useEmulator)
            gateway.reset(new GatewayEmulatorThread(settings.licenseStores(), host, port));
#endif

        settings.threadingModel(ThreadingModel::Pool);

        NewOrderSingle order;
        Helper::setOrderFields(order, marketSegmentId, securityId, DefaultAccount, priceMantissa);

        Listener listener;
        Session session(settings, &listener);

        session
            .connect(host, port)
            .send(order);

        clog << "\nThe order was sent." << endl;

        Helper::waitUntilEnterKey("disconnect the session and terminate the application");

        session.disconnect();
    }
    catch(const std::exception & ex)
    {
        cerr << "\nEXCEPTION: " << ex.what() << endl;
        return 1;
    }

    return 0;
}
//! [ThreadPoolModeSample]

===== FILE: ./external/B3/BOE/samples/Benchmark/stdafx.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

===== FILE: ./external/B3/BOE/samples/Benchmark/stdafx.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/BOE/threading/Thread.h>
#include <OnixS/B3/BOE/Session.h>
#include <OnixS/B3/BOE/testing/ABI.h>

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <iomanip>
#include <cmath>

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
#include <chrono>
#include <functional>
#include <future>
#include <thread>
#endif

#ifdef _WIN32
#include <conio.h>
#else
#include <cstdlib>
#endif

using namespace std;
using namespace OnixS::B3::BOE;
using namespace OnixS::B3::BOE::Messaging;
using namespace OnixS::B3::BOE::Threading;

#ifdef max
#undef max
#endif

===== FILE: ./external/B3/BOE/samples/Benchmark/Benchmark.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

//! [BenchmarkSample]

#include <OnixS/B3/BOE/threading/Semaphore.h>

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
#include "../Common/BenchmarkGatewayListener.h"
#endif

#include "../Common/BenchmarkSessionListener.h"
#include "../Common/Helpers.h"
#include "../Common/PerformanceCounter.h"

#include "../Settings/Defaults.h"

#ifndef _WIN32
#include <sched.h>      /* header file for POSIX scheduling */
#endif

#include <algorithm>

// #define DEBUGGING

using namespace Samples;

void usage()
{
    clog << "Usage: Benchmark [MarketSegmentId] [Host] [Port] (MainThreadAffinity) (ReceivingThreadAffinity) (AuxiliarySendingThreadAffinity)"
           " (NumberOfMessages) (IntervalBetweenSendingUsec) (WarmupIntervalUsec)" << endl;
}

int main(int argc, char* argv[])
{
    clog << "B3 BOE Benchmark Sample, version " << Session::version() << "." << endl << endl;

#if !defined(NDEBUG) && !defined(DEBUGGING)
    cerr << "Please use the RELEASE build to measure latency." << endl;
    return 1;
#endif

    MarketSegmentID marketSegmentId = DefaultMarketSegmentId;
    string host = "127.0.0.1";
    Port port = 49152;

    bool useEmulator = false;

    if (argc < 4)
    {
#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
        useEmulator = true;
        clog << "WARNING: gateway emulator is used!" << endl;
#else
        usage();
        return 1;
#endif
    }
    else
    {
        marketSegmentId = atoi(argv[1]);
        host = argv[2];
        port = atoi(argv[3]);
    }

    const Threading::CpuIndex MainThreadAffinity = argc > 4 ? atoi(argv[4]) : 1u;
    const Threading::CpuIndex ReceivingThreadAffinity = argc > 5 ? atoi(argv[5]) : 2u;
    const Threading::CpuIndex AuxiliarySendingThreadAffinity = argc > 6 ? atoi(argv[6]) : 3u;
    const unsigned int NumberOfMessages = argc > 7 ? atoi(argv[7]) : 300u;
    const unsigned int WarmupIntervalUsec = argc > 9 ? atoi(argv[9]) : 10u;
    const unsigned int IntervalBetweenSendingUsec = std::max(argc > 8 ? atoi(argv[8]) : 10000u, WarmupIntervalUsec);

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
    BenchmarkGatewayListener gatewayListener;
    std::unique_ptr<GatewayEmulatorThread> gateway;
#endif

    int result = 0;

    try
    {
        SignalHelper::manageLinuxSignals();

===== FILE: ./external/B3/BOE/samples/GettingStarted/GettingStarted.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

//! [GettingStartedSample]

#include "../Common/Helpers.h"
#include "../Common/Listener.h"
#include "../Settings/Defaults.h"

using namespace Samples;

Session* createSession(const SessionSettings& settings, SessionListener* listener)
{
    return new Session(settings, listener);
}

int main(int argc, char * argv[])
{
    clog << "B3 BOE Getting Started Sample." << endl << endl;

    MarketSegmentID marketSegmentId = DefaultMarketSegmentId;
    string host = "127.0.0.1";
    Port port = 62000;

    bool useEmulator = false;

    if (argc < 4)
    {
#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
        useEmulator = true;
#else
        std::cerr << "usage: [MarketSegmentId] [Host] [Port] (SecurityId) (PriceMantissa)" << std::endl;
        return 1;
#endif
    }
    else
    {
        marketSegmentId = atoi(argv[1]);
        host = argv[2];
        port = atoi(argv[3]);
    }

    const SecurityID securityId = argc > 4 ? fromStr<SecurityID>(argv[4]) : DefaultSecurityId;
    const Int64 priceMantissa = argc > 5 ? fromStr<Int64>(argv[5]) : DefaultPriceMantissa;

    try
    {
        SignalHelper::manageLinuxSignals();

        const SessionSettings settings = fillSettings(useEmulator);

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
        std::unique_ptr<GatewayEmulatorThread> gateway;

        if (useEmulator)
            gateway.reset(new GatewayEmulatorThread(settings.licenseStores(), host, port));
#endif

        Listener listener;
        ScopedPtr<Session> session(createSession(settings, &listener));

        NewOrderSingle order;
        Helper::setOrderFields(order, marketSegmentId, securityId, DefaultAccount, priceMantissa);

        session
            ->connect(host, port)
            .send(order);

        clog << "\nThe order was sent." << endl;

        Helper::waitUntilEnterKey("disconnect the session and terminate the application");

        session->disconnect();
    }
    catch(const std::exception & ex)
    {
        cerr << "\nEXCEPTION: " << ex.what() << endl;
        return 1;
    }

    return 0;
}

===== FILE: ./external/B3/BOE/samples/GettingStarted/stdafx.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

===== FILE: ./external/B3/BOE/samples/GettingStarted/stdafx.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/BOE/B3BOE.h>

#include <iostream>
#include <string>
#include <cstdio>
#include <sstream>
#include <time.h>
#include <fstream>

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
#include <thread>
#include <future>
#include <functional>
#include <chrono>
#endif

using namespace std;
using namespace OnixS::B3::BOE::Messaging;

===== FILE: ./external/B3/BOE/samples/PluggableStorage/stdafx.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

===== FILE: ./external/B3/BOE/samples/PluggableStorage/stdafx.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/BOE/B3BOE.h>

#include <iostream>
#include <string>

using namespace std;
using namespace OnixS::B3::BOE::Messaging;

===== FILE: ./external/B3/BOE/samples/PluggableStorage/PluggableStorage.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

//! [PluggableStorageSampleCpp]
#include "MySessionStorage.h"

#include "../Common/Listener.h"
#include "../Common/Helpers.h"
#include "../Settings/Defaults.h"

using namespace Samples;

int main(int argc, char* argv[])
{
    clog << "B3 BOE PluggableStorage Sample." << endl << endl;

    MarketSegmentID marketSegmentId = DefaultMarketSegmentId;
    string host = "127.0.0.1";
    Port port = 49152;

    bool useEmulator = false;

    if (argc < 4)
    {
#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
        useEmulator = true;
#else
        std::cerr << "usage: [MarketSegmentId] [Host] [Port]" << std::endl;
        return 1;
#endif
    }
    else
    {
        marketSegmentId = atoi(argv[1]);
        host = argv[2];
        port = atoi(argv[3]);
    }

    try
    {
        const SessionSettings settings = fillSettings(useEmulator);

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)
        std::unique_ptr<GatewayEmulatorThread> gateway;

        if (useEmulator)
            gateway.reset(new GatewayEmulatorThread(settings.licenseStores(), host, port));
#endif

        MySessionStorage storage;
        Listener listener;

        Session session(settings, &listener, SessionStorageType::Pluggable, &storage);

        NewOrderSingle order;
        Helper::setOrderFields(order, marketSegmentId, DefaultSecurityId, DefaultAccount, DefaultPriceMantissa);

        session
            .connect(host, port)
            .send(order);

        Helper::waitUntilEnterKey("disconnect the session and terminate the application");

        session.disconnect();
    }
    catch (const exception& ex)
    {
        cerr << "EXCEPTION: " << ex.what() << endl;
        return 1;
    }

    return 0;
}
//! [PluggableStorageSampleCpp]

===== FILE: ./external/B3/BOE/samples/PluggableStorage/MySessionStorage.h =====

/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/
#pragma once

//! [PluggableStorageSampleMySessionStorageH]

#include <OnixS/B3/BOE/SessionStorage.h>

#include <vector>
#include <list>

namespace Samples
{

using namespace OnixS::B3::BOE;
using namespace OnixS::B3::BOE::Messaging;

class MySessionStorage : public SessionStorage
{
public:
    MySessionStorage();

    UInt64 sessionVerId() const ONIXS_B3_BOE_OVERRIDE;

    void sessionVerId(UInt64 value) ONIXS_B3_BOE_OVERRIDE;

    const std::string & id() const ONIXS_B3_BOE_OVERRIDE;

    SeqNumber inSeqNum() const ONIXS_B3_BOE_OVERRIDE;

    void inSeqNum(SeqNumber msgSeqNum) ONIXS_B3_BOE_OVERRIDE;

    SeqNumber outSeqNum() const ONIXS_B3_BOE_OVERRIDE;

    void outSeqNum(SeqNumber msgSeqNum) ONIXS_B3_BOE_OVERRIDE;

    bool negotiated() const ONIXS_B3_BOE_OVERRIDE;

    void negotiated(bool status) ONIXS_B3_BOE_OVERRIDE;

    Timestamp sessionCreationTime() const ONIXS_B3_BOE_OVERRIDE;

    void sessionCreationTime(Timestamp) ONIXS_B3_BOE_OVERRIDE;

    void close(bool doBackup = false) ONIXS_B3_BOE_OVERRIDE;

    void storeInboundMessage(const NetworkMessage& message, SeqNumber msgSeqNum, Timestamp messageReceivingUtcTimestamp = Timestamp()) ONIXS_B3_BOE_OVERRIDE;

    void storeOutboundMessage(const NetworkMessage& message, SeqNumber msgSeqNum, Timestamp messageSendingUtcTimestamp = Timestamp()) ONIXS_B3_BOE_OVERRIDE;

    void flush() ONIXS_B3_BOE_OVERRIDE;

    void warmup(size_t, Timestamp) ONIXS_B3_BOE_OVERRIDE;

    typedef std::vector<char> Message;
    typedef std::list<Message> Messages;

private:
    SeqNumber inSeqNum_;
    SeqNumber outSeqNum_;
    std::string id_;
    bool negotiated_;
    Timestamp sessionCreationTime_;
    UInt64 sessionVerId_;
    Messages inboundMessages_;
    Messages outboundMessages_;
};

}
//! [PluggableStorageSampleMySessionStorageH]

===== FILE: ./external/B3/BOE/samples/PluggableStorage/MySessionStorage.cpp =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#include "stdafx.h"

//! [PluggableStorageSampleMySessionStorageCpp]
#include "MySessionStorage.h"

#include "../Common/Helpers.h"
#include "../Common/Listener.h"

namespace Samples
{

namespace
{
    const char* begin(const NetworkMessage& message) ONIXS_B3_BOE_NOTHROW
    {
        return static_cast<const char*>(message.data());
    }

    const char* end(const NetworkMessage& message) ONIXS_B3_BOE_NOTHROW
    {
        return static_cast<const char*>(advanceByBytes(message.data(), message.size()));
    }

    void storeMessage(MySessionStorage::Messages & storage, const NetworkMessage& message)
    {
        storage.push_back(MySessionStorage::Message(begin(message), end(message)));

        if (!processTypified(message.message(), MessagePrinter()))
            throw runtime_error("Unknown message type");
    }
}

MySessionStorage::MySessionStorage()
    : inSeqNum_(1)
    , outSeqNum_(1)
    , id_(IdGenerator::newStrId())
    , negotiated_(false)
    , sessionCreationTime_()
    , sessionVerId_(Session::UndefinedSessionVerID)
{}

UInt64 MySessionStorage::sessionVerId() const
{
    return sessionVerId_;
}

void MySessionStorage::sessionVerId(UInt64 value)
{
    std::clog << "\nSet sessionVerId to " << value << ".\n";
    sessionVerId_ = value;
}

void MySessionStorage::close(bool doBackup)
{
    std::clog << "\nClose the session storage (doBackup=" << doBackup <<  ").\n";

    inSeqNum_ = 1;
    outSeqNum_ = 1;
    negotiated_ = false;
    inboundMessages_.clear();
    outboundMessages_.clear();
    sessionVerId_ = Session::UndefinedSessionVerID;
}

const std::string & MySessionStorage::id() const
{
    return id_;
}

SeqNumber MySessionStorage::inSeqNum() const
{
    return inSeqNum_;
}

void MySessionStorage::inSeqNum(SeqNumber msgSeqNum)
{
    std::clog << "\nSet inSeqNum to " << msgSeqNum << ".\n";
    inSeqNum_ = msgSeqNum;
}

SeqNumber MySessionStorage::outSeqNum() const

===== FILE: ./external/B3/BOE/samples/SbeLogDecoder/stdafx.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

===== FILE: ./external/B3/BOE/samples/SbeLogDecoder/stdafx.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/BOE/B3BOE.h>
#include <OnixS/B3/BOE/utils/FileSystem.h>

#include <iostream>
#include <fstream>
#include <vector>
#include <string>

#ifdef _WIN32
# include <conio.h>
#else
# include <cstdlib>
#endif

using namespace std;
using namespace OnixS::B3::BOE::Messaging;
using namespace OnixS::B3::BOE::Encoding;

===== FILE: ./external/B3/BOE/samples/SbeLogDecoder/SbeLogDecoder.cpp =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#include "stdafx.h"

//! [SbeLogDecoderSample]
namespace
{
    struct MessagePrinter
    {
        MessagePrinter(ofstream& outFile, StrRef prefix)
            : outFile_(outFile)
            , prefix_(prefix)
        {}

        template <typename MessageType>
        void operator()(const MessageType& msg) const
        {
            outFile_ << prefix_ << msg << endl << endl;

            std::cout << prefix_ << msg << endl << endl;
        }

        ofstream& outFile_;
        const StrRef prefix_;
    };

    std::string getOutputFileName(const std::string& entryName)
    {
        const char * const DecodedSummaryFileExtension = ".txt";
        return entryName.substr(0, entryName.find_last_of(".")) + DecodedSummaryFileExtension;
    }

    size_t decodeSbeLogFile(const string& summaryFileName)
    {
        const std::string outputFileName = getOutputFileName(summaryFileName);
        ofstream decoded(outputFileName.c_str());

        if (!decoded)
            throw runtime_error("Cannot create file: '" + outputFileName + "'");

        ifstream file(summaryFileName.c_str());

        if (!file)
            throw runtime_error("Cannot open " + summaryFileName + " log file.");

        const size_t LogLinePrefixSize = 32;

        string line;
        ByteArray buffer;
        size_t messageCounter = 0;

        while (getline(file, line))
        {
            try
            {
                const StrRef Prefix(line.data(), LogLinePrefixSize);
                const StrRef Base64SbeMessage(line.data() + LogLinePrefixSize, line.size() - LogLinePrefixSize);

                Base64Encoding::decode(buffer, Base64SbeMessage);

                if (buffer.empty())
                    throw runtime_error("Cannot decode an empty message");

                const bool sofhDetected =
                    buffer.size() >= sizeof(SimpleOpenFramingHeader) &&
                    reinterpret_cast<const SimpleOpenFramingHeader*>(&buffer[0])->encoding() == B3BOESbeEncodingType;

                SbeMessage message;
                if(sofhDetected)
                    message = NetworkMessage(&buffer[0], static_cast<MessageSize>(buffer.size())).message();
                else
                    message = SbeMessage(&buffer[0], static_cast<MessageSize>(buffer.size()));

                assert(message.valid());

                if (!processTypified(message, MessagePrinter(decoded, Prefix)))
                    throw runtime_error("Unknown message type");

                ++messageCounter;
            }
            catch (...)
            {
                cerr << "Cannot decode '" << line << "'" << endl;

===== FILE: ./external/B3/BOE/samples/Settings/Defaults.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

//! [Defaults]
#include <OnixS/B3/BOE/B3BOE.h>

namespace Samples
{
    using namespace OnixS::B3::BOE;

    const SecurityID DefaultSecurityId = 100000140035;
    const Messaging::Int64 DefaultPriceMantissa = PriceOptional(10100).mantissa();
    const MarketSegmentID DefaultMarketSegmentId = 80;

    /// Value provided by the exchange
    const Account DefaultAccount = 10101;
};
//! [Defaults]

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/SessionStorage.h =====
#pragma once

/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#include <OnixS/B3/BOE/ABI.h>
#include <OnixS/B3/BOE/Messaging.h>
#include <OnixS/B3/BOE/messaging/Integral.h>
#include <OnixS/B3/BOE/messaging/Time.h>
#include <OnixS/B3/BOE/messaging/NetworkMessage.h>

#include <string>
#include <vector>

namespace OnixS {
namespace B3 {
namespace BOE {

using namespace OnixS::B3::BOE::Messaging;

/// Session Storage Type.
struct SessionStorageType
{
    enum Enum
    {
        /// Undefined Session Storage.
        Undefined = 0,

        /// File-based Session Storage.
        FileBased,

        /// Asynchronous File-Based Session Storage.
        AsyncFileBased,

        /// Memory-based Session Storage.
        MemoryBased,

        /// Pluggable Session Storage
        Pluggable
    };

    ONIXS_B3_BOE_EXPORTED static Enum parse(const std::string &);

    /// \return the session storage type as a string.
    ONIXS_B3_BOE_EXPORTED static const char * toString(SessionStorageType::Enum);
};

/// Session's storage.
class ONIXS_B3_BOE_EXPORTED SessionStorage
{
public:
    /// Destructor.
    virtual ~SessionStorage() ONIXS_B3_BOE_DEFAULT;

    /// \return Storage Id.
    virtual const std::string & id() const = 0;

    /// \return Session Version Identification (sessionVerId).
    virtual UInt64 sessionVerId() const = 0;

    /// Sets Session Version Identification (sessionVerId).
    virtual void sessionVerId(UInt64 value) = 0;

    /// \return the expected sequence number of the next inbound message.
    virtual SeqNumber inSeqNum() const = 0;

    /// Sets the expected sequence number of the next inbound message.
    virtual void inSeqNum(SeqNumber msgSeqNum) = 0;

    /// \return the sequence number of the next outgoing message.
    virtual SeqNumber outSeqNum() const = 0;

    /// Sets the sequence number of the next outgoing message.
    virtual void outSeqNum(SeqNumber msgSeqNum) = 0;

    /// \return `true` if the session is negotiated (the Negotiation Response message has been received in reply to the Negotiation message);
    /// otherwise - `false`.
    virtual bool negotiated() const = 0;

    /// Sets the "negotiated" status.
    ///
    /// The session is negotiated when the Negotiation Response message has been received in reply to the Negotiation message.
    virtual void negotiated(bool negotiated) = 0;


===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/SessionException.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable OnixS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/BOE/Defines.h>
#include <OnixS/B3/BOE/SessionListener.h>
#include <OnixS/B3/BOE/messaging/Fields.h>

#include <string>

#if WIN32
#pragma warning(push)
#pragma warning(disable : 4275)
#pragma warning(disable : 4251)
#endif

namespace OnixS {
namespace B3 {
namespace BOE {
namespace Exceptions{

/**
 * A Session-related exception.
 */
class ONIXS_B3_BOE_EXPORTED SessionException : public std::exception
{
public:
    SessionException(SessionErrorReason::Enum reason, const std::string& message);

    SessionException(SessionErrorReason::Enum reason, const std::string& message, const std::exception& cause);

    ~SessionException() ONIXS_B3_BOE_NOTHROW ONIXS_B3_BOE_OVERRIDE ONIXS_B3_BOE_DEFAULT;

    const char* what() const ONIXS_B3_BOE_NOTHROW ONIXS_B3_BOE_OVERRIDE;

    SessionErrorReason::Enum reason() const ONIXS_B3_BOE_NOTHROW
    {
        return reason_;
    }

    const std::string& toString() const ONIXS_B3_BOE_NOTHROW
    {
        return message_;
    }

private:
    std::string message_;
    SessionErrorReason::Enum reason_;
};


class ONIXS_B3_BOE_EXPORTED SbeMessageAttachedExceptionBase
    : public SessionException
{
public:
    SbeMessageAttachedExceptionBase(SessionErrorReason::Enum reason, const std::string& message, Messaging::SbeMessage sbeMessage);

    Messaging::SbeMessage receivedMessage() const;

    ~SbeMessageAttachedExceptionBase() ONIXS_B3_BOE_NOTHROW ONIXS_B3_BOE_OVERRIDE = 0;

private:
    std::vector<unsigned char> buffer_;
};

template <typename MessageType>
class TypedSbeMessageAttachedExceptionBase : public SbeMessageAttachedExceptionBase
{
public:
    TypedSbeMessageAttachedExceptionBase(SessionErrorReason::Enum reason, const std::string& message, Messaging::SbeMessage sbeMessage)
        : SbeMessageAttachedExceptionBase(reason, message, sbeMessage)
    {}

    MessageType receivedMessage() const
    {
        return Messaging::typify<MessageType>(SbeMessageAttachedExceptionBase::receivedMessage());
    }
};

/**
 * An unexpected message type is received.
 */
class ONIXS_B3_BOE_EXPORTED UnexpectedMessageTypeException

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/threading/Mutex.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/BOE/ABI.h>

namespace OnixS {
namespace B3 {
namespace BOE {
namespace Threading {

/// Mutex.
///
/// Protects resources from simultaneous access by multiple threads.
///
/// Only one thread at a time can own instance of this class.
///
/// This implementation is optimized for locking threads that are in the same process.
///
/// \note It is NOT suitable for interprocess synchronization.
/// \note Recursive locking is NOT supported.
class ONIXS_B3_BOE_EXPORTED Mutex
{
public:
    friend ONIXS_B3_BOE_API_DECL(class, Condition);

    /// Initializes the instance.
    Mutex();

    /// Destructs the instance.
    ~Mutex();

    /// Acquires the lock ownership.
    ///
    /// If the mutex is already occupied by another thread
    /// blocks the current thread and waits until it
    /// will be released by the owner.
    void acquire();

    /// Tries to acquires the lock ownership.
    ///
    /// \return `false` if the mutex is already occupied by another thread,
    /// otherwise - `true`.
    bool tryAcquire();

    /// Releases the ownership (lock) and
    /// unblocks one of the waiting threads.
    void release();

private:
    void * impl_;

    // Copying & assignment is prohibited.
    Mutex(const Mutex &);
    Mutex & operator = (const Mutex &);
};
}
}
}
}

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/threading/Guard.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/BOE/threading/Mutex.h>
#include <OnixS/B3/BOE/threading/Semaphore.h>

namespace OnixS {
namespace B3 {
namespace BOE {
namespace Threading {

/// Performs automatic acquisition and release of a synchronization object.
template<class Acquirable> class Guard
{
public:
    /// Acquires the given synchronization object upon initialization.
    Guard(Acquirable & acquirable)
        : acquirable_(acquirable)
    {
        acquirable_.acquire();
    }

    /// Releases the synchronization object upon destruction.
    ~Guard() {
        acquirable_.release();
    }

private:
    Acquirable & acquirable_;

    Guard(const Guard &);
    Guard & operator = (const Guard &);
};

// Aliases for guards for known synchronization objects.

typedef Guard<Mutex> MutexGuard;
typedef Guard<Semaphore> SemaphoreGuard;
}
}
}
}

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/threading/Thread.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <set>

#include <OnixS/B3/BOE/ABI.h>
#include <OnixS/B3/BOE/threading/Definitions.h>

namespace OnixS {
namespace B3 {
namespace BOE {
namespace Threading {

/// Logical processors that a thread is allowed to run on (first logical CPU has index 0).
typedef size_t CpuIndex;
typedef std::set < CpuIndex > CpuIndexes;

/// Represents set of CPU indices.
class ONIXS_B3_BOE_EXPORTED ThreadAffinity
{
public:

    /// Constructs thread affinity from the string presentation.
    /// Symbol ',' is used as the CPU index delimiter.
    explicit ThreadAffinity(const std::string & str);

    /// Destructs the instance.
    ~ThreadAffinity();

    /// Read-only access to index collection.
    const CpuIndexes & cpuIndexes() const;

    /// Collection of CPU indices.
    CpuIndexes & cpuIndexes();

    /// Serializes thread affinity to the string presentation.
    std::string toString();

private:
    ThreadAffinity(const ThreadAffinity &);
    ThreadAffinity & operator = (const ThreadAffinity &);

    CpuIndexes * indexes_;
};

/// Current thread related tasks.
class ONIXS_B3_BOE_EXPORTED ThisThread
{
public:
    /// Suspends the execution of the current thread for
    /// the given amount of time.
    static void sleep(unsigned int milliseconds);

    /// Executes a single instruction during the given number of microseconds.
    static void spinWait(unsigned int microseconds);

    /// Sets the processor affinity mask for the current thread.
    static void affinity(const CpuIndexes & cpuIndexes);

    /// Sets the processor affinity mask for the current thread.
    static void affinity(CpuIndex cpuIndex);

    /// Sets the priority for the current thread.
    static void priority(int priority);

    /// Sets the scheduling policy for the current thread.
    ///
    /// \note This method also sets the priority to the minimal value for the new policy,
    /// therefore, the priority should be set to a necessary value afterwards.
    static void policy(int policy);

    /// \return the platform identifier for the current thread.
    static ThreadId id();

    /// \return the processor number the current thread is running on during the call to this method.
    static unsigned int processorNumber();

private:
    ThisThread(const ThisThread &);
    ThisThread & operator = (const ThisThread &);
};


===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/threading/Semaphore.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/BOE/ABI.h>

namespace OnixS {
namespace B3 {
namespace BOE {
namespace Threading {

/// Semaphore.
///
/// Limits number of threads that can access the shared resource simultaneously.
class ONIXS_B3_BOE_EXPORTED Semaphore
{
public:
    /// Constructor.
    ///
    /// The state of the semaphore is signaled
    /// when its counter is greater than zero and
    /// non-signaled when it is zero.
    ///
    /// \param count the counter value.
    Semaphore(unsigned int count = 1);

    ~Semaphore();

    /// Decrements the counter by one.
    ///
    /// If the counter is already zero,
    /// blocks the thread until the counter
    /// becomes greater than zero.
    void acquire();

    /// Tries to decrement the counter by one.
    ///
    /// \return `false' if the counter is already zero,
    /// otherwise - `true`.
    bool tryAcquire();

    /// Increments the counter by one.
    void release();

private:
    void * impl_;

    // Copying & assignment is prohibited.
    Semaphore(const Semaphore &);
    Semaphore & operator = (const Semaphore &);
};
}
}
}
}

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/threading/Future.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/BOE/ABI.h>

#if defined (ONIXS_B3_BOE_CXX11)
#  include <exception>
#endif

namespace OnixS {

namespace System {
class FutureSharedState;
}

namespace B3 {
namespace BOE {
namespace Threading {

/// State of a \c SharedFuture object (similar to std::future_status, @see http://en.cppreference.com/w/cpp/thread/future_status ).
struct FutureStatus
{
    enum Enum
    {
        /// the shared state is ready.
        ready,
        /// the shared state did not become ready before specified timeout duration has passed.
        timeout,
        /// the shared state contains a deferred function, so the result will be computed only when explicitly requested.
        deferred
    };
};

namespace Implementation {

class FutureHelper;

/// Base implementation of SharedFuture<T>.
class FutureBase
{
public:
    /// Check if a future instance is associated with an asynchronous result.
    ///
    /// Returns \c true if the *this has an associated asynchronous result, false otherwise.
    bool valid() const ONIXS_B3_BOE_NOTHROW {
        return state_ != ONIXS_B3_BOE_NULLPTR;
    }

    /// Returns \c true if the asynchronous result associated with this Future is ready
    /// (has a value or exception stored in the shared state), \c false otherwise.
    ///
    /// There are often situations where a \c get() call on a Future may not be a blocking call,
    /// or is only a blocking call under certain circumstances.
    /// This method gives the ability to test for early completion and allows us to avoid
    /// associating a continuation, which needs to be scheduled with some non-trivial overhead
    /// and near-certain loss of cache efficiency.
    ///
    /// @throw std::logic_error if this instance does not refer to a shared state.
    ONIXS_B3_BOE_EXPORTED bool is_ready() const;

    /// Returns \c true if the asynchronous result associated with this Future has a stored value,
    ///         \c false otherwise.
    ///
    /// @throw std::logic_error if this instance does not refer to a shared state.
    ONIXS_B3_BOE_EXPORTED bool has_value() const;

    /// Returns \c true if the asynchronous result associated with this Future has a stored exception,
    ///         \c false otherwise.
    ///
    /// @throw std::logic_error if this instance does not refer to a shared state.
    ONIXS_B3_BOE_EXPORTED bool has_exception() const;

#if defined (ONIXS_B3_BOE_CXX11)

    /// Returns the stored exception.
    ///
    /// @throw std::logic_error if this instance does not refer to a shared state.
    /// @throw std::logic_error if the operation has *not* finished with an error.
    ONIXS_B3_BOE_EXPORTED std::exception_ptr get_exception_ptr() const;

#endif


===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/threading/Definitions.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable OnixS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/BOE/ABI.h>
#include <OnixS/B3/BOE/Defines.h>

namespace OnixS {
namespace B3 {
namespace BOE {
namespace Threading {
#if defined (_WIN32)
/// Type alias for the thread identifier.
typedef DWORD ThreadId;
#else
/// Type alias for thread identifier.
typedef pthread_t ThreadId;
#endif

}
}
}
}

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/threading/Condition.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/BOE/threading/Mutex.h>

namespace OnixS {
namespace B3 {
namespace BOE {
namespace Threading {

/// Condition variable - a synchronization objects that
/// allows threads to wait for certain events (conditions)
/// to occur.
///
/// Condition variable enables threads to atomically block
/// and test condition under protection of mutual exclusion
/// lock (Mutex) until condition is satisfied.
class ONIXS_B3_BOE_EXPORTED Condition
{
public:
    /// Initializes the instance.
    Condition();

    /// Destructs the instance.
    ~Condition();

    /// Signals one waiting thread.
    void signal();

    /// Signals all waiting threads.
    void signalAll();

    /// Blocks on a condition.
    ///
    /// \param lock Represents a reference to Mutex
    /// that is used to protect the condition testing.
    void wait(Mutex & lock);

private:
    void * impl_;

    // Copying & assignment is prohibited.
    Condition(const Condition &);
    Condition & operator = (const Condition &);
};
}
}
}
}

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/scheduling/SessionSchedule.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/BOE/ABI.h>

#include <string>
#include <vector>

namespace OnixS {
namespace B3 {
namespace BOE {
namespace Scheduling {

/// The day of the week.
struct ONIXS_B3_BOE_EXPORTED DayOfWeek
{
    enum Enum
    {
        Sunday,
        Monday,
        Tuesday,
        Wednesday,
        Thursday,
        Friday,
        Saturday,
        Total
    };

    /// Transforms the string presentation into a valid constant.
    static Enum parse(const std::string & value);

    /// \return the string presentation for a given constant.
    static std::string toString(Enum value);

    /// \return the current day of the week.
    static Enum now();

    /// \return the current UTC day of the week.
    static Enum utcNow();
};

/// The number of hours.
typedef int Hours;

/// The number of minutes.
typedef int Minutes;

/// The number of seconds.
typedef int Seconds;

/// Time of day.
class ONIXS_B3_BOE_EXPORTED TimeOfDay
{
public:
    TimeOfDay() ONIXS_B3_BOE_NOTHROW;

    TimeOfDay(Hours hours, Minutes minutes, Seconds = 0) ONIXS_B3_BOE_NOTHROW;

    /// \return hours.
    Hours hours() const ONIXS_B3_BOE_NOTHROW;

    /// \return minutes.
    Minutes minutes() const ONIXS_B3_BOE_NOTHROW;

    /// \return seconds.
    Seconds seconds() const ONIXS_B3_BOE_NOTHROW;

    /// \return the total number of seconds since the midnight.
    Seconds sinceMidnight() const ONIXS_B3_BOE_NOTHROW;

    /// \return the string presentation.
    std::string toString() const;

    /// Checks whether the instance is equal to the given one.
    bool operator == (const TimeOfDay & other) const ONIXS_B3_BOE_NOTHROW;

    /// Checks whether the instance is unequal to the given one.
    bool operator != (const TimeOfDay & other) const ONIXS_B3_BOE_NOTHROW;

    /// \return the current time of day.
    static TimeOfDay now();


===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/scheduling/SessionScheduler.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/BOE/ABI.h>
#include <OnixS/B3/BOE/Session.h>
#include <OnixS/B3/BOE/scheduling/SessionConnectionSettings.h>
#include <OnixS/B3/BOE/scheduling/SessionSchedule.h>
#include <OnixS/B3/BOE/threading/Thread.h>

#include <set>
#include <string>

namespace OnixS {
namespace B3 {
namespace BOE {
namespace Scheduling {

class SessionScheduler;

typedef std::string SessionScheduleId;
typedef std::string SessionConnectionSettingsId;

/// SessionScheduler events notifications.
class ONIXS_B3_BOE_EXPORTED SessionSchedulerListener
{
public:
    /// Notifies that the session is about to be closed.
    ///
    /// \param scheduler the instance the of session
    /// scheduler that is about to close the session.
    ///
    /// \param session the session that is about to be closed.
    ///
    /// \param allowLogout indicates whether the scheduler must perform the logout.
    /// To prohibit the logout set this parameter to `false`.
    virtual void onLoggingOut(const SessionScheduler & scheduler, Session * session, bool * allowLogout) = 0;

    /// Notifies about a non-critical issue.
    virtual void onWarning(const SessionScheduler & scheduler, Session * session, const std::string & warningReason) = 0;

    /// Notifies about an error.
    virtual void onError(const SessionScheduler & scheduler, Session * session,  const std::string & errorReason) = 0;

protected:
    virtual ~SessionSchedulerListener() ONIXS_B3_BOE_DEFAULT;
};

/// Scheduler options.
class ONIXS_B3_BOE_EXPORTED SessionSchedulerOptions
{
public:
    SessionSchedulerOptions();

    ~SessionSchedulerOptions();

    /// \return the path to the scheduler configuration file.
    const std::string & configurationFile() const ONIXS_B3_BOE_NOTHROW;

    /// Sets the path to the scheduler configuration file.
    SessionSchedulerOptions &configurationFile(const std::string &file);

    /// \return the event listener.
    SessionSchedulerListener * eventListener() const ONIXS_B3_BOE_NOTHROW;

    /// Sets the event listener.
    SessionSchedulerOptions &eventListener(SessionSchedulerListener *listener) ONIXS_B3_BOE_NOTHROW;

private:
    std::string * configurationFile_;
    SessionSchedulerListener * eventListener_;
};

/// Session Scheduler.
class ONIXS_B3_BOE_EXPORTED SessionScheduler
{
public:
    SessionScheduler(const SessionSchedulerOptions & options);

    /// Performs the graceful shutdown of scheduling sessions.
    ~SessionScheduler();

    /// Looks for the predefined session schedule associated with the given id

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/scheduling/SessionConnectionSettings.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/BOE/ABI.h>

#include <string>
#include <vector>

namespace OnixS {
namespace B3 {
namespace BOE {
namespace Scheduling {

/// Counterparty host name.
typedef std::string Host;

/// Counterparty port.
typedef unsigned short Port;

/// Parameters required to establish
/// the connection with the counterparty.
class ONIXS_B3_BOE_EXPORTED Counterparty
{
public:
    /// Initializes a blank instance.
    Counterparty();

    /// Fully identified counterparty.
    Counterparty(const Host& host, Port port);

    /// Initializes as clone of the given instance.
    Counterparty(const Counterparty& other);

    ~Counterparty();

    /// \return remote host.
    const Host& host() const ONIXS_B3_BOE_NOTHROW;

    /// \return port number.
    Port port() const ONIXS_B3_BOE_NOTHROW;

    Counterparty& operator=(const Counterparty& other);

private:
    Host* host_;
    Port port_;
};

/// Ordered series of counterparties.
typedef std::vector<Counterparty> Counterparties;

/// Connection-related settings.
class ONIXS_B3_BOE_EXPORTED SessionConnectionSettings
{
public:
    /// Constructor.
    ///
    /// \param host the remote host to which session must connect to.
    /// \param port the port number to which session must connect to.
    SessionConnectionSettings(const Host& host, Port port);

    SessionConnectionSettings(const SessionConnectionSettings& other);

    virtual ~SessionConnectionSettings();

    /// Adds the counterparty.
    SessionConnectionSettings& addCounterparty(const Host& host, Port port);

    /// \return Counterparties.
    const Counterparties& counterparties() const ONIXS_B3_BOE_NOTHROW;

    SessionConnectionSettings& operator=(const SessionConnectionSettings& other);

protected:
    SessionConnectionSettings();

private:
    Counterparties* counterparties_;
};


inline const Counterparties& SessionConnectionSettings::counterparties() const ONIXS_B3_BOE_NOTHROW

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/encoding/Base64Encoding.h =====
#pragma once
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#include <OnixS/B3/BOE/ABI.h>
#include <OnixS/B3/BOE/messaging/StrRef.h>

#include <string>
#include <vector>

namespace OnixS {
namespace B3 {
namespace BOE {
namespace Encoding {

/// Byte sequence.
typedef std::vector<unsigned char> ByteArray;

/// BASE64 encoding service.
class ONIXS_B3_BOE_EXPORTED Base64Encoding
{
public:
    /// Reconstructs the binary data from a BASE64-encoded string.
    ///
    /// @throw Exception if the string is corrupted or not BASE64-encoded.
    static void decode(ByteArray & decoded, const std::string & encoded);

    /// Reconstructs the binary data from a BASE64-encoded string.
    ///
    /// @throw Exception if the string is corrupted or not BASE64-encoded.
    static void decode(ByteArray & decoded, Messaging::StrRef encoded);
};
}
}
}
}

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/CompilerDetection.h =====
#pragma once

#define ONIXS_B3_BOE_COMPILER_IS_GNU
#define ONIXS_B3_BOE_CXX11
#define ONIXS_B3_BOE_CXX14
#define ONIXS_B3_BOE_CXX17

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/AdHoc.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable OnixS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/BOE/Session.h>

namespace OnixS {
namespace B3 {
namespace BOE {
namespace AdHoc {

#if !(defined(ONIXS_B3_BOE_DOXYGEN) && ONIXS_B3_BOE_DOXYGEN)

/**
* Session helper.
*/
struct SessionHelper
{
    /**
    * Sends the Retransmit Request message.
    *
    * \note The handler sends Retransmit Request messages automatically per the B3 BOE protocol.
    * This method should be used on an ad hoc basis only.
    */
    static void sendRetransmitRequest(Session& sn, UInt64 sessionVerId, SeqNumber from, SeqNumber to)
    {
         sn.sendRetransmitRequest(sessionVerId, from, to);
    }
};

#endif

}}}}

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/SessionListener.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/BOE/ABI.h>
#include <OnixS/B3/BOE/Messaging.h>
#include <OnixS/B3/BOE/SessionStateId.h>

#include <string>

namespace OnixS {
namespace B3 {
namespace BOE {

ONIXS_B3_BOE_API_DECL(class, Session);

/**
 * Session Warning Reason.
 */
struct SessionWarningReason
{
    enum Enum
    {
        /// General session-related warning.
        GeneralWarning,

        /// Incoming message sequence gap is detected.
        SequenceGapIsDetected,

        /// Unexpected SBE Schema version is received from B3.
        UnexpectedSbeSchemaVersion,

        /// Received an unexpected `NextSeqNo` value.
        UnexpectedNextSeqNo,

        /// Received an unsupported message type.
        UnsupportedMessageType,

        /// The incoming message has a sequence number is out of the expected  range and the <i>PossRetransFlag</i> is
        /// set, it indicates a warning. It is strongly recommended that the session be terminated and manual intervention
        /// be initiated.
        MsgSeqNumOutOfRange,

        /// Received a message with an unexpected sessionId
        UnexpectedSessionId,

        /// Raised when the `KeepAliveInterval` has expired and no keep alive message is received.
        ReceiveTimeoutIsDetected,

        /// Exception was thrown from user's event handler.
        ExceptionInEventHandler,

        /// An exception is thrown from the user-provided Session Storage
        PluggableSessionStorageException,

        /// Session state cannot be restored.
        RestoreSessionStateWarning,

        /// Raised when the AsyncFileBasedStorage queue exceeded `SessionSettings::asyncFileBasedStorageQueueMaxSize`
        AsyncFileBasedStorageQueueOverflow,

        /// Raised when the license will expire in less than `SessionSettings::licenseAlertingDaysBeforeExpiration`
        LicenseExpiration,

        /// The <i>Retransmit Reject</i> message is received in reply to the <i>Retransmit Request</i> message.
        RetransmitReject,

        /// Telecommunication link error is detected.
        LinkErrorIsDetected,

        /// After sending the initial Negotiate or Establish message the telecommunication link error is detected.
        LinkErrorIsDetectedDuringSessionEstablishment,

        /// Error setting socket option
        CannotSetSocketOption,

        /// Cannot backup the file.
        CannotBackup,

        /// Session state cannot be restored.
        CannotRestoreSessionState,
    };


===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/testing/MessagePtr.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/testing/ABI.h>

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)

#include <OnixS/B3/BOE/Messaging.h>

#include <memory>

namespace OnixS {
namespace B3 {
namespace BOE {
namespace Testing {

using namespace Messaging;

ONIXS_B3_BOE_EXPORTED
ONIXS_B3_BOE_NORETURN
void throwWrongType(UInt16, UInt16);

/// \return `true` if the instance refers to a valid message, otherwise - `false`.
inline
bool isMessageValid(const SbeMessage& msg) noexcept
{
    return msg.valid();
}

/// Message container.
template<typename Message>
class MessagePtr
{
public:
    using Container = std::shared_ptr<UInt8>;

    /// Creates from the given memory block.
    MessagePtr(Container&&, MessageSize);

    /// Create from another type.
    template <class AnotherType>
    explicit
    MessagePtr(const MessagePtr<AnotherType>& rhs)
        : size_(rhs.size_)
        , container_(rhs.container_)
        , message_()
    {
        fromAnotherType(rhs);
    }

    /// Creates from the given type.
    template <class AnotherType>
    explicit
    MessagePtr(MessagePtr<AnotherType>&& rhs)
        : size_(rhs.size_)
        , container_(std::move(rhs.container_))
        , message_()
    {
        fromAnotherType(rhs);
    }

    /// Creates an empty message container.
    MessagePtr()
        : size_(0)
        , container_()
        , message_()
    {
    }

    MessagePtr(const MessagePtr&) = default;
    MessagePtr& operator=(const MessagePtr&) = default;

    ///
    MessagePtr(MessagePtr&& rhs) noexcept
    {
        rhs.swap(*this);
        rhs.reset();
    }

    ///
    MessagePtr& operator=(MessagePtr&& rhs) noexcept

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/testing/ClientMessageListener.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/BOE/testing/ABI.h>

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)

#include <OnixS/B3/BOE/messaging/Forwards.h>

namespace OnixS {
namespace B3 {
namespace BOE {
namespace Testing {

ONIXS_B3_BOE_API_DECL(class, Gateway);

/// Client's messages Listener.
class ONIXS_B3_BOE_EXPORTED ClientMessageListener
{
protected:

    virtual ~ClientMessageListener() = 0;

public:
    virtual void onSimpleNewOrder(const Messaging::SimpleNewOrder100& /*msg*/, Gateway* /*gateway*/) {}
    virtual void onSimpleModifyOrder(const Messaging::SimpleModifyOrder101& /*msg*/, Gateway* /*gateway*/) {}
    virtual void onNewOrderSingle(const Messaging::NewOrderSingle102& /*msg*/, Gateway* /*gateway*/) {}
    virtual void onOrderCancelReplaceRequest(const Messaging::OrderCancelReplaceRequest104& /*msg*/, Gateway* /*gateway*/) {}
    virtual void onOrderCancelRequest(const Messaging::OrderCancelRequest105& /*msg*/, Gateway* /*gateway*/) {}
    virtual void onNewOrderCross(const Messaging::NewOrderCross106& /*msg*/, Gateway* /*gateway*/) {}
    virtual void onSecurityDefinitionRequest(const Messaging::SecurityDefinitionRequest300& /*msg*/, Gateway* /*gateway*/) {}
    virtual void onQuoteRequest(const Messaging::QuoteRequest401& /*msg*/, Gateway* /*gateway*/) {}
    virtual void onQuoteStatusReport(const Messaging::QuoteStatusReport402& /*msg*/, Gateway* /*gateway*/) {}
    virtual void onQuote(const Messaging::Quote403& /*msg*/, Gateway* /*gateway*/) {}
    virtual void onQuoteCancel(const Messaging::QuoteCancel404& /*msg*/, Gateway* /*gateway*/) {}
    virtual void onQuoteRequestReject(const Messaging::QuoteRequestReject405& /*msg*/, Gateway* /*gateway*/) {}
    virtual void onPositionMaintenanceCancelRequest(const Messaging::PositionMaintenanceCancelRequest501& /*msg*/, Gateway* /*gateway*/) {}
    virtual void onPositionMaintenanceRequest(const Messaging::PositionMaintenanceRequest502& /*msg*/, Gateway* /*gateway*/) {}
    virtual void onAllocationInstruction(const Messaging::AllocationInstruction601& /*msg*/, Gateway* /*gateway*/) {}
    virtual void onOrderMassActionRequest(const Messaging::OrderMassActionRequest701& /*msg*/, Gateway* /*gateway*/) {}
};

/// Client's session messages Listener.
class ONIXS_B3_BOE_EXPORTED ClientSessionMessageListener
{
protected:
    virtual ~ClientSessionMessageListener() = 0;

public:
    /// By default, send Sequence9 message with gateway->outSeqNum(), KeepAliveLapsed::NotLapsed
    virtual void onRetransmitRequest(const Messaging::RetransmitRequest12 & /*msg*/, Gateway* /*gateway*/);

    /// By default, send Sequence9 message with gateway->outSeqNum(), KeepAliveLapsed::NotLapsed
    virtual void onSequence(const Messaging::Sequence9 & /*msg*/, Gateway * /*gateway*/);
};

}
}
}
}

#endif

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/testing/ABI.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.

#pragma once

#include <OnixS/B3/BOE/ABI.h>

#if defined (ONIXS_B3_BOE_CXX11)
#   define ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR
#endif

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/testing/Gateway.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.

#pragma once

#include <OnixS/B3/BOE/testing/ABI.h>
#include <OnixS/B3/BOE/SessionSettings.h>

#if defined(ONIXS_B3_BOE_HAS_GATEWAY_EMULATOR)

#include <OnixS/B3/BOE/Messaging.h>
#include <OnixS/B3/BOE/testing/MessagePtr.h>
#include <OnixS/B3/BOE/testing/ClientMessageListener.h>

#include <chrono>
#include <atomic>

namespace OnixS {
namespace B3 {
namespace BOE {
namespace Testing {

// Assume NegotiateResponse2::credentials is empty
constexpr
UInt16 calculateNegotiateResponse2MaxSize()
{
    using Message = NegotiateResponse2;

    return
        Message::blockLength(Message::Schema::Version)
        + MessageHeader::Size
        + Message::getMinimalVariableFieldsSize(Message::Schema::Version);
}

//  Type aliases
using NegotiateResponse2Container = MessageHolder<NegotiateResponse2, calculateNegotiateResponse2MaxSize()>;
using NegotiateReject3Container = MessageHolder<NegotiateReject3>;
using EstablishAck5Container = MessageHolder<EstablishAck5>;
using EstablishReject6Container = MessageHolder<EstablishReject6>;
using Terminate7Container = MessageHolder<Terminate7>;
using Sequence9Container = MessageHolder<Sequence9>;

using MessageBasePtr = MessagePtr<SbeMessage>;
using Negotiate1Ptr = MessagePtr<Negotiate1>;
using Establish4Ptr = MessagePtr<Establish4>;
using Terminate7Ptr = MessagePtr<Terminate7>;
using Sequence9Ptr = MessagePtr<Sequence9>;

/// B3 BOE Gateway Emulator.
class ONIXS_B3_BOE_EXPORTED Gateway
{
public:
    /// Timeout alias.
    using Timeout = std::chrono::milliseconds;

    Gateway(const SessionSettings::LicenseStores& licenseStores, int port, const char* host = "127.0.0.1",
            const Timeout& acceptTimeout = defaultTimeout(),
            const Timeout& sendReceiveTimeout = defaultTimeout());

    ///
    virtual ~Gateway();

    /// Deleted.
    Gateway(const Gateway&) = delete;
    Gateway& operator=(const Gateway&) = delete;

    /// Move semantic.
    Gateway(Gateway&&) noexcept;
    Gateway& operator=(Gateway&&) noexcept;

    /// Swap with other.
    void swap(Gateway&) noexcept;

    /// Accepts an incoming connection.
    /// If the `acceptTimeout` is zero, the `acceptTimeout` provided in the constructor is used.
    Gateway& acceptConnection(const Timeout& acceptTimeout = defaultTimeout());

    /// Accepts an incoming connection.
    /// If the operation is timed out, `false` is returned.
    bool tryAcceptConnection(const Timeout& acceptTimeout = defaultTimeout());

    /// Accepts an incoming FIXP session.
    Gateway& acceptSession(SeqNumber outgoingSequenceNumber = 1);


===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/Defines.h =====
#pragma once

/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#include <OnixS/B3/BOE/CompilerDetection.h>
#include <OnixS/B3/BOE/Compiler.h>

#include <vector>
#include <string>
#include <set>
#include <memory>

#if defined(_WIN32) // Windows platform.

#if !defined(STRICT)
#define STRICT
#endif

#include <winsock2.h>

#endif

namespace OnixS {
namespace B3 {
namespace BOE {

typedef unsigned short Port;
/// Type alias for byte.
typedef unsigned char Byte;

/// Sequence of bytes.
typedef std::vector<Byte> Bytes;

#if defined (_WIN32)
/// Type alias for socket handle.
typedef SOCKET Handle;
#else
/// Type alias for socket handle.
typedef int Handle;
#endif

/// Socket option of the SOL_SOCKET level
struct SocketOption {
    SocketOption() ONIXS_B3_BOE_NOTHROW
        : optname(0), optval(ONIXS_B3_BOE_NULLPTR), optlen(0) {}

    SocketOption(int optionName, const void* optionValue, int optionLength) ONIXS_B3_BOE_NOTHROW
        : optname(optionName), optval(optionValue), optlen(optionLength) {}

    int optname;
    const void * optval;
    int optlen;
};

typedef size_t CpuIndex;
typedef std::set<CpuIndex> CpuIndexes;
typedef std::pair<Port, Port> PortRange;

/// Socket options.
typedef std::vector<SocketOption> SocketOptions;

struct ThreadParams {
    std::string name;
    CpuIndexes affinity;
    int priority;
    int policy;

    ThreadParams()
        : priority(0)
      , policy(0)
    {
    }
};

struct PriorityAndPolicyTraits {
    enum Enum {
        UndefinedPriorityAndPolicy = 255
    };
};

template <typename T>
struct PtrTraits
{

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/NetworkMessage.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/messaging/SimpleOpenFramingHeader.h>
#include <OnixS/B3/BOE/messaging/ExceptionHelpers.h>
#include <OnixS/B3/BOE/messaging/SbeMessage.h>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

/// A network BOE message.
ONIXS_B3_BOE_LTWT_CLASS NetworkMessage
{
public:
    /// Constructs an empty instance.
    NetworkMessage() ONIXS_B3_BOE_NOTHROW
        : data_(ONIXS_B3_BOE_NULLPTR)
        , size_(0)
    {}

    /// Constructs NetworkMessage from a data block. Performs no checks.
    NetworkMessage(const void* data, ONIXS_B3_BOE_UNUSED size_t size, SbeMessage::NoCheck) ONIXS_B3_BOE_NOTHROW
        : data_(ONIXS_B3_BOE_NULLPTR)
        , size_(0)
    {
        assert(size >= sizeof(SimpleOpenFramingHeader));

        const SimpleOpenFramingHeader* const header = reinterpret_cast<const SimpleOpenFramingHeader*>(data);

        assert(header->encoding() == B3BOESbeEncodingType);
        assert(header->size() <= size);

#ifndef NDEBUG
        SbeMessage(toByteBlock(toMutable(data)) + sizeof(SimpleOpenFramingHeader), header->size() - sizeof(SimpleOpenFramingHeader));
#endif

        data_ = data;
        size_ = header->size();
    }

    /// Constructs NetworkMessage from a data block.
    NetworkMessage(const void* data, size_t size)
        : data_(ONIXS_B3_BOE_NULLPTR)
        , size_(0)
    {
         if ONIXS_B3_BOE_UNLIKELY(size < sizeof(SimpleOpenFramingHeader))
             throwBinaryBlockIsTooSmall(static_cast<MessageSize>(size), sizeof(SimpleOpenFramingHeader), "SimpleOpenFramingHeader");

        const SimpleOpenFramingHeader* const header = reinterpret_cast<const SimpleOpenFramingHeader*>(data);

        if ONIXS_B3_BOE_UNLIKELY(header->encoding() != B3BOESbeEncodingType)
            throwIncorrectEncoding(header->encoding(), data, static_cast<MessageSize>(size));

        if ONIXS_B3_BOE_UNLIKELY(header->size() > size)
            throwNetPacketIsTooSmall(static_cast<MessageSize>(size), header->size());

        SbeMessage(toByteBlock(toMutable(data)) + sizeof(SimpleOpenFramingHeader), header->size() - sizeof(SimpleOpenFramingHeader));

        data_ = data;
        size_ = header->size();
    }

    ///
    const void* data() const ONIXS_B3_BOE_NOTHROW
    {
        return data_;
    }

    ///
    MessageSize size() const ONIXS_B3_BOE_NOTHROW
    {
        return size_;
    }

    /// Blank the instance.
    void clear() ONIXS_B3_BOE_NOTHROW
    {
        *this = NetworkMessage();
        assert(!valid());
    }

    /// \return `true` if the instance refers to a valid packet, otherwise - `false`.

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/StrRef.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/ABI.h>
#include <OnixS/B3/BOE/messaging/Aliases.h>
#include <OnixS/B3/BOE/messaging/String.h>
#include <OnixS/B3/BOE/messaging/Utils.h>

#include <algorithm>
#include <cassert>
#include <cstddef>
#include <cstring>
#include <limits>
#include <ostream>
#include <stdexcept>
#include <string>

#if defined (ONIXS_B3_BOE_CXX17)
#  include <string_view>
#endif


ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

#if defined (ONIXS_B3_BOE_CXX17)

using StrRef = std::basic_string_view<Char>;

#else

/// \private
/// Throws exception on invalid index
ONIXS_B3_BOE_EXPORTED
ONIXS_B3_BOE_COLDPATH
ONIXS_B3_BOE_NORETURN
void throwInvalidIndex(size_t, size_t);

/// String reference.
///
/// Provides the efficient way of accessing
/// text-based values without copying
/// content of the text being referred.
ONIXS_B3_BOE_LTWT_CLASS StrRef
{
public:
    typedef size_t size_type;

    /// STL-like iterators.
    typedef const Char* const_iterator;
    typedef const_iterator iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef const_reverse_iterator reverse_iterator;

    /// Initializes the instance referring to nothing.
    ONIXS_B3_BOE_CONSTEXPR
    StrRef()
        : items_(ONIXS_B3_BOE_NULLPTR)
        , size_(0)
    {
    }

    /// Explicit initialization.
    ONIXS_B3_BOE_CONSTEXPR
    StrRef(const Char* chars, size_t size) ONIXS_B3_BOE_NOTHROW
        : items_(chars)
        , size_((ONIXS_B3_BOE_ASSERT(size <= (std::numeric_limits<size_type>::max)()), static_cast<size_type>(size)))
    {
    }

    /// Explicit initialization.
    StrRef(const Char* chars) ONIXS_B3_BOE_NOTHROW
        : items_(chars)
        , size_(0)
    {
        assert(chars);

        ONIXS_B3_BOE_CONST_OR_CONSTEXPR size_type maxLen = (std::numeric_limits<UInt16>::max)();

        size_ = numericCast<size_type>(strnlen(chars, maxLen));

        assert(size_ < maxLen);

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/SchemaTraits.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/messaging/Composites.h>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

/// SBE-encoded data version type.
typedef
MessageHeader::Version
SchemaVersion;

typedef
MessageHeader::SchemaId
SchemaId;

/// Attributes of SBE message schema.
ONIXS_B3_BOE_LTWT_STRUCT
SchemaTraits
{
    /// Identifier of the messages schema.
    enum { Id = 1 };

    /// Version of the messages schema.
    enum { Version = 5 };

    /// The minimal SBE Schema version supported by the SDK.
    /// Messages of lower versions will not be processed
    /// as they may miss fields required for the correct data
    /// handling.
    enum { MinimalVersion = 3 };
};

#define ONIXS_B3_BOE_SCHEMA_DESCRIPTION  "B3 Binary Entrypoint FIXP messages"

#define ONIXS_B3_BOE_SCHEMA_SEMANTIC_VERSION  "8.3.2"


ONIXS_B3_BOE_MESSAGING_NAMESPACE_END

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/MessageBatch.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <vector>

#include <OnixS/B3/BOE/messaging/MessageHolder.h>
#include <OnixS/B3/BOE/messaging/SbeMessage.h>
#include <OnixS/B3/BOE/messaging/NetworkMessage.h>

namespace OnixS
{
    namespace B3
    {
        namespace BOE
        {
            ONIXS_B3_BOE_EXPORTED_CLASS Session;
        }
    }
}

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

typedef std::vector<NetworkMessage> NetMessages;
class MessageBatchChecker;

#if defined (ONIXS_B3_BOE_CXX11)

/**
* The message batch wrapper.
*/
template <typename MessageTypeT,
size_t MaxMessageSize = GetMaxMessageSize<typename HeldAdapter<MessageTypeT>::SbeType, DefaultMaxGroupItems>::Size,
typename MessageInitializer = FieldsInitPolicy>
class MessageBatch
{
public:

    using MsgHolder = MessageHolder<MessageTypeT, MaxMessageSize, MessageInitializer>;
    using MsgHolders = std::vector<MsgHolder>;

    using iterator = typename MsgHolders::iterator;
    using const_iterator = typename MsgHolders::const_iterator;

    /**
    * Creates an empty message batch.
    * The `add` method should be used to add a message to the batch.
    */
    MessageBatch() = default;

    /**
    * Creates a message batch with the given number of default constructed messages.
    * A message in the batch can be updated via `operator[]` method.
    */
    explicit MessageBatch(size_t size) : batch_(size)
    {
        updateHeaders();
    }

    /**
    * Creates a message batch from the initializer list.
    * A message in the batch can be updated via `operator[]` method.
    */
    MessageBatch(std::initializer_list<MsgHolder> list) : batch_(list)
    {
        updateHeaders();
    }

    MessageBatch(const MessageBatch &) = delete;
    MessageBatch & operator=(const MessageBatch &) = delete;

    /**
    * Appends a message to the end of the batch.
    */
    void add(const MsgHolder & msg)
    {
        batch_.push_back(msg);
    }

    /**
    * Updates headers of SBE messages to be ready for sending.
    *

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/Fields.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/messaging/StrRef.h>
#include <OnixS/B3/BOE/messaging/Integral.h>
#include <OnixS/B3/BOE/messaging/Time.h>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

/// Null value for an optional Char field.
typedef
IntegralConstant<Char, '\x0'>
NullChar;


/// Null value for an optional UInt8 field.
typedef
IntegralConstant<UInt8, 255>
NullUInt8;


/// Null value for an optional UInt16 field.
typedef
IntegralConstant<UInt16, 65535>
NullUInt16;


/// Null value for an optional UInt32 field.
typedef
IntegralConstant<UInt32, 4294967295>
NullUInt32;


/// Null value for an optional UInt64 field.
typedef
IntegralConstant<UInt64, 18446744073709551615ULL>
NullUInt64;

/// Null value for an optional Int8 field.
typedef
IntegralConstant<Int8, -128>
NullInt8;


/// Null value for an optional Int16 field.
typedef
IntegralConstant<Int16, -32768>
NullInt16;


/// Null value for an optional Int32 field.
typedef
IntegralConstant<Int32, -2147483647-1>
NullInt32;


/// Null value for an optional Int64 field.
typedef
IntegralConstant<Int64, -9223372036854775807LL-1>
NullInt64;


/// Unique identifier for this allocation instruction message.
///
/// FIX type: Int.
typedef UInt64 AllocID;


/// Unique identifier of the order as assigned by the market participant.
///
/// FIX type: Int.
typedef UInt64 ClOrdID;


/// Optional unique identifier of the order as assigned by the market participant.
///
/// FIX type: Int.
typedef UInt64 ClOrdIDOptional;


/// Client connection identification on the gateway assigned by B3.

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/MessageSerialization.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <string>

#include <OnixS/B3/BOE/messaging/Messages.h>


ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

// Market Data Serialization.

/// Serializes into a string.
ONIXS_B3_BOE_EXPORTED
void
toStr(
    std::string& str,
    const Negotiate1& obj);


/// Serializes into a string.
inline std::string toStr(const Negotiate1& obj)
{
    std::string str;

    toStr(str, obj);

    return str;
}

/// Serializes into a stream.
inline
std::ostream&
operator<<(
    std::ostream& stream,
    const Negotiate1& obj)
{
    std::string str;

    toStr(str, obj);

    return stream << str;
}

inline std::string Negotiate1::toString() const
{
    return toStr(*this);
}
/// Serializes the object into FIX presentation.
ONIXS_B3_BOE_EXPORTED
void
toFix(
    std::string& str,
    const Negotiate1& obj);


/// Serializes into a string.
ONIXS_B3_BOE_EXPORTED
void
toStr(
    std::string& str,
    const NegotiateResponse2& obj);


/// Serializes into a string.
inline
std::string
toStr(
    const NegotiateResponse2& obj)
{
    std::string str;

    toStr(str, obj);

    return str;
}

/// Serializes into a stream.
inline
std::ostream&
operator<<(

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/Typification.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/messaging/Messages.h>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

/// Casts SBE-encoded message to a given type.
template
    <
        class Message
    >
inline
ONIXS_B3_BOE_NODISCARD
ONIXS_B3_BOE_PURE
Message
typify(
    const SbeMessage& message)
{
    return Message(message);
}

/// Casts a given binary message according to template/type
/// information and processes the cast messages by a given processor.
///
/// Returned value indicates whether message type was successfully
/// recognized and pushed to the processor for further processing. Unknown
/// messages aren't processed and thus false result is returned.
template
<
    class Processor
>
inline
ONIXS_B3_BOE_NODISCARD
bool
processTypified(
    SbeMessage binary,
    const Processor& processor)
{
    switch (binary.templateId())
    {
    case Negotiate1::TemplateId:
    {
        processor(
            typify
            <Negotiate1>
            (binary));

        return true;
    }

    case NegotiateResponse2::TemplateId:
    {
        processor(
            typify
            <NegotiateResponse2>
            (binary));

        return true;
    }

    case NegotiateReject3::TemplateId:
    {
        processor(
            typify
            <NegotiateReject3>
            (binary));

        return true;
    }

    case Establish4::TemplateId:
    {
        processor(
            typify
            <Establish4>
            (binary));

        return true;
    }


===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/Messages.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <cassert>
#include <stdexcept>

#include <OnixS/B3/BOE/ABI.h>
#include <OnixS/B3/BOE/messaging/Composites.h>
#include <OnixS/B3/BOE/messaging/SbeMessage.h>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

/// The client sends the Negotiate message to B3 to initiate a connection. Negotiate is the first message that the client must sent to start the communication between client and gateway through a TCP socket connection.
ONIXS_B3_BOE_LTWT_STRUCT
Negotiate1
: SbeMessage
{
    /// Used template schema.
    typedef SchemaTraits Schema;

    /// This type alias.
    typedef Negotiate1 ThisType;

    /// Message template ID from SBE schema.
    enum { TemplateId = 1 };

    /// Initializes a blank instance.
    Negotiate1() ONIXS_B3_BOE_DEFAULT;

    /// Initializes an instance over the given memory block.
    Negotiate1(
        void* data,
        EncodedLength length,
        SchemaVersion version = Schema::Version)
      : SbeMessage(data, length, version)
    {
        checkVersion<Schema>(version);
        checkLength(length, version);
        init(TemplateId, minimalBlockLength(version), blockLength(version), Schema::Id);
        reset();
    }

    /// Initializes an instance over the given memory block
    /// With no variable-length fields initialization
    /// It is assumed that the user does such an initialization manually.
    Negotiate1(
        void* data,
        EncodedLength length,
        NoFieldsInit,
        SchemaVersion version = Schema::Version)
      : SbeMessage(data, length, version)
    {
        checkVersion<Schema>(version);
        checkLength(length, version);
        init(TemplateId, minimalBlockLength(version), blockLength(version), Schema::Id);
        resetVariableFields();
    }

    /// Creates an instance over the given memory block.
    Negotiate1(
        void* data,
        EncodedLength length,
        NoInit)
      : SbeMessage(data, length)
    {
        checkCompatibility();
    }

    /// Creates an instance over the given SBE message.
    explicit
    Negotiate1(
        const SbeMessage& message)
      : SbeMessage(message)
    {
        assert(message.valid());

        checkCompatibility();
    }

    /// Creates an instance over the given memory block.
    /// Performs no checks.

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/SimpleOpenFramingHeader.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/messaging/Fields.h>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

// B3 SBE Version 1.0 Little-endian
ONIXS_B3_BOE_CONST_OR_CONSTEXPR UInt16 B3BOESbeEncodingType = 0xEB50;

ONIXS_B3_BOE_DATA_PACKING_BEGIN(1)

/// Simple Open Framing Header.
ONIXS_B3_BOE_LTWT_CLASS SimpleOpenFramingHeader
{
public:
    /// Initializes the header.
    void setup(UInt16 sz) ONIXS_B3_BOE_NOTHROW
    {
        size(sz);
        encodingType = B3BOESbeEncodingType;
    }

    /// Sets the size.
    void size(UInt16 val) ONIXS_B3_BOE_NOTHROW
    {
        msgSize = val;
    }

    /// \return the size
    UInt16 size() const ONIXS_B3_BOE_NOTHROW
    {
        return msgSize;
    }

    /// \return the encoding type.
    UInt16 encoding() const ONIXS_B3_BOE_NOTHROW
    {
        return encodingType;
    }

private:
    UInt16 msgSize;
    UInt16 encodingType;
};

ONIXS_B3_BOE_DATA_PACKING_END

/// Serializes SimpleOpenFramingHeader into a string.
ONIXS_B3_BOE_EXPORTED
void toStr(std::string&, const SimpleOpenFramingHeader&);

inline
std::string toStr(const SimpleOpenFramingHeader& header)
{
    std::string res;
    toStr(res, header);
    return res;
}

ONIXS_B3_BOE_MESSAGING_NAMESPACE_END

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/Decimal.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/messaging/Integral.h>
#include <OnixS/B3/BOE/messaging/Memory.h>

#include <string>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

/// Forward declarations
template <class MantissaType, class ExponentType> class FixedPointDecimal;
template <class MantissaType, class ExponentType> class FloatingPointDecimal;
template<class Mantissa, class Exponent> std::string toStr(const FixedPointDecimal <Mantissa, Exponent>&);
template<class Mantissa, class Exponent> std::string toStr(const FloatingPointDecimal <Mantissa, Exponent>&);

/// A real number with a floating exponent.
template <class MantissaType, class ExponentType >
class FloatingPointDecimal
{
    MantissaType mantissa_;
    ExponentType exponent_;

public:
    /// \private
    /// Init traits.
    struct MemberTraits
    {
        enum { Count = 2 };

        typedef MantissaType FirstArgType;

        typedef ExponentType SecondArgType;
    };

    /// Mantissa component type.
    typedef MantissaType Mantissa;

    /// Exponent component type.
    typedef ExponentType Exponent;

    /// Traits.
    enum
    {
        /// Size of the class in bytes.
        Size = sizeof(Mantissa) + sizeof(Exponent)
    };

    /// \return a human-readable presentation.
    ONIXS_B3_BOE_NODISCARD
    std::string toString() const
    {
        return toStr(*this);
    }

    /// Default (zero) initialization.
    ONIXS_B3_BOE_CONSTEXPR
    FloatingPointDecimal() ONIXS_B3_BOE_NOTHROW
        : mantissa_()
        , exponent_()
    {
    }

    /// Explicitly initializes the instance from the mantissa and exponent values.
    ONIXS_B3_BOE_CONSTEXPR
    FloatingPointDecimal(Mantissa mantissa, Exponent exponent) ONIXS_B3_BOE_NOTHROW
        : mantissa_(mantissa)
        , exponent_(exponent)
    {
    }

    /// Initializes the instance as a copy of the given one.
    ONIXS_B3_BOE_CONSTEXPR
    FloatingPointDecimal(
        const FloatingPointDecimal& other) ONIXS_B3_BOE_NOTHROW
        : mantissa_(other.mantissa_)
        , exponent_(other.exponent_)
    {
    }

    /// \return mantissa.

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/MessageSizeTraits.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/ABI.h>
#include <OnixS/B3/BOE/Compiler.h>

#include <OnixS/B3/BOE/messaging/Composites.h>
#include <OnixS/B3/BOE/messaging/Forwards.h>


ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

#if defined(ONIXS_B3_BOE_CXX11)

/// Assume the credentials filed of the message is empty.
template <typename Message>
struct HasEmptyCredentials
{
    static constexpr bool UseCustomValue = true;

    static constexpr
    UInt16 calculateMaxMessageSize()
    {
        return
            Message::blockLength(Message::Schema::Version)
            + MessageHeader::Size
            + Message::getMinimalVariableFieldsSize(Message::Schema::Version);
    }
};

/// Assume the message has a constant size.
template <typename Message>
struct HasNoVariableFieldsOrGroups
{
    static constexpr bool UseCustomValue = true;

    static constexpr
        UInt16 calculateMaxMessageSize()
    {
        return
            Message::blockLength(Message::Schema::Version)
            + MessageHeader::Size;
    }
};

/// Traits for calculating the buffer size of a message.
template <typename Message> struct MaxMessageSizeTraits;

/*
/// \private
template <>
struct MaxMessageSizeTraits<Negotiate1> : HasEmptyCredentials<Negotiate1> {};

/// \private
template <>
struct MaxMessageSizeTraits<Establish4> : HasEmptyCredentials<Establish4> {};

/// \private
template <>
struct MaxMessageSizeTraits<Sequence9> : HasNoVariableFieldsOrGroups<Sequence9> {};

/// \private
template <>
struct MaxMessageSizeTraits<Terminate7> : HasNoVariableFieldsOrGroups<Terminate7> {};

/// \private
template <>
struct MaxMessageSizeTraits<Retransmission13> : HasNoVariableFieldsOrGroups<Retransmission13> {};
*/

#endif

ONIXS_B3_BOE_MESSAGING_NAMESPACE_END

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/Watch.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/messaging/Time.h>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

/// Local watch.
ONIXS_B3_BOE_EXPORTED_CLASS LocalWatch
{
    LocalWatch(const LocalWatch&);
    LocalWatch& operator =(const LocalWatch&);

public:
    /// \return the current local time.
    static Timestamp now();
};

// UTC watch.
class ONIXS_B3_BOE_EXPORTED UtcWatch
{
    UtcWatch(const UtcWatch&);
    UtcWatch& operator =(const UtcWatch&);

public:
    /// \return the current UTC.
    static Timestamp now();
};

ONIXS_B3_BOE_MESSAGING_NAMESPACE_END

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/Decimal.Operations.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/ABI.h>

#include <OnixS/B3/BOE/messaging/Decimal.h>
#include <OnixS/B3/BOE/messaging/Composites.h>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

/// \private
ONIXS_B3_BOE_EXPORTED
ONIXS_B3_BOE_COLDPATH
ONIXS_B3_BOE_NORETURN
void throwCannotQuantizeOrConvert();

/// Universal decimal type.
typedef FloatingPointDecimal<Int64, Int32> Decimal;
//

/// \private
ONIXS_B3_BOE_CONSTEXPR
inline bool isNull(const Decimal&) ONIXS_B3_BOE_NOTHROW
{
    return false;
}

/// Quantize so its exponent is the same as that of provided value.
///
/// \return `false` if the value cannot be quantized.
ONIXS_B3_BOE_EXPORTED
bool
quantize(
    const Decimal& operand,
    Int32 exponent,
    Decimal& quantized);

/// Quantize so its exponent is the same as that of provided value.
///
/// \throw std::exception if the value cannot be quantized.
///
/// \return resulting decimal.
ONIXS_B3_BOE_EXPORTED
ONIXS_B3_BOE_NODISCARD
ONIXS_B3_BOE_PURE
Decimal quantize(const Decimal& operand, Int32 exponent);

/// Quantize so its exponent is the same as that of provided value.
///
/// \throw std::exception if the value cannot be quantized
///
/// \return resulting decimal mantissa
template <class MantissaType>
ONIXS_B3_BOE_NODISCARD
MantissaType quantizedMantissa(const Decimal& operand, Int32 exponent)
{
    const Decimal::Mantissa res =
        quantize(
            operand, exponent)
                .mantissa();

    if(static_cast<MantissaType>(
        (std::numeric_limits<MantissaType>::max)()) >= res)
    {
        return static_cast<MantissaType>(res);
    }

    throwCannotQuantizeOrConvert();
}

template
<
    class MantissaType,
    class ExponentType
>
void convert(
    FixedPointDecimal<MantissaType, ExponentType>& res,
    const Decimal& number)
{
    res =
        FixedPointDecimal<MantissaType, ExponentType>(

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/Serialization.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <string>

#include <OnixS/B3/BOE/messaging/Fields.h>
#include <OnixS/B3/BOE/messaging/Composites.h>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

// Market Data Serialization.

/// Serializes into a string.
ONIXS_B3_BOE_EXPORTED
void
toStr(
    std::string& str,
    Boolean::Enum value);


/// Serializes into a string.
inline std::string toStr(Boolean::Enum value)
{
    std::string str;

    toStr(str, value);

    return str;
}

/// Serializes into a stream.
inline
std::ostream&
operator<<(
    std::ostream& stream,
    Boolean::Enum value)
{
    std::string str;

    toStr(str, value);

    return stream << str;
}

/// Serializes the object into FIX presentation.
inline
void
toFix(
    std::string& str,
    Boolean::Enum value)
{
    toStr(
        str,
        static_cast<Boolean::Base>(value));
}


/// Serializes into a string.
ONIXS_B3_BOE_EXPORTED
void
toStr(
    std::string& str,
    AllocTransType::Enum value);


/// Serializes into a string.
inline
std::string
toStr(
    AllocTransType::Enum value)
{
    std::string str;

    toStr(str, value);

    return str;
}

/// Serializes into a stream.
inline
std::ostream&

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/MaxMessageSize.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/ABI.h>
#include <OnixS/B3/BOE/Compiler.h>

#include <OnixS/B3/BOE/messaging/Fields.h>
#include <OnixS/B3/BOE/messaging/Composites.h>
#include <OnixS/B3/BOE/messaging/SimpleOpenFramingHeader.h>

#include <OnixS/B3/BOE/messaging/MessageSizeTraits.h>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

/// Maximum supported message size.
ONIXS_B3_BOE_CONST_OR_CONSTEXPR UInt16 MaxB3BOEMessageSize = 65535 - sizeof(SimpleOpenFramingHeader);

#if defined(ONIXS_B3_BOE_CXX11)

/// \private
template <typename Message>
struct MaxMessageSizeTraits
{
    static constexpr bool UseCustomValue = false;
};

/// Calculates the buffer size for a message with the given number of repeating group items.
template<typename Message>
constexpr
MessageSize calculateMaxMessageSize(UInt8 maxGroupItems)
{
    return
        ONIXS_B3_BOE_ASSERT(Message::getMaxMessageSize(maxGroupItems) <= MaxB3BOEMessageSize),
        static_cast<MessageSize>(Message::getMaxMessageSize(maxGroupItems));
}

/// Calculates the buffer size for a message with the given number of repeating group items.
template<typename Message>
constexpr
typename std::enable_if<MaxMessageSizeTraits<Message>::UseCustomValue, MessageSize>::type
getMaxMessageSize(UInt8)
{
    return
        MaxMessageSizeTraits<Message>::calculateMaxMessageSize();
}

/// Calculates the buffer size for a message with the given number of repeating group items.
template<typename Message>
constexpr
typename std::enable_if<!MaxMessageSizeTraits<Message>::UseCustomValue, MessageSize>::type
getMaxMessageSize(UInt8 maxGroupItems)
{
    return calculateMaxMessageSize<Message>(maxGroupItems);
}

/// \private
template<typename Message, UInt8 MaxGroupItems>
struct GetMaxMessageSize
{
    enum {Size = getMaxMessageSize<Message>(MaxGroupItems)};
};

/// \private
template<typename Message>
constexpr
UInt16 getMinMessageSize()
{
    return
        Message::blockLength(Message::Schema::Version)
        + MessageHeader::Size
        + Message::getMinimalVariableFieldsSize(Message::Schema::Version);
}

/// \private
template<typename Message>
struct GetMinMessageSize
{
    enum {Size = getMinMessageSize<Message>()};
};

#else

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/SbeMessage.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/ABI.h>
#include <OnixS/B3/BOE/messaging/Aliases.h>
#include <OnixS/B3/BOE/messaging/StrRef.h>
#include <OnixS/B3/BOE/messaging/Memory.h>
#include <OnixS/B3/BOE/messaging/Composites.h>
#include <OnixS/B3/BOE/messaging/SchemaTraits.h>
#include <OnixS/B3/BOE/messaging/MaxMessageSize.h>
#include <OnixS/B3/BOE/messaging/ExceptionHelpers.h>

#include <cassert>
#include <limits>
#include <stdexcept>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

/// Message type (template) identification.
typedef
MessageHeader::TemplateId MessageTemplateId;

/// \private
template<typename Message> inline
void checkBinaryLength(const Message&, MessageSize length, MessageSize minimalRequiredLength)
{
    if ONIXS_B3_BOE_UNLIKELY(length < minimalRequiredLength)
        throwBinaryBlockIsTooSmall(length, minimalRequiredLength, Message::className());
}

/// \private
ONIXS_B3_BOE_LTWT_CLASS BinaryBlockBase
{
protected:
    ~BinaryBlockBase() ONIXS_B3_BOE_DEFAULT;
};

/// Services to access fields stored
/// in an SBE-encoded block of fixed-length fields.
///
/// The given class represents an abstraction to be used
/// by descendants as a base class with static polymorphism.
template < class Container, class BlockLength >
ONIXS_B3_BOE_LTWT_CLASS BinaryBlock : public BinaryBlockBase
{
    /// \return The block container that provides access to the encoded data.
    const Container& container() const ONIXS_B3_BOE_NOTHROW
    {
        return *static_cast <const Container*> (this);
    }

protected:
    /// Initializes a blank instance.
    BinaryBlock() ONIXS_B3_BOE_DEFAULT;

    ~BinaryBlock() ONIXS_B3_BOE_DEFAULT;

    /// \return the field value.
    template < class Value > ONIXS_B3_BOE_HOTPATH
    Value ordinary(BlockLength offset) const ONIXS_B3_BOE_NOTHROW
    {
        assert(container().blockLength() >= (offset + size<Value>()) &&
            "The requested field exceeds provided block boundaries.");

        const void* const location = advanceByBytes(container().block(), offset);
        return getValue<Value>(location);
    }

    /// \return constant reference to the field value.
    template < class Value > ONIXS_B3_BOE_HOTPATH
    const Value& accessOrdinary(BlockLength offset) const ONIXS_B3_BOE_NOTHROW
    {
        assert(container().blockLength() >= (offset + size<Value>()) &&
            "The requested field exceeds provided block boundaries.");

        const void* location = advanceByBytes(container().block(), offset);
        const Value* valuePtr = static_cast<const Value*>(location);
        return *valuePtr;
    }

    /// \return reference to the field value.

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/Composites.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/ABI.h>

#include <OnixS/B3/BOE/messaging/Memory.h>
#include <OnixS/B3/BOE/messaging/Decimal.h>
#include <OnixS/B3/BOE/messaging/Fields.h>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN
ONIXS_B3_BOE_DATA_PACKING_BEGIN(1)

/// Message identifiers and length of message root.
ONIXS_B3_BOE_LTWT_CLASS MessageHeader
{
public:
    /// Size of the composite.
    enum { Size = 8 };

    /// Length of the root of the FIX message contained before repeating groups or variable/conditions fields.
    typedef UInt16 BlockLength;

    /// Template ID used to encode the message.
    typedef UInt16 TemplateId;

    /// ID of the system publishing the message.
    typedef UInt16 SchemaId;

    /// Schema version.
    typedef UInt16 Version;

    /// Length of the root of the FIX message contained before repeating groups or variable/conditions fields.
    ONIXS_B3_BOE_NODISCARD
    BlockLength blockLength() const
        ONIXS_B3_BOE_NOTHROW
    {
        return blockLength_;
    }

    /// Length of the root of the FIX message contained before repeating groups or variable/conditions fields.
    void setBlockLength(BlockLength value)
        ONIXS_B3_BOE_NOTHROW
    {
        blockLength_ = value;
    }

    /// Template ID used to encode the message.
    ONIXS_B3_BOE_NODISCARD
    TemplateId templateId() const
        ONIXS_B3_BOE_NOTHROW
    {
        return templateId_;
    }

    /// Template ID used to encode the message.
    void setTemplateId(TemplateId value)
        ONIXS_B3_BOE_NOTHROW
    {
        templateId_ = value;
    }

    /// ID of the system publishing the message.
    ONIXS_B3_BOE_NODISCARD
    SchemaId schemaId() const
        ONIXS_B3_BOE_NOTHROW
    {
        return schemaId_;
    }

    /// ID of the system publishing the message.
    void setSchemaId(SchemaId value)
        ONIXS_B3_BOE_NOTHROW
    {
        schemaId_ = value;
    }

    /// Schema version.
    ONIXS_B3_BOE_NODISCARD
    Version version() const
        ONIXS_B3_BOE_NOTHROW
    {

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/Memory.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/Compiler.h>
#include <OnixS/B3/BOE/messaging/Integral.h>
#include <OnixS/B3/BOE/messaging/Utils.h>

#include <cstddef>
#include <cstring>
#include <cassert>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

/// Alias for Byte.
typedef UInt8 Byte;

/// Alias for Word.
typedef UInt16 Word;

/// Alias for Double Word.
typedef UInt32 DWord;

/// Alias for Quad Word.
typedef UInt64 QWord;

/// Makes the pointer an opaque one.
/// \private
template
<
    typename Type
>
ONIXS_B3_BOE_HOTPATH
ONIXS_B3_BOE_PURE
void*
toOpaquePtr(Type* ptr)
    ONIXS_B3_BOE_NOTHROW
{
    assert(ptr);
    return static_cast<void*>(ptr);
}

/// Makes the pointer an opaque one.
/// \private
template
<
    typename Type
>
ONIXS_B3_BOE_HOTPATH
ONIXS_B3_BOE_PURE
const void*
toOpaquePtr(const Type* ptr)
    ONIXS_B3_BOE_NOTHROW
{
    assert(ptr);
    return static_cast<const void*>(ptr);
}

/// \private
template
<
    typename Type
>
ONIXS_B3_BOE_HOTPATH
ONIXS_B3_BOE_PURE
void* toMutable(const Type* ptr) ONIXS_B3_BOE_NOTHROW
{
    assert(ptr);
    return const_cast<void*>(static_cast<const void*>(ptr));
}

/// Reinterprets the pointer as a byte block one.
/// \private
template
<
    typename Type
>
ONIXS_B3_BOE_HOTPATH
ONIXS_B3_BOE_PURE
Byte*
toByteBlock(Type* ptr)
    ONIXS_B3_BOE_NOTHROW

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/Aliases.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/ABI.h>
#include <OnixS/B3/BOE/messaging/Integral.h>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

/// Message length type.
typedef UInt16 MessageSize;

ONIXS_B3_BOE_MESSAGING_NAMESPACE_END

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/Utils.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <cassert>

#include <OnixS/B3/BOE/ABI.h>

#ifdef ONIXS_B3_BOE_HAS_TYPE_TRAITS
#   include <type_traits>
#endif

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

#ifdef ONIXS_B3_BOE_HAS_TYPE_TRAITS

/// \private
template <bool B, class T = void>
using EnableIf = std::enable_if<B, T>;

/// \private
template <typename Base, typename Derived>
using IsBaseOf = std::is_base_of<Base, Derived>;

/// \private
template <class T>
using IsSigned = std::is_signed<T>;

#define CHECK_TYPE_INTEGRAL(Type) \
          static_assert( \
              std::is_integral<Type>::value, \
              #Type " must be an integral type, consider adding MemberTraits" \
              );
#else

/// \private
template <bool B, class T = void>
struct EnableIf
{
    typedef T type;
};

/// \private
template <class T>
struct EnableIf<false, T> {};

/// \private
template<typename Base, typename Derived>
struct IsBaseOf
{
    enum { value = __is_base_of(Base, Derived)};
};

/// \private
template<typename T>
struct IsSigned
{
    enum { value = (!(static_cast<T>(-1) > static_cast<T>(0))) };
};

#define CHECK_TYPE_INTEGRAL(Type)

#endif

///\private
namespace details {

    ///\private
    template <class T, class U>
    struct IsSameSignedness
    {
        enum { value = (static_cast<bool>(IsSigned<T>::value) == static_cast<bool>(IsSigned<U>::value)) };
    };

    ///\private
    template<typename T>
    struct HasMantissa
    {
        template<typename U> struct SFINAE {};
        template<typename U> static char test(SFINAE<typename U::Mantissa>*);
        template<typename U> static int test(...);
        enum { value = sizeof(test<T>(ONIXS_B3_BOE_NULLPTR)) == sizeof(char) };

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/String.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <string>

#include <OnixS/B3/BOE/ABI.h>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

/// Character type alias.
typedef char Char;

/// Appends the character to the given std::string instance.
inline
void toStr(std::string& str, Char character)
{
    str.append(1, character);
}

/// Appends strings.
inline
void toStr(std::string& str, const std::string& value)
{
    str.append(value);
}

/// Constructs a std::string from the given character.
ONIXS_B3_BOE_NODISCARD
inline std::string toStr(Char character)
{
    return std::string(1, character);
}

ONIXS_B3_BOE_MESSAGING_NAMESPACE_END

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/ExceptionHelpers.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/ABI.h>
#include <OnixS/B3/BOE/messaging/SchemaTraits.h>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

/// Message type (template) identification.
typedef MessageHeader::TemplateId MessageTemplateId;

/// \private
/// Throws an exception on a bad repeating group.
ONIXS_B3_BOE_EXPORTED
ONIXS_B3_BOE_COLDPATH
ONIXS_B3_BOE_NORETURN
void throwBadBinaryBlock();

/// \private
/// Throws an exception on a bad repeating group entry.
ONIXS_B3_BOE_EXPORTED
ONIXS_B3_BOE_COLDPATH
ONIXS_B3_BOE_NORETURN
void throwDisallowedField();

/// \private
/// Raises an exception when the given binary block is too small.
ONIXS_B3_BOE_EXPORTED
ONIXS_B3_BOE_COLDPATH
ONIXS_B3_BOE_NORETURN
void throwBinaryBlockIsTooSmall(MessageSize actual, MessageSize required);

/// \private
/// Raises an exception when the given binary block is too small.
ONIXS_B3_BOE_EXPORTED
ONIXS_B3_BOE_COLDPATH
ONIXS_B3_BOE_NORETURN
void throwBinaryBlockIsTooSmall(MessageSize actual, MessageSize required, const Char*);

/// \private
/// Raises an exception on a bad message version.
ONIXS_B3_BOE_EXPORTED
ONIXS_B3_BOE_COLDPATH
ONIXS_B3_BOE_NORETURN
void throwBadMessageVersion(SchemaVersion messageVersion, SchemaVersion minimalVersion);

/// \private
/// Raises an exception on a bad message id.
ONIXS_B3_BOE_EXPORTED
ONIXS_B3_BOE_COLDPATH
ONIXS_B3_BOE_NORETURN
void throwBadSchemaId(SchemaId expected, SchemaId provided);

/// \private
/// Throws an exception on a bad repeating group entry.
ONIXS_B3_BOE_EXPORTED
ONIXS_B3_BOE_COLDPATH
ONIXS_B3_BOE_NORETURN
void throwNotEnoughSpace();

/// \private
ONIXS_B3_BOE_EXPORTED
ONIXS_B3_BOE_COLDPATH
ONIXS_B3_BOE_NORETURN
void throwBadConversion(const Char* typeName);


/// \private
/// \throw DecodingError
ONIXS_B3_BOE_EXPORTED
ONIXS_B3_BOE_NORETURN
ONIXS_B3_BOE_COLDPATH
void throwIncorrectEncoding(Messaging::UInt16 encoding, const void* data, MessageSize size);

/// \private
/// \throw UnsufficientDataError
ONIXS_B3_BOE_EXPORTED
ONIXS_B3_BOE_NORETURN
ONIXS_B3_BOE_COLDPATH
void throwNetPacketIsTooSmall(MessageSize actual, MessageSize required);


===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/Forwards.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/ABI.h>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

ONIXS_B3_BOE_LTWT_STRUCT_DECL(Negotiate1);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(NegotiateResponse2);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(NegotiateReject3);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(Establish4);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(EstablishAck5);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(EstablishReject6);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(Terminate7);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(NotApplied8);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(Sequence9);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(RetransmitRequest12);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(Retransmission13);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(RetransmitReject14);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(SimpleNewOrder100);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(SimpleModifyOrder101);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(NewOrderSingle102);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(OrderCancelReplaceRequest104);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(OrderCancelRequest105);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(NewOrderCross106);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(ExecutionReportNew200);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(ExecutionReportModify201);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(ExecutionReportCancel202);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(ExecutionReportTrade203);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(ExecutionReportReject204);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(ExecutionReportForward205);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(BusinessMessageReject206);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(SecurityDefinitionRequest300);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(SecurityDefinitionResponse301);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(QuoteRequest401);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(QuoteStatusReport402);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(Quote403);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(QuoteCancel404);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(QuoteRequestReject405);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(PositionMaintenanceCancelRequest501);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(PositionMaintenanceRequest502);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(PositionMaintenanceReport503);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(AllocationInstruction601);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(AllocationReport602);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(OrderMassActionRequest701);
ONIXS_B3_BOE_LTWT_STRUCT_DECL(OrderMassActionReport702);

ONIXS_B3_BOE_MESSAGING_NAMESPACE_END

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/MessageHolder.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <vector>

#include <OnixS/B3/BOE/messaging/MaxMessageSize.h>
#include <OnixS/B3/BOE/messaging/SbeMessage.h>
#include <OnixS/B3/BOE/messaging/NetworkMessage.h>

namespace OnixS
{
    namespace B3
    {
        namespace BOE
        {
            ONIXS_B3_BOE_EXPORTED_CLASS Session;
        }
    }
}

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

/// \return the version of the Session’s message schema.
ONIXS_B3_BOE_EXPORTED
Messaging::SchemaVersion getMessagingVersion(const Session&) ONIXS_B3_BOE_NOTHROW;

/// The policy to create messages with null-initialized optional fields.
struct FieldsInitPolicy
{
    /// \private
    template <typename SbeMessageType>
    inline static SbeMessageType createMessage(
        void* data, MessageSize length, SchemaVersion version)
    {
        return SbeMessageType(data, length, version);
    }

    /// \private
    inline static const char* name() ONIXS_B3_BOE_NOTHROW
    {
        return "FieldsInitPolicy";
    }
};

/// The policy to create messages without initialized optional fields.
struct FieldsNoInitPolicy
{
    /// \private
    template <typename SbeMessageType>
    inline static SbeMessageType createMessage(
        void* data, MessageSize length, SchemaVersion version)
    {
        return SbeMessageType(
            data, length, SbeMessage::NoFieldsInit(), version);
    }

    /// \private
    inline static const char* name() ONIXS_B3_BOE_NOTHROW
    {
        return "FieldsNoInitPolicy";
    }
};

/// \private
template <typename MessageType>
struct HeldAdapter : public MessageType
{
    ONIXS_B3_BOE_STATIC_ASSERT((
        IsBaseOf<SbeMessage, MessageType>::value));

    enum { isFix = false };

    typedef MessageType SbeType;

    typedef typename
    SbeType::EncodedLength
        EncodedLength;

    HeldAdapter() ONIXS_B3_BOE_DEFAULT;

    HeldAdapter(

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/Integral.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/ABI.h>
#include <OnixS/B3/BOE/messaging/String.h>

#include <string>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

#if defined (_MSC_VER)

typedef signed char Int8;
typedef unsigned char UInt8;

typedef signed short Int16;
typedef unsigned short UInt16;

typedef signed int Int32;
typedef unsigned int UInt32;

typedef signed long long Int64;
typedef unsigned long long UInt64;

#elif defined (__GNUC__)

typedef signed char Int8;
typedef unsigned char UInt8;

typedef signed short Int16;
typedef unsigned short UInt16;

#if defined (__LP64__)

typedef signed int Int32;
typedef unsigned int UInt32;

typedef signed long Int64;
typedef unsigned long UInt64;

#else

typedef signed int Int32;
typedef unsigned int UInt32;

typedef signed long long Int64;
typedef unsigned long long UInt64;

#endif

#else

// Compiler is not (yet) supported.
// Integral types must be defined explicitly.

#error \
    Cannot identify compiler toolset to define integral types. \
    Please contact support@onixs.biz on further assistance.

#endif

/// Integral constant.
template
<
    typename Type,
    Type Constant
>
struct IntegralConstant
{
    /// Type of the constant.
    typedef Type Value;

    /// \return value of the constant.
    ONIXS_B3_BOE_CONSTEXPR
    operator Value() const ONIXS_B3_BOE_NOTHROW
    {
        return Constant;
    }

    /// \return value of the constant.
    ONIXS_B3_BOE_CONSTEXPR

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/Validation.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/Compiler.h>
#include <OnixS/B3/BOE/messaging/MessageHolder.h>
#include <OnixS/B3/BOE/messaging/Messages.h>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

//template <typename Message>
//void validate(const Message&)
//{
//}
//
//template <typename SbeMessageType, size_t MaxMessageSize, typename MessageInitializer>
//void validate(const Messaging::MessageHolder<SbeMessageType, MaxMessageSize, MessageInitializer>& holder)
//{
//    validate(holder.message());
//}

ONIXS_B3_BOE_MESSAGING_NAMESPACE_END

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/messaging/Time.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/BOE/messaging/Utils.h>
#include <OnixS/B3/BOE/messaging/Integral.h>

#include <stdexcept>

ONIXS_B3_BOE_MESSAGING_NAMESPACE_BEGIN

/// Miscellaneous time characteristics.
ONIXS_B3_BOE_LTWT_STRUCT TimeTraits
{
    /// \return the number of nanoseconds in a day.
    ONIXS_B3_BOE_CONSTEXPR
    static Int64 nanosecondsPerDay() ONIXS_B3_BOE_NOTHROW
    {
        return 86400000000000ll;
    }

    /// \return the number of nanoseconds in an hour.
    ONIXS_B3_BOE_CONSTEXPR
    static Int64 nanosecondsPerHour() ONIXS_B3_BOE_NOTHROW
    {
        return 3600000000000ll;
    }

    /// \return the number of nanoseconds in a minute.
    ONIXS_B3_BOE_CONSTEXPR
    static Int64 nanosecondsPerMinute() ONIXS_B3_BOE_NOTHROW
    {
        return 60000000000ll;
    }

    /// \return the number of nanoseconds in a second.
    ONIXS_B3_BOE_CONSTEXPR
    static Int32 nanosecondsPerSecond() ONIXS_B3_BOE_NOTHROW
    {
        return 1000000000;
    }

    /// \return the number of nanoseconds in a millisecond.
    ONIXS_B3_BOE_CONSTEXPR
    static Int32 nanosecondsPerMillisecond() ONIXS_B3_BOE_NOTHROW
    {
        return 1000000;
    }

    /// \return the number of nanoseconds in a microsecond.
    ONIXS_B3_BOE_CONSTEXPR
    static Int32 nanosecondsPerMicrosecond() ONIXS_B3_BOE_NOTHROW
    {
        return 1000;
    }

    /// \return the number of hours in a day.
    ONIXS_B3_BOE_CONSTEXPR
    static Int32 hoursPerDay() ONIXS_B3_BOE_NOTHROW
    {
        return 24;
    }

    /// \return the number of minutes in an hour.
    ONIXS_B3_BOE_CONSTEXPR
    static Int32 minutesPerHour() ONIXS_B3_BOE_NOTHROW
    {
        return 60;
    }

    /// \return the number of seconds in a minute.
    ONIXS_B3_BOE_CONSTEXPR
    static Int32 secondsPerMinute() ONIXS_B3_BOE_NOTHROW
    {
        return 60;
    }

    /// \return the number of milliseconds in a second.
    ONIXS_B3_BOE_CONSTEXPR
    static Int32 millisecondsPerSecond() ONIXS_B3_BOE_NOTHROW
    {
        return 1000;

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/TcpInfo.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable OnixS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/BOE/ABI.h>

namespace OnixS {
namespace B3 {
namespace BOE {

/// TCP state information.

struct TcpInfo
{
    /// State of the connection
    struct TcpState
    {
        enum Enum
        {
            /// TCP connection is established
            Established = 1,

            /// TCP SYN packet has been sent
            SynSent,

            /// TCP SYN packet has been received
            SynRecv,

            /// TCP connection is in FIN wait state 1
            FinWait1,

            /// TCP connection is in FIN wait state 2
            FinWait2,

            /// TCP connection is in time wait state
            TimeWait,

            /// TCP connection is closing
            Close,

            /// TCP connection is in close wait state
            CloseWait,

            /// Last acknowledgment has been sent
            LastAck,

            /// TCP socket is listening for incoming connections
            Listen,

            /// TCP connection is in closing state
            Closing,

            /// TCP connection has received a new SYN packet
            NewSynRecv
        };
    };

    /// TCP congestion avoidance state
    struct TcpCaState
    {
        enum Enum
        {
            /// TCP congestion avoidance state: open
            Open = 0,

            /// TCP congestion avoidance state: disorder
            Disorder,

            /// TCP congestion avoidance state: congestion window reduced
            Cwr,

            /// TCP congestion avoidance state: recovery
            Recovery,

            /// TCP congestion avoidance state: loss
            Loss
        };
    };

    /// Represents the state of the TCP connection.
    TcpState::Enum state;

    /// Represents the congestion avoidance state of the TCP connection.

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/SessionStateId.h =====
#pragma once

/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#include <OnixS/B3/BOE/ABI.h>

#include <iosfwd>
#include <string>

namespace OnixS {
namespace B3 {
namespace BOE {

/// Session state ID.
struct SessionStateId
{
    enum Enum
    {
        /// Session is disconnected.
        Disconnected,

        /// Session is waiting for the `Negotiation Response` message from the exchange.
        AwaitNegotiationResponse,

        /// Session is waiting for the `Establishment Acknowledgment` message from the exchange.
        AwaitEstablishmentAck,

        /// Session is waiting for the confirming `Terminate` message from the exchange.
        AwaitConfirmingTerminate,

        /// Session is fully established.
        Established,

        /// Session is trying to restore the telecommunication link.
        Reconnecting,

        /// Session is waiting for the message retransmission from the exchange.
        WaitForRetransmission,
    };

    /// \return the session state as a string.
    ONIXS_B3_BOE_EXPORTED static const std::string& toString(Enum state);
};

inline std::ostream & operator<<(std::ostream & o, SessionStateId::Enum state) {
    return o << SessionStateId::toString(state);
}

}
}
}

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/SessionReactor.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/BOE/threading/Definitions.h>

namespace OnixS {
namespace B3 {
namespace BOE {

/// Network reactor type.
struct ReactorType {
    enum Enum {
        /// Undefined reactor.
        Undefined = 0,

        /// Solarflare TCPDirect reactor.
        TcpDirect = 1,

        /// Standard TCP reactor.
        TcpStandard = 2
    };
};

/// Session's network stack reactor interface.
class ONIXS_B3_BOE_EXPORTED SessionReactor
{
public:
    /// Destructor.
    virtual ~SessionReactor() ONIXS_B3_BOE_DEFAULT;

    /// Processes events on a stack and performs the necessary handling.
    ///
    /// These events, including transmit and receive events raised by the hardware,
    /// and also software events such as TCP and FIXP protocol timers.
    virtual void dispatchEvents() = 0;

    /// \return a boolean value indicating whether a stack is quiescent.
    virtual bool isQuiescent() const = 0;

    /// \return the ID of the thread that created the stack.
    virtual Threading::ThreadId workingThreadId() const ONIXS_B3_BOE_NOTHROW = 0;

    /// \return the type of the stack.
    virtual ReactorType::Enum type() const ONIXS_B3_BOE_NOTHROW = 0;
};
}
}
}

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/SessionSettings.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable OnixS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/BOE/ABI.h>
#include <OnixS/B3/BOE/Messaging.h>
#include <OnixS/B3/BOE/ThreadingModel.h>

#include <climits>
#include <set>
#include <string>
#include <vector>

namespace OnixS {
namespace B3 {
namespace BOE {

/**
 * Session settings.
 */
class SessionSettings
{
public:
    ONIXS_B3_BOE_EXPORTED
    SessionSettings();

    /// \return the session id that was assigned by the exchange.
    ///
    /// The default value is empty.
    ONIXS_B3_BOE_NODISCARD
    Messaging::SessionID sessionId() const ONIXS_B3_BOE_NOTHROW {
        return sessionId_;
    }

    /// Sets the session id that was assigned by the exchange.
    ONIXS_B3_BOE_EXPORTED
    SessionSettings& sessionId(Messaging::SessionID value);

    /// \return the broker firm id that will enter orders.
    ///
    /// The default value is zero.
    ONIXS_B3_BOE_NODISCARD
    Messaging::UInt32 enteringFirm() const ONIXS_B3_BOE_NOTHROW {
        return enteringFirm_;
    }

    /// Sets the broker firm id that will enter orders.
    ONIXS_B3_BOE_EXPORTED
    SessionSettings& enteringFirm(Messaging::UInt32 value);

    /// \return The token provided by B3 for the FIXP session.
    ///
    /// The default value is empty.
    ONIXS_B3_BOE_NODISCARD
    const std::string & accessKey() const ONIXS_B3_BOE_NOTHROW {
        return accessKey_;
    }

    /// Sets the token provided by B3 for the FIXP session.
    ONIXS_B3_BOE_EXPORTED
    SessionSettings& accessKey(const std::string & value);

    /// \return The criteria used to initiate cancel on disconnect mechanism by the gateway.
    ///
    /// The default value is DoNotCancelOnDisconnectOrTerminate.
    ONIXS_B3_BOE_NODISCARD
    Messaging::CancelOnDisconnectType::Enum cancelOnDisconnectType() const ONIXS_B3_BOE_NOTHROW {
        return cancelOnDisconnectType_;
    }

    /// Sets the criteria used to initiate cancel on disconnect mechanism by the gateway.
    ONIXS_B3_BOE_EXPORTED
    SessionSettings& cancelOnDisconnectType(Messaging::CancelOnDisconnectType::Enum value);

    /// \return the trading system name.
    ///
    /// The default value is empty.
    ONIXS_B3_BOE_NODISCARD
    const std::string & tradingSystemName() const ONIXS_B3_BOE_NOTHROW {
        return tradingSystemName_;
    }

    /// Sets the trading system name.

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/utils/FileSystem.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/
#pragma once

#include <OnixS/B3/BOE/ABI.h>

#include <vector>
#include <string>

namespace OnixS {
namespace B3 {
namespace BOE {
namespace Filesystem {

/// Gathers files which are stored in a given folder.
ONIXS_B3_BOE_EXPORTED
void gatherFiles(std::vector<std::string>* gatheredFiles, const std::string& root, const std::string& extension);

/// \return true if provided path is a directory
ONIXS_B3_BOE_EXPORTED
bool isDirectory(const std::string& path);

/// \return true if provided entry exists
ONIXS_B3_BOE_EXPORTED
bool exist(const std::string& entry);


}}}}

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/ThreadingModel.h =====
#pragma once

/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#include <string>

#include <OnixS/B3/BOE/ABI.h>

namespace OnixS {
namespace B3 {
namespace BOE {

    /// Threading model.
    struct ThreadingModel
    {
        enum Enum
        {
            /// Each session has a sender thread and a receiving thread.
            Dedicated,

            /// Sessions share a thread pool.
            Pool,

            /// Session events are handled by rolling an event loop in a user thread.
            External,

            /// The default mode.
            Default = Dedicated,
        };

        /// \return a string that represents the given value.
        ONIXS_B3_BOE_EXPORTED static const char * toString(Enum type) ONIXS_B3_BOE_NOTHROW;

        ONIXS_B3_BOE_EXPORTED static Enum parse(const std::string & text);
    };
}
}
}

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/Session.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable OnixS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <limits.h>

#include <OnixS/B3/BOE/ABI.h>
#include <OnixS/B3/BOE/Defines.h>
#include <OnixS/B3/BOE/SessionListener.h>
#include <OnixS/B3/BOE/SessionSettings.h>
#include <OnixS/B3/BOE/SessionStorage.h>
#include <OnixS/B3/BOE/SessionReactor.h>
#include <OnixS/B3/BOE/TcpInfo.h>
#include <OnixS/B3/BOE/messaging/SbeMessage.h>
#include <OnixS/B3/BOE/threading/Future.h>

namespace OnixS
{
namespace B3
{
namespace BOE
{
// Forward declarations
class TcpDirectStack;
namespace AdHoc { struct SessionHelper; };

/**
* A FIXP Session.
*/
class ONIXS_B3_BOE_EXPORTED Session
{
public:
    static const UInt64 UndefinedSessionVerID = 0;

    /**
     * Constructor.
     *
     * \param settings Session settings.
     * \param listener Session listener.
     * \param storageType Session storage type.
     * \param storage Session storage.
     * \param sessionVerId Session Version Identification (sessionVerId).
     * \param customKey Custom key that could be used to distinguish sessions with the same sessionVerId, Session ID, FirmId, and Market Segment ID values.
     */
    Session(const SessionSettings &settings, SessionListener *listener, SessionStorageType::Enum storageType = SessionStorageType::FileBased,
        SessionStorage *storage = ONIXS_B3_BOE_NULLPTR, UInt64 sessionVerId = UndefinedSessionVerID, const std::string &customKey = "");

    Session(SessionReactor & stack, const SessionSettings & settings, SessionListener * listener, SessionStorageType::Enum storageType = SessionStorageType::FileBased,
        SessionStorage * storage = ONIXS_B3_BOE_NULLPTR, UInt64 sessionVerId = UndefinedSessionVerID, const std::string &customKey = "");

    ~Session();

    /// \return the Session Version Identification (sessionVerId).
    UInt64 sessionVerId() const ONIXS_B3_BOE_NOTHROW;

    /// \return string presentation for Session ID (assigned by the exchange).
    std::string id() const;

    /// \return Session ID (assigned by the exchange).
    Messaging::SessionID sessionId() const ONIXS_B3_BOE_NOTHROW;

    /// \return Custom key that could be used to distinguish sessions with the same sessionVerId, Session ID, FirmId, and Market Segment ID values.
    std::string customKey() const;

    /// \return `true` if the session is negotiated (the Negotiation Response message has been received in reply to the Negotiation message); otherwise - `false`.
    bool negotiated() const;

    /// Sets the "negotiated" status.
    ///
    /// The session is negotiated when the Negotiation Response message has been received in reply to the Negotiation message.
    Session& negotiated(bool negotiated);

    /**
     * Establishes the connection.
     *
     * \param host Market Segment Gateway host.
     * \param port Market Segment Gateway port.
     *
     * \return This session.
     */
    Session& connect(const std::string &host, Port port);

    /**

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/TcpStandardStack.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/
#pragma once

#include <OnixS/B3/BOE/SessionReactor.h>
#include <OnixS/B3/BOE/threading/Thread.h>

namespace OnixS {
namespace B3 {
namespace BOE {

/**
 * A high-level wrapper over the TCP standard stack.
 */
class ONIXS_B3_BOE_EXPORTED TcpStandardStack ONIXS_B3_BOE_FINAL : public SessionReactor
{
public:
    /**
    * Allocates a TCP stack.
    */
    TcpStandardStack();

#if defined(ONIXS_B3_BOE_CXX11)
    TcpStandardStack(const TcpStandardStack &) = delete;
    TcpStandardStack(TcpStandardStack &&) = delete;

    TcpStandardStack & operator=(const TcpStandardStack &) = delete;
    TcpStandardStack & operator=(TcpStandardStack &&) = delete;
#endif

    ~TcpStandardStack() ONIXS_B3_BOE_OVERRIDE;

    /**
     * Processes events on a stack and performs the necessary handling.
     *
     * These events, including transmit and receive events raised by the hardware,
     * and also software events such as TCP and FIXP protocol timers.
     *
     */
    void dispatchEvents() ONIXS_B3_BOE_OVERRIDE {
        dispatchEventsImpl();
    }

    /**
    * \return a boolean value indicating whether a stack is quiescent.
     *
     * This can be used to ensure that all connections have been closed gracefully before destroying a stack
     * (or exiting the application). Destroying a stack while it is not quiescent is permitted by the API,
     * but when doing so there is no guarantee that sent data has been acknowledged by the peer or even transmitted,
     * and there is the possibility that peers' connections will be reset.
     */
    bool isQuiescent() const ONIXS_B3_BOE_OVERRIDE {
        return isQuiescentImpl();
    }

    /**
     * \return the ID of the thread that created the stack.
     */
    Threading::ThreadId workingThreadId() const ONIXS_B3_BOE_NOTHROW ONIXS_B3_BOE_OVERRIDE {
        return threadId_;
    }

    ReactorType::Enum type() const ONIXS_B3_BOE_NOTHROW ONIXS_B3_BOE_OVERRIDE {
        return ReactorType::TcpStandard;
    }

private:
    void dispatchEventsImpl();

    bool isQuiescentImpl() const;

    class Impl;
    Impl * const impl_;

    Threading::ThreadId const threadId_;

#if !defined(ONIXS_B3_BOE_CXX11)
    TcpStandardStack(const TcpStandardStack &);
    TcpStandardStack & operator=(const TcpStandardStack &);
#endif

    friend class SessionImpl;
};


===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/B3BOE.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/BOE/ABI.h>
#include <OnixS/B3/BOE/Compiler.h>
#include <OnixS/B3/BOE/Defines.h>
#include <OnixS/B3/BOE/Messaging.h>
#include <OnixS/B3/BOE/Session.h>
#include <OnixS/B3/BOE/SessionException.h>
#include <OnixS/B3/BOE/SessionListener.h>
#include <OnixS/B3/BOE/SessionSettings.h>
#include <OnixS/B3/BOE/SessionStateId.h>
#include <OnixS/B3/BOE/SessionStorage.h>
#include <OnixS/B3/BOE/SessionReactor.h>
#include <OnixS/B3/BOE/ThreadingModel.h>
#include <OnixS/B3/BOE/TcpDirectAttr.h>
#include <OnixS/B3/BOE/TcpDirectStack.h>
#include <OnixS/B3/BOE/TcpStandardStack.h>
#include <OnixS/B3/BOE/TcpInfo.h>

#include <OnixS/B3/BOE/encoding/Base64Encoding.h>

#include <OnixS/B3/BOE/Messaging.h>

#include <OnixS/B3/BOE/scheduling/SessionConnectionSettings.h>
#include <OnixS/B3/BOE/scheduling/SessionSchedule.h>
#include <OnixS/B3/BOE/scheduling/SessionScheduler.h>

#include <OnixS/B3/BOE/testing/ABI.h>
#include <OnixS/B3/BOE/testing/ClientMessageListener.h>
#include <OnixS/B3/BOE/testing/Gateway.h>
#include <OnixS/B3/BOE/testing/MessagePtr.h>

#include <OnixS/B3/BOE/threading/Condition.h>
#include <OnixS/B3/BOE/threading/Definitions.h>
#include <OnixS/B3/BOE/threading/Guard.h>
#include <OnixS/B3/BOE/threading/Mutex.h>
#include <OnixS/B3/BOE/threading/Semaphore.h>
#include <OnixS/B3/BOE/threading/Thread.h>

//#include <OnixS/B3/BOE/tools/AuditTrailGenerator.h>
#include <OnixS/B3/BOE/tools/Nic.h>

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/Compiler.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#if !(defined(ONIXS_B3_BOE_DOXYGEN) && ONIXS_B3_BOE_DOXYGEN)

#include <OnixS/B3/BOE/CompilerDetection.h>

#if defined(ONIXS_B3_BOE_COMPILER_IS_Clang)
#define ONIXS_B3_BOE_PADDING(size) __attribute__((__unused__)) char padding[size]
#else
#define ONIXS_B3_BOE_PADDING(size) char padding[size]
#endif

#if defined(_MSC_VER) && defined(_MSVC_LANG)
#  define ONIXS_CURRENT_CXX_STD _MSVC_LANG
#else
#  define ONIXS_CURRENT_CXX_STD __cplusplus
#endif

# if defined(ONIXS_B3_BOE_CXX11)
#  if (ONIXS_CURRENT_CXX_STD < 201103L)
#   error C++11 was targeted during the OnixS SDK compilation but is not detected now
#   define ONIXS_TERMINATE_COMPILATION
#  endif
# endif

# if defined(ONIXS_B3_BOE_CXX14)
#  if (ONIXS_CURRENT_CXX_STD < 201402L)
#   error C++14 was targeted during the OnixS SDK compilation but is not detected now
#   define ONIXS_TERMINATE_COMPILATION
#  endif
# endif

# if defined(ONIXS_B3_BOE_CXX17)
#  if (ONIXS_CURRENT_CXX_STD < 201703L)
#   error C++17 was targeted during the OnixS SDK compilation but is not detected now
#   define ONIXS_TERMINATE_COMPILATION
#  endif
# endif

# if defined(ONIXS_B3_BOE_CXX20)
#  if !(ONIXS_CURRENT_CXX_STD > 201703L)
#   error C++20 was targeted during the OnixS SDK compilation but is not detected now
#   define ONIXS_TERMINATE_COMPILATION
#  endif
# endif

# if defined(ONIXS_TERMINATE_COMPILATION)
#  include <termnate_compilation>
#endif

# if defined(ONIXS_B3_BOE_COMPILER_IS_GNU) | defined(ONIXS_B3_BOE_COMPILER_IS_Clang)
#  define ONIXS_B3_BOE_COMPILER_IS_GNU_or_Clang
# endif

# if defined(ONIXS_B3_BOE_COMPILER_IS_GNU_or_Clang)

#  define ONIXS_B3_BOE_LIKELY(cond) (__builtin_expect((static_cast<bool>((cond))), true))
#  define ONIXS_B3_BOE_UNLIKELY(cond) (__builtin_expect((static_cast<bool>((cond))), false))
#  define ONIXS_B3_BOE_UNUSED __attribute__((__unused__))
#  define ONIXS_B3_BOE_MAY_ALIAS __attribute__((__may_alias__))
#  define ONIXS_B3_BOE_HOTPATH __attribute__((hot))
#  define ONIXS_B3_BOE_COLDPATH __attribute__((noinline,cold))
#  define ONIXS_B3_BOE_NORETURN __attribute__ ((__noreturn__))
#  define ONIXS_B3_BOE_NODISCARD __attribute__((warn_unused_result))
#  define ONIXS_B3_BOE_PURE

#elif defined(ONIXS_B3_BOE_COMPILER_IS_MSVC)

#  define ONIXS_B3_BOE_LIKELY(cond) ((cond))
#  define ONIXS_B3_BOE_UNLIKELY(cond) ((cond))
#  define ONIXS_B3_BOE_PURE
#  define ONIXS_B3_BOE_UNUSED
#  define ONIXS_B3_BOE_MAY_ALIAS
#  define ONIXS_B3_BOE_HOTPATH
#  define ONIXS_B3_BOE_COLDPATH
#  define ONIXS_B3_BOE_NORETURN __declspec(noreturn)
#  define ONIXS_B3_BOE_NODISCARD _Check_return_

#else
#  error Unsupported compiler
#endif

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/Version.h =====
/**
 * \file
 *
 * \todo Generate this file using CMake!
 */
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable OnixS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once
#include <string>

#include <OnixS/B3/BOE/ABI.h>

namespace OnixS {
namespace B3 {
namespace BOE {

const std::string B3_BOE_HANDLER_VERSION("1.3.0");

}
}
}

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/Export.h =====

#ifndef ONIXS_B3_BOE_EXPORTED_H
#define ONIXS_B3_BOE_EXPORTED_H

#ifdef ONIXS_B3_BOE_AS_STATIC_LIB
#  define ONIXS_B3_BOE_EXPORTED
#  define ONIXS_B3_BOE_INTERNAL
#else
#  ifndef ONIXS_B3_BOE_EXPORTED
#    ifdef b3_boe_EXPORTS
        /* We are building this library */
#      define ONIXS_B3_BOE_EXPORTED __attribute__((visibility("default")))
#    else
        /* We are using this library */
#      define ONIXS_B3_BOE_EXPORTED __attribute__((visibility("default")))
#    endif
#  endif

#  ifndef ONIXS_B3_BOE_INTERNAL
#    define ONIXS_B3_BOE_INTERNAL __attribute__((visibility("hidden")))
#  endif
#endif

#ifndef ONIXS_B3_BOE_DEPRECATED
#  define ONIXS_B3_BOE_DEPRECATED __attribute__ ((__deprecated__))
#endif

#ifndef ONIXS_B3_BOE_DEPRECATED_EXPORT
#  define ONIXS_B3_BOE_DEPRECATED_EXPORT ONIXS_B3_BOE_EXPORTED ONIXS_B3_BOE_DEPRECATED
#endif

#ifndef ONIXS_B3_BOE_DEPRECATED_NO_EXPORT
#  define ONIXS_B3_BOE_DEPRECATED_NO_EXPORT ONIXS_B3_BOE_INTERNAL ONIXS_B3_BOE_DEPRECATED
#endif

/* NOLINTNEXTLINE(readability-avoid-unconditional-preprocessor-if) */
#if 0 /* DEFINE_NO_DEPRECATED */
#  ifndef ONIXS_B3_BOE_NO_DEPRECATED
#    define ONIXS_B3_BOE_NO_DEPRECATED
#  endif
#endif

#endif /* ONIXS_B3_BOE_EXPORTED_H */

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/ABI.h =====
#pragma once
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#include <OnixS/B3/BOE/Export.h>
#include <OnixS/B3/BOE/Compiler.h>

#if defined (_MSC_VER)

#define ONIXS_B3_BOE_API_DECL(typeKind, typeName) \
    typeKind ONIXS_B3_BOE_EXPORTED typeName
#else
#define ONIXS_B3_BOE_API_DECL(typeKind, typeName) \
    typeKind typeName
#endif

// Common part of export-related decorations.

#define \
    ONIXS_B3_BOE_EXPORTED_CLASS_DECL(typeName) \
    ONIXS_B3_BOE_EXPORTED_DECL(class, typeName)

#define \
    ONIXS_B3_BOE_EXPORTED_STRUCT_DECL(typeName) \
    ONIXS_B3_BOE_EXPORTED_DECL(struct, typeName)

#define \
    ONIXS_B3_BOE_EXPORTED_CLASS \
    class ONIXS_B3_BOE_EXPORTED

#define \
    ONIXS_B3_BOE_EXPORTED_STRUCT \
    struct ONIXS_B3_BOE_EXPORTED

#define \
    ONIXS_B3_BOE_INTERNAL_CLASS_DECL(typeName) \
    class typeName

#define \
    ONIXS_B3_BOE_INTERNAL_STRUCT_DECL(typeName) \
    struct typeName

#if defined (ONIXS_B3_BOE_LTWT_AS_EXPORTED)

#define \
    ONIXS_B3_BOE_LTWT_CLASS \
    ONIXS_B3_BOE_EXPORTED_CLASS

#define \
    ONIXS_B3_BOE_LTWT_STRUCT \
    ONIXS_B3_BOE_EXPORTED_STRUCT

#define \
    ONIXS_B3_BOE_LTWT_EXPORTED \
    /* Nothing */

#define \
    ONIXS_B3_BOE_LTWT_CLASS_DECL(name) \
    ONIXS_B3_BOE_EXPORTED_CLASS_DECL(name)

#define \
    ONIXS_B3_BOE_LTWT_STRUCT_DECL(name) \
    ONIXS_B3_BOE_EXPORTED_STRUCT_DECL(name)

#else

#define \
    ONIXS_B3_BOE_LTWT_CLASS \
    class ONIXS_B3_BOE_GCC44_SPURIOUS_WARNING_TURNAROUND

#define \
    ONIXS_B3_BOE_LTWT_STRUCT \
    struct ONIXS_B3_BOE_GCC44_SPURIOUS_WARNING_TURNAROUND

#define \
    ONIXS_B3_BOE_LTWT_EXPORTED \
    ONIXS_B3_BOE_EXPORTED

#define \
    ONIXS_B3_BOE_LTWT_CLASS_DECL(name) \
    class name

#define \
    ONIXS_B3_BOE_LTWT_STRUCT_DECL(name) \

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/TcpDirectAttr.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable OnixS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/BOE/ABI.h>

#include <string>
#include <stdint.h>

namespace OnixS {
namespace B3 {
namespace BOE {

// Forward declarations
class TcpDirectStack;

/**
* TCPDirect Attributes to pass configuration details (a wrapper around the `zf_attr` struct).
*
* The default values for attributes may be overridden by setting the
* environment variable `ZF_ATTR`.  For example:
*
* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.sh}
* ZF_ATTR="interface=enp4s0f0;log_level=3;reactor_spin_count=1"
* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/
class ONIXS_B3_BOE_EXPORTED TcpDirectAttr
{
public:
    /** Allocates an attribute object.
    *
    * \throws std::bad_alloc if memory could not be allocated.
    * \throws std::runtime_error if the `ZF_ATTR` environment variable is malformed.
    */
    TcpDirectAttr();

    ~TcpDirectAttr();

    TcpDirectAttr(const TcpDirectAttr & other);

    TcpDirectAttr & operator=(const TcpDirectAttr & other);

    /** Gets a string attribute.
    *
    * \param name Name of the attribute.
    *
    * \throws std::logic_error If @p name is not a valid attribute name or if @p name does not have a string type.
    */
    std::string getString(const std::string & name);

    /** Sets the attribute to the given value.
    *
    * \param name Name of the attribute.
    * \param value New value for the attribute (may be NULL).
    *
    * \throws std::logic_error If @p name is not a valid attribute name or if the attribute is not a string attribute.
    */
    void set(const std::string & name, const std::string & value);

    /** Gets an integer attribute.
    *
    * \param name Name of the attribute.
    *
    * \throws std::logic_error If @p name is not a valid attribute name or if @p name does not have an integer type.
    */
    int64_t getInt(const std::string & name);

    /** Sets the attribute to the given value.
    *
    * \param name Name of the attribute.
    * \param value New value for the attribute.
    *
    * \throws std::logic_error If @p name is not a valid attribute name.
    * \throws std::domain_error If @p value is not within the range of values this attribute can take.
    */
    void set(const std::string & name, uint64_t value);

private:
    class Impl;
    Impl * const impl_;

    friend class TcpDirectStack;
};

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/Messaging.h =====
#pragma once
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
// and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable OnixS Software
// Services Agreement (the Agreement) and Customer end user license agreements granting
// a non-assignable, non-transferable and non-exclusive license to use the software
// for it's own data processing purposes under the terms defined in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
// of this source code or associated reference material to any other location for further reproduction
// or redistribution, and any amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in accordance with
// the terms of the Agreement is a violation of copyright law.
//

#include <OnixS/B3/BOE/Defines.h>

#include <OnixS/B3/BOE/messaging/Aliases.h>
#include <OnixS/B3/BOE/messaging/Decimal.h>
#include <OnixS/B3/BOE/messaging/Decimal.Operations.h>
#include <OnixS/B3/BOE/messaging/Integral.h>
#include <OnixS/B3/BOE/messaging/MessageBatch.h>
#include <OnixS/B3/BOE/messaging/MessageHolder.h>
#include <OnixS/B3/BOE/messaging/MessageSizeTraits.h>
#include <OnixS/B3/BOE/messaging/Serialization.h>
#include <OnixS/B3/BOE/messaging/StrRef.h>
#include <OnixS/B3/BOE/messaging/Watch.h>
#include <OnixS/B3/BOE/messaging/Composites.h>
#include <OnixS/B3/BOE/messaging/Fields.h>
#include <OnixS/B3/BOE/messaging/MaxMessageSize.h>
#include <OnixS/B3/BOE/messaging/MessageSerialization.h>
#include <OnixS/B3/BOE/messaging/SbeMessage.h>
#include <OnixS/B3/BOE/messaging/SimpleOpenFramingHeader.h>
#include <OnixS/B3/BOE/messaging/Time.h>
#include <OnixS/B3/BOE/messaging/Decimal.h>
#include <OnixS/B3/BOE/messaging/Memory.h>
#include <OnixS/B3/BOE/messaging/Messages.h>
#include <OnixS/B3/BOE/messaging/SchemaTraits.h>
#include <OnixS/B3/BOE/messaging/String.h>
#include <OnixS/B3/BOE/messaging/Typification.h>
#include <OnixS/B3/BOE/messaging/Validation.h>
#include <OnixS/B3/BOE/messaging/NetworkMessage.h>

namespace OnixS {
namespace B3 {
namespace BOE {

typedef Messaging::UInt32 SeqNumber;

struct SeqNumberTraits {
    static ONIXS_B3_BOE_CONST_OR_CONSTEXPR SeqNumber Zero = 0;
    static ONIXS_B3_BOE_CONST_OR_CONSTEXPR SeqNumber InvalidValue = SeqNumber(-1);

    ONIXS_B3_BOE_CONSTEXPR
    static bool isValid(SeqNumber seqNumber) ONIXS_B3_BOE_NOTHROW {
        return seqNumber != InvalidValue;
    }
};

}
}
}

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/tools/Nic.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/
#pragma once

#include <OnixS/B3/BOE/ABI.h>

namespace OnixS {
namespace B3 {
namespace BOE {
namespace Tools {

/// Network interface card helpers.
struct Nic
{
    /// Sets hardware timestamping for the given network interface card.

    /// \param nicName name of the network interface card.
    /// \param setRx enable rx timestamping
    /// \throw std::exception in case of failure.

    /// \note: available on Linux only.
    /// \note: requires root privileges
    ONIXS_B3_BOE_EXPORTED
    static void setHardwareTimestamp(const char* nicName, bool setRx);
};

}}}}

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/tools/AuditTrailGenerator.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/
#pragma once

#include <OnixS/B3/BOE/messaging/Time.h>

namespace OnixS {
namespace B3 {
namespace BOE {
namespace Tools {

/// Audit Trail Spreadsheet Generator
class ONIXS_B3_BOE_EXPORTED AuditTrailGenerator
{
public:
    /**
    * Constructor.
    *
    * \param fileName A log file file to analyze.
    * \param cmeTradeDayStartTimeUtc Trade day start time in UTC.
    * \param outputFieldDelimiter Output field delimiter.
    * \param outputFilenameExtension Output filename extension.
    */
    AuditTrailGenerator(
        const std::string& fileName
      , const Messaging::Timestamp& cmeTradeDayStartTimeUtc = Messaging::Timestamp(1970, Messaging::Month::January, 1, 0, 0, 0)
      , char outputFieldDelimiter = ','
      , const char* outputFilenameExtension = "csv"
    );

    /**
    * Constructor.
    *
    * \param fileName A log file to analyze.
    * \param outputPath Output file path.
    * \param outputBaseName Output file base name.
    * \param cmeTradeDayStartTimeUtc Trade day start time in UTC.
    * \param outputFieldDelimiter Output field delimiter.
    * \param outputFilenameExtension Output filename extension.
    */
    AuditTrailGenerator(
        const std::string& fileName
        , const std::string& outputPath
        , const std::string& outputBaseName
        , const Messaging::Timestamp& cmeTradeDayStartTimeUtc = Messaging::Timestamp(1970, Messaging::Month::January, 1, 0, 0, 0)
        , char outputFieldDelimiter = ','
        , const char* outputFilenameExtension = "csv"
    );

    /// Generate the output.
    void generate();

    ///
    ~AuditTrailGenerator();

private:
    struct Impl;
    Impl* const impl_;
};

}}}}

===== FILE: ./external/B3/BOE/include/OnixS/B3/BOE/TcpDirectStack.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable OnixS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/BOE/SessionReactor.h>
#include <OnixS/B3/BOE/TcpDirectAttr.h>
#include <OnixS/B3/BOE/threading/Thread.h>

#include <cassert>

namespace OnixS {
namespace B3 {
namespace BOE {

/**
* A high-level wrapper over the TCPDirect network stack.
*/
class ONIXS_B3_BOE_EXPORTED TcpDirectStack ONIXS_B3_BOE_FINAL : public SessionReactor
{
public:
    /** Allocates a stack with the supplied attributes.
    *
    * \param attr A set of properties to apply to the stack.
    *
    * A stack binds to a single network interface, specified by the `interface` attribute in @p attr.
    *
    * Relevant attributes to set in @p attr are those in the `zf_stack`,
    * `zf_pool` and `zf_vi` categories described in the attributes documentation.
    *
    * \throws std::bad_alloc Out of memory. N.B. TCPDirect API requires huge pages.
    * \throws std::runtime_error the TCPDirect library reported an error, see the error text.
    * \throws std::exception System call reported an error, see the error text.
    */
    explicit TcpDirectStack(const TcpDirectAttr & attr);

# if defined(ONIXS_B3_BOE_CXX11)
    TcpDirectStack(const TcpDirectStack &) = delete;
    TcpDirectStack & operator=(const TcpDirectStack &) = delete;
    TcpDirectStack(TcpDirectStack &&) = delete;
    TcpDirectStack & operator=(TcpDirectStack &&) = delete;
#endif

    ~TcpDirectStack() ONIXS_B3_BOE_OVERRIDE;

    /**
     * This function processes events on a stack and performs the necessary handling.
     *
     * These events, including transmit and receive events raised by the hardware,
     * and also software events such as TCP and FIXP timers.
     *
     * Please see the "Stack polling" section in the TCPDirect User Guide for further information.
     */
    void dispatchEvents() ONIXS_B3_BOE_NOTHROW ONIXS_B3_BOE_OVERRIDE {
        assert(workingThreadId() == Threading::ThisThread::id());
        dispatchEventsImpl();
    }

    /** \return a boolean value indicating whether a stack is quiescent.
     *
     * This can be used to ensure that all connections have been closed gracefully before destroying a stack
     * (or exiting the application). Destroying a stack while it is not quiescent is permitted by the API,
     * but when doing so there is no guarantee that sent data has been acknowledged by the peer or even transmitted,
     * and there is the possibility that peers' connections will be reset.
     *
     * \note When using the Windows TCPDirect emulator, destroying a stack while it is not quiescent may cause a memory leak.
     */
    bool isQuiescent() const ONIXS_B3_BOE_NOTHROW ONIXS_B3_BOE_OVERRIDE {
        assert(workingThreadId() == Threading::ThisThread::id());
        return isQuiescentImpl();
    }

    /// \return The Id of the thread that created the stack.
    Threading::ThreadId workingThreadId() const ONIXS_B3_BOE_NOTHROW ONIXS_B3_BOE_OVERRIDE {
        return workingThreadId_;
    }

    ReactorType::Enum type() const ONIXS_B3_BOE_NOTHROW ONIXS_B3_BOE_OVERRIDE {
        return ReactorType::TcpDirect;
    }

private:
    void dispatchEventsImpl() ONIXS_B3_BOE_NOTHROW;


===== FILE: ./external/B3/UMDF/samples/LogPlayer/LogPlayer.cpp =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#include "OnixS/B3/MarketData/UMDF/Handler.h"
#include "OnixS/B3/MarketData/UMDF/testing/LogPlayer.h"

#include <Common/Common.h>
#include <Common/Configuring.h>

//! [LogPlayerSample]

using namespace OnixS::B3::MarketData::UMDF;
using namespace OnixS::B3::MarketData::UMDF::Testing;

// Options.

class Configuration
    : public ChannelConfiguration
    , public ConnectivityConfiguration
{
public:
    Configuration(size_t qty, char** args)
        : ConfigurationBase(qty, args)
        , ChannelConfiguration(qty, args, 310)
        , ConnectivityConfiguration(qty, args)
    {
    }

    std::string logFile() const
    {
        return requiredArg<std::string>(options(), "log");
    }

    std::string ifA() const
    {
        return argOrDefault(options(), "ifA", NETWORK_INTERFACE_FOR_FEEDS_A);
    }

    std::string ifB() const
    {
        return argOrDefault(options(), "ifB", NETWORK_INTERFACE_FOR_FEEDS_B);
    }

    UInt32 sendDelay() const
    {
        return argOrDefault(options(), "sendDelay", 100);
    }

    bool useNaturalSendDelays() const
    {
        return exist(options(), "useNaturalSendDelays");
    }

    UInt32 sourceSwitchDelay() const
    {
        return argOrDefault(options(), "sourceSwitchDelay", 100000);
    }

    UInt32 packetsCount() const
    {
        return argOrDefault(options(), "packetsCount", 10000);
    }

    bool updateSendingTime() const
    {
        return exist(options(), "updateSendingTime");
    }

private:

    void showOptions(std::ostream& out) const ONIXS_B3_UMDF_MD_OVERRIDE
    {
        out << "  --log <file>" << std::endl
            << "\tTells to use the given log file. " << std::endl
            << std::endl;

        ChannelConfiguration::showOptions(out);
        ConnectivityConfiguration::showOptions(out);

        out << "  --ifA <interface>" << std::endl
            << "\tSpecifies a network interface for primary feeds. " << std::endl
            << std::endl
            << "  --ifB <interface>" << std::endl

===== FILE: ./external/B3/UMDF/samples/Common/Helpers.h =====
/*
 * Copyright Onix Solutions Limited [OnixS]. All rights reserved.
 *
 * This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
 * and international copyright treaties.
 *
 * Access to and use of the software is governed by the terms of the applicable ONIXS Software
 * Services Agreement (the Agreement) and Customer end user license agreements granting
 * a non-assignable, non-transferable and non-exclusive license to use the software
 * for it's own data processing purposes under the terms defined in the Agreement.
 *
 * Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
 * of this source code or associated reference material to any other location for further reproduction
 * or redistribution, and any amendments to this copyright notice, are expressly prohibited.
 *
 * Any reproduction or redistribution for sale or hiring of the Software not in accordance with
 * the terms of the Agreement is a violation of copyright law.
 */

#pragma once

//! [HelpersH]

#include <OnixS/B3/MarketData/UMDF/ABI.h>

#include <cstdio>
#include <fstream>

#ifdef _WIN32
#   include <conio.h>
#   include <ctype.h>
#else
#   include <pthread.h>
#   include <csignal>
#   include <cstdlib>
#   include <vector>
#endif

#ifdef __linux__
#include <sys/poll.h>
#else
#include <conio.h>
#endif

#ifndef _WIN32
// The code below illustrates how to manage signals:
// - Mask signals in all threads;
// - Start a separate thread to catch signals;
class SignalHelper
{
public:

    typedef std::vector<int> SuppressedSignals;

    static void manageLinuxSignals()
    {
        SuppressedSignals suppressedSignals;

        // Add signals we are waiting for.
        suppressedSignals.push_back(SIGPIPE);

        pthread_t signalThreadId;
        int status;

        // Mask signals in the primary thread.
        // Child threads will inherit this signal mask.
        sigemptyset(&signalSet());

        for (SuppressedSignals::const_iterator i = suppressedSignals.begin(), e = suppressedSignals.end(); i != e; ++i)
            sigaddset(&signalSet(), *i);

        status = pthread_sigmask(SIG_BLOCK, &signalSet(), ONIXS_B3_UMDF_MD_NULLPTR);

        if (status != 0)
            errorAbort(status, "Set signal mask");

        // Create the sigwait thread.
        status = pthread_create(&signalThreadId, ONIXS_B3_UMDF_MD_NULLPTR, signalWaiter, ONIXS_B3_UMDF_MD_NULLPTR);

        if (status != 0)
            errorAbort(status, "Create signalWaiter");
    }

    static void waitUntilSignal()
    {
        int signalNumber = 0;

        while (true)
        {
            sigwait (&signalSet(), &signalNumber);
            if (SIGINT == signalNumber)
            {
                printf ("Signal %d received, exit from waiting.\n", signalNumber);
                return;
            }
            else
                printf ("Signal %d received and suppressed.\n", signalNumber);
        }
    }


===== FILE: ./external/B3/UMDF/samples/Common/Common.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#if defined(_WIN32)
#  define _SCL_SECURE_NO_WARNINGS
#ifndef NOMINMAX
# define NOMINMAX
#endif
#  include <Windows.h>
#else
#  include <unistd.h>
#endif

#include <algorithm>
#include <map>
#include <vector>
#include <string>
#include <cassert>
#include <stdexcept>
#include <iostream>
#include <sstream>
#include <ostream>
#include <iomanip>
#include <fstream>
#include <limits>
#include <numeric>

#include <signal.h>

#include <OnixS/B3/MarketData/UMDF.h>

===== FILE: ./external/B3/UMDF/samples/Common/Defaults.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#define LICENSE_STORE_FOLDER "../../license"

#define SETTINGS_FOLDER "../Settings/"

#define CONNECTIVITY_CONFIGURATION_FILE SETTINGS_FOLDER "config.Test.xml"

// Override macros below to use particular network interface(s)
// where the Handler should listen to multicast market data.

#define NETWORK_INTERFACE_FOR_FEEDS_A ""
#define NETWORK_INTERFACE_FOR_FEEDS_B ""

===== FILE: ./external/B3/UMDF/samples/Common/Utils.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <Common/Common.h>
#include <Common/Defaults.h>

// Network-related helpers.

inline std::string getIfSetting(const std::string& iface, const std::string& setting)
{
    std::string settingPath;

    settingPath += "/proc/sys/net/ipv4/conf/";
    settingPath += iface;
    settingPath += "/";
    settingPath += setting;

    std::ifstream ifs(settingPath.c_str());

    if (!ifs)
    {
        return std::string();
    }
    else
    {
        std::string value;

        getline(ifs, value);

        return value;
    }
}

inline void checkReversePathFiltering(const std::string& iface)
{
    if (!iface.empty())
    {
        const char* settingName = "rp_filter";

        std::string filtering = getIfSetting(iface, settingName);

        std::string scopedIf;

        if (filtering.empty())
        {
            const char* defaultIf = "default";

            filtering = getIfSetting("default", settingName);

            scopedIf = defaultIf;
        }
        else
        {
            scopedIf = iface;
        }

        if (!filtering.empty() && filtering != "0")
        {
            std::cout << "WARNING: reverse path filtering "
                      << " is turned ON for [" << scopedIf
                      << "] interface(s). This can be a "
                         "reason of multicast data absence "
                         "on the application level. "
                      << std::endl
                      << std::endl;
        }
    }
}

inline void checkNetworkSettings(const std::string& feedANif, const std::string& feedBNif)
{
    if (feedANif.empty() && feedBNif.empty())
    {
        std::cout << "WARNING: Handler is configured to listen to market data "
                     "on all network interfaces. Linux platform configuration may "
                     "require exact network interface(s) to be specified to receive "
                     "multicast data successfully. Either define network interfaces "
                     "using application args (see command line options using --help "
                     "key) or edit definitions of the NETWORK_INTERFACE_FOR_FEEDS_A "
                     "and NETWORK_INTERFACE_FOR_FEEDS_B macros in the Common/Defaults.h"
                     ", whose values are used as defaults. "

===== FILE: ./external/B3/UMDF/samples/Common/Options.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <Common/Common.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Integral.h>

ONIXS_B3_UMDF_MD_NAMESPACE_BEGIN

using namespace OnixS::B3::MarketData::UMDF::Messaging;

typedef std::string Option;

typedef std::string OptionArg;

typedef std::vector<OptionArg> OptionArgs;

// Implements a carriage over command line arguments.
class ArgCarriage
{
public:
    ArgCarriage(size_t qty, char** args)
        : qty_(qty)
        , args_(args)
    {
    }

    // Checks whether the carriage is in a valid state.
    operator bool() const
    {
        return (0 < qty_);
    }

    // If valid, provides access to the argument
    // which the carriage currently points to.
    const char* operator*() const
    {
        assert(0 < qty_);

        return *args_;
    }

    // Advances the carriage to the next argument.
    void advance()
    {
        --qty_;
        ++args_;
    }

private:
    size_t qty_;
    char** args_;
};

inline void throwBadOption(const Char* arg)
{
    assert(ONIXS_B3_UMDF_MD_NULLPTR != arg);

    std::string issue;

    issue += "The given argument [";
    issue += arg;

    issue += "] does not represent an option which "
             "must begin with the '--' prefix. ";

    throw std::runtime_error(issue);
}

inline void throwDuplicatedOption(const Char* option)
{
    std::string issue;

    issue += "The given option [";
    issue += option;
    issue += "] is defined twice in the argument list. ";

    throw std::runtime_error(issue);
}

// Groups the command line arguments by options.
class Options

===== FILE: ./external/B3/UMDF/samples/Common/Configuring.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <Common/Common.h>
#include <Common/Defaults.h>
#include <Common/Options.h>

ONIXS_B3_UMDF_MD_NAMESPACE_BEGIN

// Configuration grouped by semantic/application basis.

class ConfigurationBase
{
public:
    bool show() const
    {
        return exist(options(), "help");
    }

    void show(std::ostream& out) const
    {
        out << "Options affecting application behavior: " << std::endl << std::endl;

        showOptions(out);

        out << "  --help" << std::endl << "\tDisplays this message. " << std::endl;
    }

    virtual ~ConfigurationBase() {}

protected:
    ConfigurationBase(size_t qty, char** args)
        : opts_(qty, args)
    {
    }

    const Options& options() const
    {
        return opts_;
    }

    virtual void showOptions(std::ostream&) const {}

private:
    Options opts_;
};

// Connectivity-related configuration parameters.

class ConnectivityConfiguration : public virtual ConfigurationBase
{
public:
    std::string connectivityFile() const
    {
        return argOrDefault(options(), "connectivity", CONNECTIVITY_CONFIGURATION_FILE);
    }

protected:
    ConnectivityConfiguration(size_t qty, char** args)
        : ConfigurationBase(qty, args)
    {
    }

    void showOptions(std::ostream& out) const ONIXS_B3_UMDF_MD_OVERRIDE
    {
        out << "  --connectivity <file>" << std::endl
            << "\tTells to use the given connectivity configuration file. " << std::endl
            << std::endl;
    }
};

// Feed-related configuration parameters.
class FeedConfiguration : public virtual ConfigurationBase
{
public:
    std::string ifA() const
    {
        return argOrDefault(options(), "ifA", NETWORK_INTERFACE_FOR_FEEDS_A);
    }

    std::string ifB() const

===== FILE: ./external/B3/UMDF/samples/Benchmark/MyListener.h =====
#pragma once
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

//! [MyListenerH]
#include <vector>

#include <OnixS/B3/MarketData/UMDF/ErrorListener.h>
#include <OnixS/B3/MarketData/UMDF/Messaging.h>
#include <OnixS/B3/MarketData/UMDF/MessageListener.h>
#include <OnixS/B3/MarketData/UMDF/WarningListener.h>
#include <OnixS/B3/MarketData/UMDF/OrderBookListener.h>
#include <OnixS/B3/MarketData/UMDF/Handler.h>

#define ONIXS_USE_HUGE_PAGE 1

#if ONIXS_USE_HUGE_PAGE
# ifndef _WIN32
#  include <sys/mman.h>
#  ifdef MAP_FAILED
#   undef MAP_FAILED
#  endif
# define MAP_FAILED reinterpret_cast<void*>(-1)
# endif
#endif

#ifndef MAP_HUGETLB
#  undef ONIXS_USE_HUGE_PAGE
#  define ONIXS_USE_HUGE_PAGE 0
#  undef MAP_FAILED
#endif

namespace Sample
{

    using namespace OnixS::B3::MarketData::UMDF;

    class Allocator
    {
    public:
        Allocator(size_t size);
        ~Allocator();

        void* allocate(size_t size);

        template <typename T>
        T* allocate(size_t n)
        {
            return static_cast<T*>(allocate(sizeof(T) * n));
        }

    private:
        void* init(size_t size);
        void fini(void* ptr);

        static void throwNoHugePage();
        static void throwAllocatorExhausted();

        const size_t size_;
        void* const chunk_;
        void* ptr_;
        size_t available_;
    };

    struct alignas(64) Marks
    {
        Timestamp receiveTime;
        Timestamp messageTime;
        Messaging::MessageTemplateId messageType = 0;
        Timestamp bookTime;
    };

    typedef unsigned long long Latency;
    typedef std::vector<Latency> Latencies;

    class MyListener :
        public MessageListener,
        public OrderBookListener,
        public WarningListener,
        public ErrorListener
    {
    public:
        /// Constructor
        MyListener( size_t packetsToProcess);

===== FILE: ./external/B3/UMDF/samples/Benchmark/Benchmark.cpp =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

//! [BenchmarkSample]
#include <iostream>

#include <Common/Configuring.h>
#include <Common/Options.h>
#include <Common/Utils.h>

#include "MyListener.h"

#include <OnixS/B3/MarketData/UMDF/Handler.h>
#include <OnixS/B3/MarketData/UMDF/HandlerSettings.h>

#define ONIXS_USE_EF_VI 0


using namespace OnixS::B3::MarketData::UMDF;
using Sample::MyListener;

typedef std::shared_ptr<OrderBookPool> OrderBookPoolPtr;

constexpr UInt32 MaxProcessedPackets = 1000000;

// Handles sample input parameters.
class Configuration
    : public ChannelConfiguration
    , public ConnectivityConfiguration
    , public FeedConfiguration
{
public:
    Configuration(size_t qty, Char** args)
        : ConfigurationBase(qty, args)
        , ChannelConfiguration(qty, args, 80)
        , ConnectivityConfiguration(qty, args)
        , FeedConfiguration(qty, args)
    {
    }

    UInt32 packetsCount() const
    {
        return argOrDefault(options(), "packetsCount", MaxProcessedPackets);
    }

    bool measureBookChanges() const
    {
        return exist(options(), "measureBookChanges");
    }

    UInt32 chunksLength() const
    {
        return argOrDefault<UInt32>(options(), "chunksLength", 2 * 1024 * 1024);
    }

    std::set<Messaging::SecurityID> instruments() const
    {
        return argSetOrDefault<Messaging::SecurityID>(options(), "instruments", 10018438);
    }

private:
    void showOptions(std::ostream& out) const ONIXS_B3_UMDF_MD_OVERRIDE
    {
        ChannelConfiguration::showOptions(out);

        out << "  --packetsCount <target>" << std::endl
            << "\tDefines the number of incremental packets to process. The MaxProcessedPackets value is used by default." << std::endl
            << std::endl;

        out << "  --instruments <list>" << std::endl
            << "\tA comma-separated list of `SecurityID`'s of interest." << std::endl
            << std::endl;

        out << "  --measureBookChanges" << std::endl
            << "\tMeasure book change latency." << std::endl
            << std::endl
            << "  --chunksLength <number>" << std::endl
            << "\tDefines the amount of memory chunks used for book building, see OrderBookPoolSettings::chunkLength." << std::endl
            << std::endl;


        ConnectivityConfiguration::showOptions(out);
        FeedConfiguration::showOptions(out);
    }

===== FILE: ./external/B3/UMDF/samples/Benchmark/MyListener.cpp =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

//! [MyListenerCpp]
#include <iostream>
#include <algorithm>
#include <iterator>

#include "MyListener.h"

#include <Common/Utils.h>

namespace Sample
{
    ONIXS_B3_UMDF_MD_COLDPATH
    void* Allocator::init(size_t size)
    {
        void* ptr = nullptr;

#ifdef _WIN32
        ptr = _aligned_malloc(size, 4096);
#else

#  if ONIXS_USE_HUGE_PAGE
        const int flags =  MAP_PRIVATE | MAP_ANONYMOUS | MAP_LOCKED | MAP_POPULATE | MAP_HUGETLB;

        ptr = mmap(nullptr, size, PROT_READ | PROT_WRITE, flags, -1, 0);

        if (ptr == MAP_FAILED)
            throwNoHugePage();
#  else
        if (0 != posix_memalign(&ptr, 4096, size))
            ptr = nullptr;
#  endif

#endif
        if (!ptr)
            throw std::bad_alloc();

#ifndef _WIN32
        ::madvise(ptr, size, MADV_SEQUENTIAL);
#endif

        return ptr;
    }

    ONIXS_B3_UMDF_MD_COLDPATH
    void Allocator::fini(void* ptr)
    {
#ifdef _WIN32
        _aligned_free(ptr);
#else
#  if ONIXS_USE_HUGE_PAGE
        munmap(ptr, size_);
# else
        free(ptr);
# endif
#endif
    }

    Allocator::Allocator(size_t size)
        : size_(size)
        , chunk_(init(size_))
        , ptr_(chunk_)
        , available_(size_)
    {
    }

    ONIXS_B3_UMDF_MD_COLDPATH
    Allocator::~Allocator()
    {
        fini(chunk_);
    }

    ONIXS_B3_UMDF_MD_COLDPATH
    void Allocator::throwNoHugePage()
    {
        struct Exception : public std::bad_alloc
        {
            const char* what() const throw() override
            {
                return
                    "Unable to allocate a huge page. "
                    "Please enable it on your system (sudo sysctl -w vm.nr_hugepages=N), "

===== FILE: ./external/B3/UMDF/samples/AllChannels/MyListener.h =====
#pragma once
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

//! [MyListenerH]
#include <fstream>

#include <OnixS/B3/MarketData/UMDF/ErrorListener.h>
#include <OnixS/B3/MarketData/UMDF/Messaging.h>
#include <OnixS/B3/MarketData/UMDF/MessageListener.h>
#include <OnixS/B3/MarketData/UMDF/WarningListener.h>
#include <OnixS/B3/MarketData/UMDF/OrderBookListener.h>

namespace Sample
{

    using namespace OnixS::B3::MarketData::UMDF;

    class MyListener :
        public MessageListener,
        public WarningListener,
        public ErrorListener,
        public OrderBookListener
    {
        public:
            /// Constructor
            MyListener();

            /// Inherited from Warning Listener
            /// Is called when the Warning condition is detected
            void onWarning (const std::string& reason) ONIXS_B3_UMDF_MD_FINAL;

            /// Inherited from Error Listener
            /// Notifications about errors
            void onError (ErrorCode::Enum code, const std::string& description) ONIXS_B3_UMDF_MD_FINAL;

            void onSequenceReset_1(const Messaging::SequenceReset_1, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onSequence_2(const Messaging::Sequence_2, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onEmptyBook_9(const Messaging::EmptyBook_9, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onChannelReset_11(const Messaging::ChannelReset_11, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onSecurityStatus_3(const Messaging::SecurityStatus_3, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onSecurityGroupPhase_10(const Messaging::SecurityGroupPhase_10, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onSecurityDefinition_12(const Messaging::SecurityDefinition_12, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;

            void onSnapshotFullRefresh_Header_30(const Messaging::SnapshotFullRefresh_Header_30, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onSnapshotFullRefresh_Orders_MBO_71(const Messaging::SnapshotFullRefresh_Orders_MBO_71, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;

            void onNews_5(const Messaging::News_5, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onClosingPrice_17(const Messaging::ClosingPrice_17, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onQuantityBand_21(const Messaging::QuantityBand_21, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onPriceBand_22(const Messaging::PriceBand_22, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;

            void onOpeningPrice_15(const Messaging::OpeningPrice_15, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onTheoreticalOpeningPrice_16(const Messaging::TheoreticalOpeningPrice_16, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onAuctionImbalance_19(const Messaging::AuctionImbalance_19, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onHighPrice_24(const Messaging::HighPrice_24, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onLowPrice_25(const Messaging::LowPrice_25, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onLastTradePrice_27(const Messaging::LastTradePrice_27, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onSettlementPrice_28(const Messaging::SettlementPrice_28, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onOpenInterest_29(const Messaging::OpenInterest_29, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onOrder_MBO_50(const Messaging::Order_MBO_50, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onDeleteOrder_MBO_51(const Messaging::DeleteOrder_MBO_51, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onMassDeleteOrders_MBO_52(const Messaging::MassDeleteOrders_MBO_52, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onTrade_53(const Messaging::Trade_53, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onForwardTrade_54(const Messaging::ForwardTrade_54, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onExecutionSummary_55(const Messaging::ExecutionSummary_55, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onExecutionStatistics_56(const Messaging::ExecutionStatistics_56, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onTradeBust_57(const Messaging::TradeBust_57, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;

            void onOrderBookChanged(const OrderBook& book, const Messaging::SbeMessage message) ONIXS_B3_UMDF_MD_FINAL;

            void onOrderBookUpdated(const OrderBook& book) ONIXS_B3_UMDF_MD_FINAL;
            void onOrderBookOutOfDate(const OrderBook& book) ONIXS_B3_UMDF_MD_FINAL;

        private:
        std::ofstream marketDataLog_;
    };

}
//! [MyListenerH]

===== FILE: ./external/B3/UMDF/samples/AllChannels/MyListener.cpp =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

//! [MyListenerCpp]
#include <iostream>

#include "MyListener.h"
#include <OnixS/B3/MarketData/UMDF/OrderBook.h>

namespace Sample
{
    MyListener::MyListener()
    {
        const std::string marketDataLogName = "logs/MarketData.txt";
        marketDataLog_.open (marketDataLogName.c_str() );

        if (!marketDataLog_)
            throw std::domain_error ("Cannot open " + marketDataLogName);
    }

    void MyListener::onWarning (const std::string& reason)
    {
        std::clog << "Warning occurred. Description: '" << reason << "'" << std::endl;
    }

    void MyListener::onError (ErrorCode::Enum code, const std::string& description)
    {
        std::clog << "Error occurred, errorCode = " << enumToString (code) << ". Description: '" << description << "'" << std::endl;
    }

    void MyListener::onSequenceReset_1(const Messaging::SequenceReset_1 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }

    void MyListener::onSequence_2(const Messaging::Sequence_2 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }

    void MyListener::onEmptyBook_9(const Messaging::EmptyBook_9 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }

    void MyListener::onChannelReset_11(const Messaging::ChannelReset_11 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }

    void MyListener::onSecurityStatus_3(const Messaging::SecurityStatus_3 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }

    void MyListener::onSecurityGroupPhase_10(const Messaging::SecurityGroupPhase_10 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }

    void MyListener::onSecurityDefinition_12(const Messaging::SecurityDefinition_12 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }

    void MyListener::onSnapshotFullRefresh_Header_30(const Messaging::SnapshotFullRefresh_Header_30 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }

    void MyListener::onSnapshotFullRefresh_Orders_MBO_71(const Messaging::SnapshotFullRefresh_Orders_MBO_71 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }

    void MyListener::onNews_5(const Messaging::News_5 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }

    void MyListener::onClosingPrice_17(const Messaging::ClosingPrice_17 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }

===== FILE: ./external/B3/UMDF/samples/AllChannels/AllChannels.cpp =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

//! [AllChannelsSample]
#include <iostream>

#include <Common/Configuring.h>
#include <Common/Options.h>
#include <Common/Utils.h>
#include <Common/Helpers.h>

#include <OnixS/B3/MarketData/UMDF.h>

#include "MyListener.h"


using namespace OnixS::B3::MarketData::UMDF;
using namespace OnixS::B3::MarketData::UMDF::Messaging;
using Sample::MyListener;

/////////////////////////////////////////////////////////////////////////////
typedef std::shared_ptr<Handler> HandlerPtr;
typedef std::shared_ptr<OrderBookPool> OrderBookPoolPtr;
typedef std::vector<HandlerPtr> Handlers;

void stopAndDeleteHandlers(Handlers& handlers)
{
    for (auto& handler : handlers)
        handler->stop(true);
    handlers.clear();
}

// Handles sample input parameters.
class Configuration
    : public ConnectivityConfiguration
    , public FeedConfiguration
{
public:
    Configuration(size_t qty, Char** args)
        : ConfigurationBase(qty, args)
        , ConnectivityConfiguration(qty, args)
        , FeedConfiguration(qty, args)
    {
    }

    bool buildBooks() const
    {
        return exist(options(), "buildBooks");
    }

    std::string logDir() const
    {
        return argOrDefault(options(), "logDir", "logs");
    }

private:
    void showOptions(std::ostream& out) const ONIXS_B3_UMDF_MD_OVERRIDE
    {
        ConnectivityConfiguration::showOptions(out);
        FeedConfiguration::showOptions(out);

        out << "  --buildBooks" << std::endl
            << "\tBuild order books. " << std::endl
            << std::endl;

        out << "  --logDir <directory>" << std::endl
            << "\tTells to use the given log directory. " << std::endl
            << std::endl;
    }
};

/// The main entry point.
int main(int qty, char** args)
{
    std::clog << "OnixS C++ B3 Binary UMDF Market Data Handler All Channels sample, version " << Handler::version() << '.' << std::endl << std::endl;

    try
    {
        manageLinuxSignals();

        const Configuration configuration(qty, args);

        if (configuration.show())
        {

===== FILE: ./external/B3/UMDF/samples/GettingStarted/GettingStarted.cpp =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

//! [GettingStartedSample]
#include <iostream>

#include <Common/Configuring.h>
#include <Common/Options.h>
#include <Common/Utils.h>

#include <OnixS/B3/MarketData/UMDF.h>

#include "MyListener.h"


using namespace OnixS::B3::MarketData::UMDF;
using Sample::MyListener;

/// Wait until the user presses the button
void waitUntilEnterKey ()
{
    std::string tmp;
    std::getline (std::cin, tmp);
}

// Handles sample input parameters.
class Configuration
    : public ChannelConfiguration
    , public ConnectivityConfiguration
    , public FeedConfiguration
{
public:
    Configuration(size_t qty, Char** args)
        : ConfigurationBase(qty, args)
        , ChannelConfiguration(qty, args, 80)
        , ConnectivityConfiguration(qty, args)
        , FeedConfiguration(qty, args)
    {
    }

private:
    void showOptions(std::ostream& out) const ONIXS_B3_UMDF_MD_OVERRIDE
    {
        ChannelConfiguration::showOptions(out);
        ConnectivityConfiguration::showOptions(out);
        FeedConfiguration::showOptions(out);
    }
};

/// The main entry point.
int main (int qty, char** args)
{
    std::clog << "OnixS C++ B3 Binary UMDF Market Data Handler Getting Started sample, version " << Handler::version() << '.' << std::endl << std::endl;

    const Configuration configuration(qty, args);

    if (configuration.show())
    {
        configuration.show(std::cout);
        return 0;
    }

    checkNetworkSettings(configuration);

    HandlerSettings handlerSettings;

    handlerSettings.licenseDirectory                           = "../../license";
    handlerSettings.loggerSettings.logDirectory                = "logs";
    handlerSettings.loggerSettings.logLevel                    = LogLevel::Debug;
    handlerSettings.buildOrderBooks = true;

    handlerSettings.loadFeeds(configuration.channel(), configuration.connectivityFile());

    handlerSettings.networkInterfaceA = configuration.ifA();
    handlerSettings.networkInterfaceB = configuration.ifB();

    try
    {
        MyListener myListener;

        Handler handler(handlerSettings);

        handler.registerWarningListener(&myListener);
        handler.registerErrorListener (&myListener);

===== FILE: ./external/B3/UMDF/samples/GettingStarted/MyListener.h =====
#pragma once
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

//! [MyListenerH]
#include <fstream>

#include <OnixS/B3/MarketData/UMDF/ErrorListener.h>
#include <OnixS/B3/MarketData/UMDF/Messaging.h>
#include <OnixS/B3/MarketData/UMDF/MessageListener.h>
#include <OnixS/B3/MarketData/UMDF/WarningListener.h>

namespace Sample
{

    using namespace OnixS::B3::MarketData::UMDF;

    class MyListener :
        public MessageListener,
        public WarningListener,
        public ErrorListener
    {
        public:
            /// Constructor
            MyListener();

            /// Inherited from Warning Listener
            /// Is called when the Warning condition is detected
            void onWarning (const std::string& reason)
            ONIXS_B3_UMDF_MD_FINAL;

            /// Inherited from Error Listener
            /// Notifications about errors
            void onError (ErrorCode::Enum code, const std::string& description)
            ONIXS_B3_UMDF_MD_FINAL;

            void onSequenceReset_1(const Messaging::SequenceReset_1, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onSequence_2(const Messaging::Sequence_2, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onEmptyBook_9(const Messaging::EmptyBook_9, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onChannelReset_11(const Messaging::ChannelReset_11, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onSecurityStatus_3(const Messaging::SecurityStatus_3, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onSecurityGroupPhase_10(const Messaging::SecurityGroupPhase_10, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onSecurityDefinition_12(const Messaging::SecurityDefinition_12, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;

            void onSnapshotFullRefresh_Header_30(const Messaging::SnapshotFullRefresh_Header_30, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onSnapshotFullRefresh_Orders_MBO_71(const Messaging::SnapshotFullRefresh_Orders_MBO_71, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;

            void onNews_5(const Messaging::News_5, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onClosingPrice_17(const Messaging::ClosingPrice_17, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onQuantityBand_21(const Messaging::QuantityBand_21, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onPriceBand_22(const Messaging::PriceBand_22, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;

            void onOpeningPrice_15(const Messaging::OpeningPrice_15, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onTheoreticalOpeningPrice_16(const Messaging::TheoreticalOpeningPrice_16, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onAuctionImbalance_19(const Messaging::AuctionImbalance_19, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onHighPrice_24(const Messaging::HighPrice_24, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onLowPrice_25(const Messaging::LowPrice_25, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onLastTradePrice_27(const Messaging::LastTradePrice_27, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onSettlementPrice_28(const Messaging::SettlementPrice_28, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onOpenInterest_29(const Messaging::OpenInterest_29, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onOrder_MBO_50(const Messaging::Order_MBO_50, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onDeleteOrder_MBO_51(const Messaging::DeleteOrder_MBO_51, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onMassDeleteOrders_MBO_52(const Messaging::MassDeleteOrders_MBO_52, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onTrade_53(const Messaging::Trade_53, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onForwardTrade_54(const Messaging::ForwardTrade_54, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onExecutionSummary_55(const Messaging::ExecutionSummary_55, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onExecutionStatistics_56(const Messaging::ExecutionStatistics_56, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;
            void onTradeBust_57(const Messaging::TradeBust_57, const DataSource&) ONIXS_B3_UMDF_MD_FINAL;

        private:
            std::ofstream marketDataLog_;
    };

}
//! [MyListenerH]

===== FILE: ./external/B3/UMDF/samples/GettingStarted/MyListener.cpp =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

//! [MyListenerCpp]
#include <iostream>

#include "MyListener.h"

namespace Sample
{
    MyListener::MyListener()
    {
        const std::string marketDataLogName = "logs/MarketData.txt";
        marketDataLog_.open (marketDataLogName.c_str() );

        if (!marketDataLog_)
            throw std::domain_error ("Cannot open " + marketDataLogName);
    }

    void MyListener::onWarning (const std::string& reason)
    {
        std::clog << "Warning occurred. Description: '" << reason << "'" << std::endl;
    }

    void MyListener::onError (ErrorCode::Enum code, const std::string& description)
    {
        std::clog << "Error occurred, errorCode = " << enumToString (code) << ". Description: '" << description << "'" << std::endl;
    }

    void MyListener::onSequenceReset_1(const Messaging::SequenceReset_1 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }

    void MyListener::onSequence_2(const Messaging::Sequence_2 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }

    void MyListener::onEmptyBook_9(const Messaging::EmptyBook_9 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }

    void MyListener::onChannelReset_11(const Messaging::ChannelReset_11 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }

    void MyListener::onSecurityStatus_3(const Messaging::SecurityStatus_3 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }

    void MyListener::onSecurityGroupPhase_10(const Messaging::SecurityGroupPhase_10 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }

    void MyListener::onSecurityDefinition_12(const Messaging::SecurityDefinition_12 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }


    void MyListener::onSnapshotFullRefresh_Header_30(const Messaging::SnapshotFullRefresh_Header_30 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }

    void MyListener::onSnapshotFullRefresh_Orders_MBO_71(const Messaging::SnapshotFullRefresh_Orders_MBO_71 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }


    void MyListener::onNews_5(const Messaging::News_5 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;
    }

    void MyListener::onClosingPrice_17(const Messaging::ClosingPrice_17 msg, const DataSource&)
    {
        marketDataLog_ << msg << std::endl;

===== FILE: ./external/B3/UMDF/samples/Backtesting/Backtesting.cpp =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

//! [BacktestingSample]
#include <iostream>

#include <OnixS/B3/MarketData/UMDF.h>

#include "OnixS/B3/MarketData/UMDF/Messaging.h"


using namespace OnixS::B3::MarketData::UMDF;

class MyListener
    : public ErrorListener
    , public WarningListener
    , public ReplayListener
    , public MessageListener
{

public:
    /// Notifications about errors.
    void onError(ErrorCode::Enum code, const std::string& description) ONIXS_B3_UMDF_MD_FINAL
    {
        std::clog
            << "Error occurred, errorCode = "
            << enumToString (code)
            << ". Description: '"
            << description
            << "'"
            << std::endl;
    }

    /// Notifications about warnings.
    void onWarning(const std::string& description) ONIXS_B3_UMDF_MD_FINAL
    {
        std::clog
            << "Warning occurred. Description: '"
            << description
            << "'"
            << std::endl;
    };

    void onReplayError(const std::string& errorDescription) ONIXS_B3_UMDF_MD_FINAL
    {
        std::clog << "Replay error: " << errorDescription << std::endl;
        replaySemaphore_.release();
    }

    void onReplayFinished() ONIXS_B3_UMDF_MD_FINAL
    {
        replaySemaphore_.release();
    }

    /// Wait for reference data snapshot cycle end.
    void waitUntilReplayFinished()
    {
        replaySemaphore_.acquire();
    }

    void onSequenceReset_1(const Messaging::SequenceReset_1 msg, const DataSource&) ONIXS_B3_UMDF_MD_FINAL
    {
        std::clog << msg << std::endl;
    }

    void onSequence_2(const Messaging::Sequence_2 msg, const DataSource&) ONIXS_B3_UMDF_MD_FINAL
    {
        std::clog << msg << std::endl;
    }

    void onEmptyBook_9(const Messaging::EmptyBook_9 msg, const DataSource&) ONIXS_B3_UMDF_MD_FINAL
    {
        std::clog << msg << std::endl;
    }

    void onChannelReset_11(const Messaging::ChannelReset_11 msg, const DataSource&) ONIXS_B3_UMDF_MD_FINAL
    {
        std::clog << msg << std::endl;
    }

    void onSecurityStatus_3(const Messaging::SecurityStatus_3 msg, const DataSource&) ONIXS_B3_UMDF_MD_FINAL
    {
        std::clog << msg << std::endl;
    }

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/Exception.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <exception>

#include <OnixS/B3/MarketData/UMDF/ABI.h>
#include <OnixS/B3/MarketData/UMDF/Compiler.h>


namespace OnixS
{
    namespace B3
    {
        namespace MarketData
        {
            namespace UMDF
            {
                /// Basic exception class for this namespace
                class ONIXS_B3_UMDF_MD_THROWABLE Exception: public std::exception
                {
                    public:
                        /// Constructor
                        Exception (const char* method_name, const char* message);

                        /// Copy constructor
                        Exception (const Exception&);

                        /// Destructor
                        ~Exception () ONIXS_B3_UMDF_MD_NOTHROW ONIXS_B3_UMDF_MD_OVERRIDE;

                        /// Assignment
                        Exception& operator = (const Exception&);

                        /// Returns information about error
                        const char* what () const ONIXS_B3_UMDF_MD_NOTHROW ONIXS_B3_UMDF_MD_OVERRIDE;

                        /// Add information about context of exception
                        void touch (const char* method_name);

                    private:
                        struct Implementation;

                        Implementation* impl_;
                };

                /// Argument value error
                class ONIXS_B3_UMDF_MD_THROWABLE ArgumentException: public Exception
                {
                    public:
                        /// Constructor
                        ArgumentException (const char* source, const char* message);

                        /// Constructor
                        ArgumentException (const char* source, const char* argument_name, const char* value, const char* comment = "");

                        /// Constructor
                        ArgumentException (const char* source, const char* argument_name, int value, const char* comment = "");

                        /// Constructor
                        ArgumentException (const char* source, const char* argument_name, unsigned int value, const char* comment = "");

                        /// Constructor
                        ArgumentException (const char* source, const char* argument_name, double value, const char* comment = "");
                };

                /// Operation exception
                class ONIXS_B3_UMDF_MD_THROWABLE OperationException: public Exception
                {
                    public:
                        /// Constructor
                        OperationException (const char* source, const char* message);
                };
            }
        }
    }
}

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/WarningListener.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>

#include <string>

namespace OnixS
{
    namespace B3
    {
        namespace MarketData
        {
            namespace UMDF
            {

                /// Warning listener.
                class ONIXS_B3_UMDF_MD_API WarningListener
                {
                    public:
                        /// Is called when the Warning condition is detected.
                        virtual void onWarning (const std::string& reason) = 0;

                    protected:
                        /// Destructor.
                        virtual ~WarningListener() {}
                };

            }
        }
    }
}

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/OrderBookListener.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>
#include <OnixS/B3/MarketData/UMDF/messaging/SbeMessage.h>

namespace OnixS
{
    namespace B3
    {
        namespace MarketData
        {
            namespace UMDF
            {
                ONIXS_B3_UMDF_MD_API_DECL (class, OrderBook);

                /// Order Book listener
                class ONIXS_B3_UMDF_MD_API OrderBookListener
                {
                    public:
                        /// Is called when the book is changed within it's depth, when Order_MBO_50, DeleteOrder_MBO_51 or MassDeleteOrders_MBO_52 are received.
                        virtual void onOrderBookChanged(const OrderBook& book, const Messaging::SbeMessage message) = 0;

                        /// Is called when the book is updated, when a message with MatchEventIndicator::EndOfEvent is received and the book was changed within it's depth.
                        virtual void onOrderBookUpdated (const OrderBook& book) = 0;

                        /// Is called when no data is coming during a reasonable
                        /// period of time. Since the moment of call books
                        /// must be considered outdated. Further
                        /// call of 'onOrderBookUpdated' members makes a particular
                        /// book as up-to-date.
                        virtual void onOrderBookOutOfDate (const OrderBook& book) = 0;

                    protected:
                        virtual ~OrderBookListener() {}
                };
            }
        }
    }
}

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/CompilerDetection.h =====
#pragma once

#define ONIXS_B3_UMDF_MD_COMPILER_IS_GNU
#define ONIXS_B3_UMDF_MD_CXX11
#define ONIXS_B3_UMDF_MD_CXX14
#define ONIXS_B3_UMDF_MD_CXX17

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/MessageListener.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/MarketData/UMDF/messaging/Messages.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Forwards.h>
#include <OnixS/B3/MarketData/UMDF/Defines.h>

namespace OnixS {
namespace B3 {
namespace MarketData {
namespace UMDF {

    /// Message listener
    class ONIXS_B3_UMDF_MD_API MessageListener
    {
        public:
            virtual void onSequenceReset_1(const Messaging::SequenceReset_1, const DataSource&) {}
            virtual void onSequence_2(const Messaging::Sequence_2, const DataSource&) {}
            virtual void onEmptyBook_9(const Messaging::EmptyBook_9, const DataSource&) {}
            virtual void onChannelReset_11(const Messaging::ChannelReset_11, const DataSource&) {}
            virtual void onSecurityStatus_3(const Messaging::SecurityStatus_3, const DataSource&) {}
            virtual void onSecurityGroupPhase_10(const Messaging::SecurityGroupPhase_10, const DataSource&) {}
            virtual void onSecurityDefinition_12(const Messaging::SecurityDefinition_12, const DataSource&) {}

            virtual void onSnapshotFullRefresh_Header_30(const Messaging::SnapshotFullRefresh_Header_30, const DataSource&) {}
            virtual void onSnapshotFullRefresh_Orders_MBO_71(const Messaging::SnapshotFullRefresh_Orders_MBO_71, const DataSource&) {}

            virtual void onNews_5(const Messaging::News_5, const DataSource&) {}
            virtual void onClosingPrice_17(const Messaging::ClosingPrice_17, const DataSource&) {}
            virtual void onQuantityBand_21(const Messaging::QuantityBand_21, const DataSource&) {}
            virtual void onPriceBand_22(const Messaging::PriceBand_22, const DataSource&) {}

            virtual void onOpeningPrice_15(const Messaging::OpeningPrice_15, const DataSource&) {}
            virtual void onTheoreticalOpeningPrice_16(const Messaging::TheoreticalOpeningPrice_16, const DataSource&) {}
            virtual void onAuctionImbalance_19(const Messaging::AuctionImbalance_19, const DataSource&) {}
            virtual void onHighPrice_24(const Messaging::HighPrice_24, const DataSource&) {}
            virtual void onLowPrice_25(const Messaging::LowPrice_25, const DataSource&) {}
            virtual void onLastTradePrice_27(const Messaging::LastTradePrice_27, const DataSource&) {}
            virtual void onSettlementPrice_28(const Messaging::SettlementPrice_28, const DataSource&) {}
            virtual void onOpenInterest_29(const Messaging::OpenInterest_29, const DataSource&) {}
            virtual void onOrder_MBO_50(const Messaging::Order_MBO_50, const DataSource&) {}
            virtual void onDeleteOrder_MBO_51(const Messaging::DeleteOrder_MBO_51, const DataSource&) {}
            virtual void onMassDeleteOrders_MBO_52(const Messaging::MassDeleteOrders_MBO_52, const DataSource&) {}
            virtual void onTrade_53(const Messaging::Trade_53, const DataSource&) {}
            virtual void onForwardTrade_54(const Messaging::ForwardTrade_54, const DataSource&) {}
            virtual void onExecutionSummary_55(const Messaging::ExecutionSummary_55, const DataSource&) {}
            virtual void onExecutionStatistics_56(const Messaging::ExecutionStatistics_56, const DataSource&) {}
            virtual void onTradeBust_57(const Messaging::TradeBust_57, const DataSource&) {}

            virtual void onUnknownMessage(const Messaging::SbeMessage, const DataSource&) {}

            virtual void onInstrumentChannelGap() {}
            virtual void onInstrumentChannelInactivity() {}
            virtual void onInstrumentRecoveryStarted() {}
            virtual void onInstrumentRecoveryFinished() {}

            virtual void onSnapshotChannelGap() {}
            virtual void onSnapshotChannelInactivity() {}
            virtual void onSnapshotRecoveryStarted() {}
            virtual void onSnapshotRecoveryFinished() {}

            virtual void onIncrementalChannelGap() {}
            virtual void onIncrementalChannelInactivity() {}

            virtual void onInstrumentSequenceGap(Messaging::SecurityID) {}

        protected:
            virtual ~MessageListener() = 0;
    };
}
}
}
}

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/Handler.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <unordered_set>
#include <vector>

#include <OnixS/B3/MarketData/UMDF/ABI.h>
#include <OnixS/B3/MarketData/UMDF/LogSettings.h>
#include <OnixS/B3/MarketData/UMDF/HandlerStateListener.h>
#include <OnixS/B3/MarketData/UMDF/Replay.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Fields.h>

namespace OnixS
{
    namespace B3
    {
        namespace MarketData
        {
            namespace UMDF
            {
                namespace Implementation { struct ReplayHelper; }
                class ErrorListener;
                class FeedEngine;
                class WarningListener;
                class MessageListener;
                class OrderBookListener;

                struct HandlerSettings;

                /// B3 Binary UMDF Market Data Handler class.
                class ONIXS_B3_UMDF_MD_API Handler
                {
                    public:
                        /// Performs instance initialization.
                        /// @param settings defines values for various options
                        /// which affect handler behavior like enabling logging
                        /// during execution of the handler.
                        explicit
                        Handler (const HandlerSettings& settings);

                        /// Finalizes the Handler.
                        virtual ~Handler();

                        /// Assigns listener for errors occurred while executing handler.
                        /// It's permissible to change the listener multiple times during
                        /// handler's life-time, but only when it is in disconnected state.
                        /// @throw OperationException if handler not disconnected
                        void registerErrorListener (ErrorListener* listener);

                        /// Assigns listener for warnings occurred while executing handler.
                        /// It's permissible to change the listener multiple times during
                        /// handler's life-time, but only when it is in disconnected state.
                        /// @throw OperationException if handler not disconnected
                        void registerWarningListener (WarningListener* listener);

                        /// Assigns listener for state change events occurred while executing handler.
                        /// It's permissible to change the listener multiple times during
                        /// handler's life-time, but only when it is in disconnected state.
                        /// @throw OperationException if handler not disconnected.
                        void registerHandlerStateListener (HandlerStateListener* listener);

                        /// Assigns listener to receive notifications when market data messages are received while executing handler.
                        /// It's permissible to change the listener multiple times during
                        /// handler's life-time, but only when it is in disconnected state.
                        /// @throw OperationException if handler not disconnected.
                        void registerMessageListener (MessageListener* listener);

                        /// Assigns listener to receive notification about order book states while executing handler.
                        /// It's permissible to change the listener multiple times during
                        /// handler's life-time, but only when it is in disconnected state.
                        /// @throw OperationException if handler not disconnected.
                        void registerOrderBookListener (OrderBookListener* listener);

                        /// Start handler.
                        ///
                        /// @note This action is asynchronous.
                        /// @throw std::exception in case of unable to start.
                        void start ();

                        /// Stop handler.
                        void stop (bool wait);


===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/LogSettings.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by ONIX SOLUTIONS LIMITED [ONIXS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>

#include <string>

namespace OnixS
{
    namespace B3
    {
        namespace MarketData
        {
            namespace UMDF
            {

                /// Log level.
                struct ONIXS_B3_UMDF_MD_API LogLevel
                {
                    enum Enum
                    {
                        Disabled,   /// Logging disabled.
                        Error,      /// Error, cannot continue.
                        Warning,    /// Warning, can continue.
                        Info,       /// Information message.
                        Trace,      /// Used for tracing, usually including functions' names and args.
                        Debug,      /// Used for debugging.
                    };
                };

                /// Returns string representation of ErrorCode value.
                ONIXS_B3_UMDF_MD_API std::string enumToString (LogLevel::Enum);

                /// Logging options.
                struct ONIXS_B3_UMDF_MD_API LogSettings
                {
                    enum Enum
                    {
                        /// Trace to the log file.
                        TraceToFile = 0x01,

                        /// Duplicate log messages to console.
                        /// @note Messages with LogLevel::Trace and LogLevel::Debug are not duplicated to console.
                        TraceToConsole = 0x02,

                        /// Use asynchronous logging
                        Async = 0x4,

                        /// if TraceToConsole is set, then direct output to stderr
                        ConsoleErr = 0x8,

                        /// if TraceToConsole is set, then set up colored output mode
                        ConsoleColored = 0x10,

                        /// if TraceToConsole is set, then append prefix to output
                        ConsoleShowPrefix = 0x20,

                        /// Log binary data of received packets, applied only for Info log level and below.
                        LogPackets = 0x40,

                        /// Log updated order book, applied only for Debug log level.
                        LogBooks = 0x80,

                        /// Default log settings.
                        Default = TraceToFile | LogPackets | LogBooks
                    };
                };

                /// Typed logical operator helper.
                inline LogSettings::Enum operator| (LogSettings::Enum a, LogSettings::Enum b)
                {
                    return LogSettings::Enum ( static_cast<int>(a) | static_cast<int>(b));
                }


                /// Log file read permissions.
                struct ONIXS_B3_UMDF_MD_API LogFilePermission
                {
                    enum Enum
                    {
                        /// read access only for owner of process
                        ReadOwnerOnly = 0x01,

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/testing/LogPlayer.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <limits>
#include <string>

#include <OnixS/B3/MarketData/UMDF/ABI.h>
#include <OnixS/B3/MarketData/UMDF/Integral.h>

ONIXS_B3_UMDF_MD_TESTING_NAMESPACE_BEGIN

/// Identifies channel.
typedef UInt32 ChannelId;

struct FeedType {
    enum Enum
    {
        Unknown,

        Incremental,
        Instrument,
        Snapshot,
    };
};

/// LogPlayer's configuration settings.
ONIXS_B3_UMDF_MD_LTWT_CLASS LogPlayerSettings
{
public:
    /// Initializes parameters with default values.
    LogPlayerSettings()
    {
    }

    /// Cleans everything up.
    ~LogPlayerSettings() {}

    /// Path to the log file.
    const std::string& logFile() const
    {
        return logFile_;
    }

    /// Path to the log file.
    LogPlayerSettings& logFile(const std::string& file)
    {
        logFile_ = file;

        return *this;
    }

    /// Identifies CME market data channel.
    ChannelId channel() const
    {
        return channel_;
    }

    /// Identifies CME market data channel.
    LogPlayerSettings& channel(ChannelId value)
    {
        channel_ = value;
        return *this;
    }

    /// Path to the connectivity configuration file.
    const std::string& connectivityConfigurationFile() const
    {
        return configurationFile_;
    }

    /// Path to the connectivity configuration file from which
    /// to load feed connection settings.
    LogPlayerSettings& connectivityConfigurationFile(const std::string& configurationFile)
    {
        configurationFile_ = configurationFile;
    
        return *this;
    }

    /// Pause before sending data to the same source as it was sent before (in microseconds).
    unsigned sendDelay() const

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/Defines.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>
#include <OnixS/B3/MarketData/UMDF/Time.h>

#include <string>
#include <ostream>
#include <memory>
#include <set>

namespace OnixS
{
    namespace B3
    {
        namespace MarketData
        {
            namespace UMDF
            {
                typedef char Char;

                struct NoCheck {};

                /// Alias for Packet Sequence Number type (PSN).
                typedef UInt32 PacketSequenceNumber;

                /// Data source
                struct ONIXS_B3_UMDF_MD_API DataSource
                {
                    DataSource() {}
                    DataSource(Timestamp ts) noexcept : packetReceptionTime(ts) {}

                    enum Origin : UInt8
                    {
                        Instrument,
                        Incremental,
                        Snapshot,
                    };

                    /// Time when the packet was received by Handler from UDP, in system ticks, @see Time.h
                    Timestamp packetReceptionTime;

                    /// UTC date and time of packet transmission, in nanoseconds since Unix epoch (Jan 1st., 1970), with microsecond-level precision*.
                    UInt64 sendingTime;

                    /// Packet Sequence Number. Always incremented by one in the same channel and same SequenceVersion.
                    PacketSequenceNumber packetSequenceNumber;

                    /// Packet Sequence Version.
                    /// For incremental stream, it starts with 1 at the rollout in the production
                    /// environment and incremented on weekly basis or in case of failover events.
                    /// For instrument definition and snapshot streams, its value changes for each new loop.
                    /// its value will be rolled back to 1 if incremented beyond 65534.
                    UInt16 packetSequenceVersion;

                    /// Channel identification.
                    UInt8 channelId;

                    /// Number of message in the packet
                    UInt8 packetMessageNumber;

                    /// Indicates if the message is the last in the packet
                    bool lastMessage;

                    /// the way data received
                    Origin origin;

                    /// The packet was cached due to incorrect sequence
                    bool cached;

                    std::string toString () const;
                };

                ONIXS_B3_UMDF_MD_API std::ostream& operator << (std::ostream& stream, const DataSource& ds);

                namespace System
                {
                    /// Zero-based index of CPU.
                    typedef size_t CpuIndex;

                    /// Represents set of CPU indices.
                    class ONIXS_B3_UMDF_MD_API ThreadAffinity

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/messaging/StrRef.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Aliases.h>
#include <OnixS/B3/MarketData/UMDF/messaging/String.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Utils.h>

#include <algorithm>
#include <cassert>
#include <cstddef>
#include <cstring>
#include <limits>
#include <ostream>
#include <stdexcept>
#include <string>

#if defined(ONIXS_B3_UMDF_MD_HAS_STRING_VIEW)
#include <string_view>
#endif


ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_BEGIN

#if defined(ONIXS_B3_UMDF_MD_HAS_STRING_VIEW)

using StrRef = std::basic_string_view<Char>;

#else

/// \private
/// Throws exception on invalid index
ONIXS_B3_UMDF_MD_EXPORTED
ONIXS_B3_UMDF_MD_COLDPATH
ONIXS_B3_UMDF_MD_NORETURN
void throwInvalidIndex(size_t, size_t);

/// String reference.
///
/// Provides the efficient way of accessing
/// text-based values without copying
/// content of the text being referred.
ONIXS_B3_UMDF_MD_LTWT_CLASS StrRef
{
public:
    typedef size_t size_type;

    /// STL-like iterators.
    typedef const Char* const_iterator;
    typedef const_iterator iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef const_reverse_iterator reverse_iterator;

    /// Initializes the instance referring to nothing.
    ONIXS_B3_UMDF_MD_CONSTEXPR
    StrRef()
        : items_(ONIXS_B3_UMDF_MD_NULLPTR)
        , size_(0)
    {
    }

    /// Explicit initialization.
    ONIXS_B3_UMDF_MD_CONSTEXPR
    StrRef(const Char* chars, size_t size) ONIXS_B3_UMDF_MD_NOTHROW
        : items_(chars)
        , size_((ONIXS_B3_UMDF_MD_ASSERT(size <= (std::numeric_limits<size_type>::max)()), static_cast<size_type>(size)))
    {
    }

    /// Explicit initialization.
    StrRef(const Char* chars) ONIXS_B3_UMDF_MD_NOTHROW
        : items_(chars)
        , size_(0)
    {
        assert(chars);

        ONIXS_B3_UMDF_MD_CONST_OR_CONSTEXPR size_type maxLen = (std::numeric_limits<UInt16>::max)();

        size_ = numericCast<size_type>(strnlen(chars, maxLen));

        assert(size_ < maxLen);

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/messaging/SchemaTraits.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/MarketData/UMDF/messaging/Composites.h>

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_BEGIN

/// SBE-encoded data version type.
typedef
MessageHeader::Version
SchemaVersion;

typedef
MessageHeader::SchemaId
SchemaId;

/// Attributes of SBE message schema.
ONIXS_B3_UMDF_MD_LTWT_STRUCT
SchemaTraits
{
    /// Identifier of the messages schema.
    enum { Id = 2 };

    /// Version of the messages schema.
    enum { Version = 16 };

    /// The minimal SBE Schema version supported by the SDK.
    /// Messages of lower versions will not be processed
    /// as they may miss fields required for the correct data
    /// handling.
    enum { MinimalVersion = 15 };
};

#define ONIXS_B3_UMDF_MD_SCHEMA_DESCRIPTION  "B3 Market Data UMDF SBE messages"

#define ONIXS_B3_UMDF_MD_SCHEMA_SEMANTIC_VERSION  "2.2.0"


ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_END

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/messaging/Fields.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/MarketData/UMDF/Time.h>
#include <OnixS/B3/MarketData/UMDF/messaging/StrRef.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Integral.h>

#ifdef DELETE
#undef DELETE
#endif

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_BEGIN

/// 1-byte signed integer, from -128 to 127; if optional, null value is -128.
typedef Int8 Int8;


/// 2-byte signed integer, from -32768 to 32767; if optional, null value is -32768.
typedef Int16 Int16;


/// 4-byte signed integer, from -2147483648 to 2147483647; if optional, null value is -2147483648.
typedef Int32 Int32;


/// 8-byte signed integer, from -9223372036854775808 (-2^63) to 9223372036854775807 (2^63-1).
typedef Int64 Int64;


/// 1-byte unsigned integer, from 0 to 255.
typedef UInt8 UInt8;


/// 2-byte unsigned integer, from 0 to 65535.
typedef UInt16 UInt16;


/// 4-byte unsigned integer, from 0 to 4294967295 (2^32-1).
typedef UInt32 UInt32;


/// 8-byte unsigned integer, from 0 to 18446744073709551615 (2^64-1).
typedef UInt64 UInt64;


/// 1-byte signed integer, from -128 to 127, NULL (optional) value = 0.
typedef Int8 Int8NULL;


/// 2-byte unsigned integer, from -32768 to 32767, NULL (optional) value = 0.
typedef Int16 Int16NULL;


/// 4-byte signed integer, from -2147483648 (-2^31) to 2147483647 (2^31-1), NULL (optional) value = 0.
typedef Int32 Int32NULL;


/// 8-byte signed integer, from -9223372036854775808 (-2^63) to 9223372036854775807 (2^63-1), NULL (optional) value = 0.
typedef Int64 Int64NULL;


/// 1 ASCII character, NULL (optional) value is '\0'.
typedef Char CharNULL;


/// 1-byte unsigned integer, from 1 to 255, NULL (optional) value = 0.
typedef UInt8 UInt8NULL;


/// 2-byte unsigned integer, from 1 to 65535, NULL (optional) value = 0.
typedef UInt16 UInt16NULL;


/// 4-byte unsigned integer, from 1 to 4294967295 (2^32-1), NULL (optional) value = 0.
typedef UInt32 UInt32NULL;


/// 8-byte unsigned integer, from 1 to 18446744073709551615 (2^64-1), NULL (optional) value = 0.
typedef UInt64 UInt64NULL;



===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/messaging/MessageSerialization.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <string>

#include <OnixS/B3/MarketData/UMDF/messaging/Messages.h>


ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_BEGIN

// Market Data Serialization.

/// Serializes into a string.
ONIXS_B3_UMDF_MD_EXPORTED
void
toStr(
    std::string& str,
    const SequenceReset_1& obj);


/// Serializes into a string.
inline
std::string
toStr(
    const SequenceReset_1& obj)
{
    std::string str;

    toStr(str, obj);

    return str;
}

/// Serializes into a stream.
inline
std::ostream&
operator<<(
    std::ostream& stream,
    const SequenceReset_1& obj)
{
    std::string str;

    toStr(str, obj);

    return stream << str;
}

inline std::string SequenceReset_1::toString() const
{
    return toStr(*this);
}
/// Serializes the object into FIX presentation.
ONIXS_B3_UMDF_MD_EXPORTED
void
toFix(
    std::string& str,
    const SequenceReset_1& obj);


/// Serializes into a string.
ONIXS_B3_UMDF_MD_EXPORTED
void
toStr(
    std::string& str,
    const Sequence_2& obj);


/// Serializes into a string.
inline std::string toStr(const Sequence_2& obj)
{
    std::string str;

    toStr(str, obj);

    return str;
}

/// Serializes into a stream.
inline
std::ostream&
operator<<(

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/messaging/Typification.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/MarketData/UMDF/messaging/Messages.h>

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_BEGIN

/// Casts SBE-encoded message to a given type.
template
    <
        class Message
    >
inline
ONIXS_B3_UMDF_MD_NODISCARD
ONIXS_B3_UMDF_MD_PURE
Message
typify(
    const SbeMessage message)
{
    return Message(message);
}

/// Casts a given binary message according to template/type
/// information and processes the cast messages by a given processor.
///
/// Returned value indicates whether message type was successfully
/// recognized and pushed to the processor for further processing. Unknown
/// messages aren't processed and thus false result is returned.
template
<
    class Processor
>
inline
ONIXS_B3_UMDF_MD_NODISCARD
bool
processTypified(
    const SbeMessage binary,
    Processor&& processor)
{
    switch (binary.templateId())
    {
    case SequenceReset_1::TemplateId:
    {
        processor(
            typify
            <SequenceReset_1>
            (binary));

        return true;
    }

    case Sequence_2::TemplateId:
    {
        processor(
            typify
            <Sequence_2>
            (binary));

        return true;
    }

    case EmptyBook_9::TemplateId:
    {
        processor(
            typify
            <EmptyBook_9>
            (binary));

        return true;
    }

    case ChannelReset_11::TemplateId:
    {
        processor(
            typify
            <ChannelReset_11>
            (binary));

        return true;
    }


===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/messaging/Messages.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <cassert>
#include <stdexcept>

#include <OnixS/B3/MarketData/UMDF/ABI.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Composites.h>
#include <OnixS/B3/MarketData/UMDF/messaging/SbeMessage.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Forwards.h>

#ifdef DELETE
#undef DELETE
#endif

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_BEGIN

/// Used to reset the incremental stream or indicate the loop on instrument definition or snapshot recovery is restarting.
ONIXS_B3_UMDF_MD_LTWT_STRUCT
SequenceReset_1
: SbeMessage
{
    /// Used template schema.
    typedef SchemaTraits Schema;

    /// Message template ID from SBE schema.
    enum { TemplateId = 1 };

    /// Initializes a blank instance.
    SequenceReset_1() ONIXS_B3_UMDF_MD_DEFAULT;

    /// Creates an instance over the given memory block.
    SequenceReset_1(
        void* data,
        EncodedLength length,
        NoInit)
      : SbeMessage(data, length)
    {
        checkCompatibility();
    }

    /// Creates an instance over the given SBE message.
    explicit
    SequenceReset_1(
        const SbeMessage& message)
      : SbeMessage(message)
    {
        assert(message.valid());

        checkCompatibility();
    }

    /// Creates an instance over the given memory block.
    /// Performs no checks.
    SequenceReset_1(
        void* data,
        EncodedLength length,
        NoInit,
        NoCheck)
        ONIXS_B3_UMDF_MD_NOTHROW
      : SbeMessage(data, length, NoCheck())
    {
        assert(schemaId() == Schema::Id);
        assert(version() >= Schema::MinimalVersion);
        assert(TemplateId == templateId());
    }

    /// FIX Message Type.
    ONIXS_B3_UMDF_MD_LTWT_EXPORTED
    ONIXS_B3_UMDF_MD_CONSTEXPR
    static MessageType::Enum messageType()
        ONIXS_B3_UMDF_MD_NOTHROW
    {
        return MessageType::SequenceReset;
    }

    /// Specifies the service pack release being applied at
    /// message level.
    ONIXS_B3_UMDF_MD_LTWT_EXPORTED
    ONIXS_B3_UMDF_MD_CONSTEXPR
    static ApplVerID::Enum applVerId()

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/messaging/Decimal.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/MarketData/UMDF/messaging/Integral.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Memory.h>

#include <string>

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_BEGIN

/// Forward declarations
template <class MantissaType, class ExponentType> class FixedPointDecimal;
template<class Mantissa, class Exponent> std::string toStr(const FixedPointDecimal <Mantissa, Exponent>&);

/// A real number with a constant exponent.
template
<
    class MantissaType,
    class ExponentType
>
class FixedPointDecimal
{
    // Only mantissa is stored.
    MantissaType mantissa_;

public:
    /// \private
    /// Init traits.
    struct MemberTraits
    {
        enum { Count = 1 };

        typedef MantissaType FirstArgType;
    };

    /// Mantissa component type.
    typedef MantissaType Mantissa;

    /// Exponent component type.
    typedef ExponentType Exponent;

    /// Traits.
    enum
    {
        /// Size of the class in bytes.
        Size = sizeof(Mantissa)
    };

    /// \return a human-readable presentation.
    ONIXS_B3_UMDF_MD_NODISCARD
    std::string toString() const
    {
        return toStr(*this);
    }

    /// Default (zero) initialization.
    ONIXS_B3_UMDF_MD_CONSTEXPR
    FixedPointDecimal() ONIXS_B3_UMDF_MD_NOTHROW
        : mantissa_()
    {
    }

    /// Explicitly initializes the instance from the mantissa value.
    explicit ONIXS_B3_UMDF_MD_CONSTEXPR FixedPointDecimal(Mantissa mantissa) ONIXS_B3_UMDF_MD_NOTHROW
        : mantissa_(mantissa)
    {
    }

    /// \return mantissa.
    ONIXS_B3_UMDF_MD_CONSTEXPR
    Mantissa mantissa() const ONIXS_B3_UMDF_MD_NOTHROW
    {
        return mantissa_;
    }

    /// \return exponent.
    ONIXS_B3_UMDF_MD_CONSTEXPR
    Exponent exponent() const ONIXS_B3_UMDF_MD_NOTHROW
    {
        return Exponent();
    }

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/messaging/Decimal.Operations.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>

#include <OnixS/B3/MarketData/UMDF/messaging/Decimal.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Composites.h>

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_BEGIN

/// Serializes a fixed-point decimal into a string.
template
<
    class Mantissa,
    class Exponent
>
inline
ONIXS_B3_UMDF_MD_NODISCARD
std::string
toStr(
    const
    FixedPointDecimal
        <
            Mantissa,
            Exponent
        >& number)
{
    std::string str;

    toStr(str, number);

    return str;
}

/// Serializes into a stream.
template
    <
        class Mantissa,
        class Exponent
    >
inline
std::ostream&
operator<<(
    std::ostream& stream,
    const
    FixedPointDecimal
        <Mantissa, Exponent>& value)
{
    std::string str;

    toStr(str, value);

    return stream << str;
}

/// Compares two fixed-point decimals.
template
<
    class Mantissa,
    class Exponent
>
ONIXS_B3_UMDF_MD_NODISCARD
ONIXS_B3_UMDF_MD_PURE
bool
operator ==(
    const
    FixedPointDecimal
        <Mantissa, Exponent>& left,
    const
    FixedPointDecimal
        <Mantissa, Exponent>& right)
{
    if(isNull(left) && isNull(right))
        return true;

    return left.mantissa() == right.mantissa();
}

/// Compares two fixed-point decimals.
template
<

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/messaging/Serialization.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <string>

#include <OnixS/B3/MarketData/UMDF/messaging/Fields.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Composites.h>

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_BEGIN

// Market Data Serialization.

/// Serializes into a string.
ONIXS_B3_UMDF_MD_EXPORTED
void
toStr(
    std::string& str,
    MessageType::Enum value);


/// Serializes into a string.
inline std::string toStr(MessageType::Enum value)
{
    std::string str;

    toStr(str, value);

    return str;
}

/// Serializes into a stream.
inline
std::ostream&
operator<<(
    std::ostream& stream,
    MessageType::Enum value)
{
    std::string str;

    toStr(str, value);

    return stream << str;
}

/// Serializes the object into FIX presentation.
inline
void
toFix(
    std::string& str,
    MessageType::Enum value)
{
    toStr(
        str,
        static_cast<MessageType::Base>(value));
}


/// Serializes into a string.
ONIXS_B3_UMDF_MD_EXPORTED
void
toStr(
    std::string& str,
    Boolean::Enum value);


/// Serializes into a string.
inline std::string toStr(Boolean::Enum value)
{
    std::string str;

    toStr(str, value);

    return str;
}

/// Serializes into a stream.
inline
std::ostream&
operator<<(
    std::ostream& stream,
    Boolean::Enum value)

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/messaging/MaxMessageSize.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>
#include <OnixS/B3/MarketData/UMDF/Compiler.h>

#include <OnixS/B3/MarketData/UMDF/messaging/Fields.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Composites.h>


ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_BEGIN

/// Maximum supported message size.
ONIXS_B3_UMDF_MD_CONST_OR_CONSTEXPR UInt16 MaxMessageSize = 1400 - 16;

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_END

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/messaging/SbeMessage.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Aliases.h>
#include <OnixS/B3/MarketData/UMDF/messaging/StrRef.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Memory.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Composites.h>
#include <OnixS/B3/MarketData/UMDF/messaging/SchemaTraits.h>
#include <OnixS/B3/MarketData/UMDF/messaging/MaxMessageSize.h>
#include <OnixS/B3/MarketData/UMDF/messaging/ExceptionHelpers.h>

#include <cassert>
#include <limits>
#include <stdexcept>

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_BEGIN

/// Message type (template) identification.
typedef
MessageHeader::TemplateId MessageTemplateId;

/// \private
template<typename Message> inline
void checkBinaryLength(const Message&, MessageSize length, MessageSize minimalRequiredLength)
{
    if ONIXS_B3_UMDF_MD_UNLIKELY(length < minimalRequiredLength)
        throwBinaryBlockIsTooSmall(length, minimalRequiredLength, Message::className());
}

/// \private
ONIXS_B3_UMDF_MD_LTWT_CLASS BinaryBlockBase
{
protected:
    ~BinaryBlockBase() ONIXS_B3_UMDF_MD_DEFAULT;
};

/// Services to access fields stored
/// in an SBE-encoded block of fixed-length fields.
///
/// The given class represents an abstraction to be used
/// by descendants as a base class with static polymorphism.
template < class Container, class BlockLength >
ONIXS_B3_UMDF_MD_LTWT_CLASS BinaryBlock : public BinaryBlockBase
{
    /// \return The block container that provides access to the encoded data.
    const Container& container() const ONIXS_B3_UMDF_MD_NOTHROW
    {
        return *static_cast <const Container*> (this);
    }

protected:
    /// Initializes a blank instance.
    BinaryBlock() ONIXS_B3_UMDF_MD_DEFAULT;

    ~BinaryBlock() ONIXS_B3_UMDF_MD_DEFAULT;

    /// \return the field value.
    template < class Value > ONIXS_B3_UMDF_MD_HOTPATH
    Value ordinary(BlockLength offset) const ONIXS_B3_UMDF_MD_NOTHROW
    {
        assert(container().blockLength() >= (offset + size<Value>()) &&
            "The requested field exceeds provided block boundaries.");

        const void* const location = advanceByBytes(container().block(), offset);
        return getValue<Value>(location);
    }

    /// Provides access to an optional field value.
    ///
    /// \return `true` if the field is present in the field block and its value was copied,
    /// otherwise - `false`.
    template <class Value, class NullValue > ONIXS_B3_UMDF_MD_HOTPATH
    bool ordinary(Value& value, BlockLength offset, NullValue null) const ONIXS_B3_UMDF_MD_NOTHROW
    {
        value = ordinary<Value>(offset);

        return (null != value);
    }

    /// Provides access to an optional field value.

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/messaging/Composites.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>

#include <OnixS/B3/MarketData/UMDF/messaging/Memory.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Decimal.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Fields.h>

#ifdef DELETE
#undef DELETE
#endif

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_BEGIN
ONIXS_B3_UMDF_MD_DATA_PACKING_BEGIN(1)

/// Message identifiers and length of message root.
ONIXS_B3_UMDF_MD_LTWT_CLASS MessageHeader
{
public:
    /// Size of the composite.
    enum { Size = 8 };

    /// Root block length.
    typedef UInt16 BlockLength;

    /// Template ID.
    typedef UInt16 TemplateId;

    /// Schema ID.
    typedef UInt16 SchemaId;

    /// Schema Version.
    typedef UInt16 Version;

    /// Root block length.
    ONIXS_B3_UMDF_MD_NODISCARD
    BlockLength blockLength() const
        ONIXS_B3_UMDF_MD_NOTHROW
    {
        return blockLength_;
    }

    /// Template ID.
    ONIXS_B3_UMDF_MD_NODISCARD
    TemplateId templateId() const
        ONIXS_B3_UMDF_MD_NOTHROW
    {
        return templateId_;
    }

    /// Schema ID.
    ONIXS_B3_UMDF_MD_NODISCARD
    SchemaId schemaId() const
        ONIXS_B3_UMDF_MD_NOTHROW
    {
        return schemaId_;
    }

    /// Schema Version.
    ONIXS_B3_UMDF_MD_NODISCARD
    Version version() const
        ONIXS_B3_UMDF_MD_NOTHROW
    {
        return version_;
    }

private:
    BlockLength blockLength_;
    TemplateId templateId_;
    SchemaId schemaId_;
    Version version_;
};


/// Repeating group dimensions.
ONIXS_B3_UMDF_MD_LTWT_CLASS GroupSizeEncoding
{
public:
    /// Size of the composite.
    enum { Size = 3 };

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/messaging/Memory.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/MarketData/UMDF/Compiler.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Integral.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Utils.h>

#include <cstddef>
#include <cstring>
#include <cassert>

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_BEGIN

/// Alias for Byte.
typedef UInt8 Byte;

/// Alias for Word.
typedef UInt16 Word;

/// Alias for Double Word.
typedef UInt32 DWord;

/// Alias for Quad Word.
typedef UInt64 QWord;

/// Makes the pointer an opaque one.
/// \private
template
<
    typename Type
>
ONIXS_B3_UMDF_MD_HOTPATH
ONIXS_B3_UMDF_MD_PURE
void*
toOpaquePtr(Type* ptr)
    ONIXS_B3_UMDF_MD_NOTHROW
{
    assert(ptr);
    return static_cast<void*>(ptr);
}

/// Makes the pointer an opaque one.
/// \private
template
<
    typename Type
>
ONIXS_B3_UMDF_MD_HOTPATH
ONIXS_B3_UMDF_MD_PURE
const void*
toOpaquePtr(const Type* ptr)
    ONIXS_B3_UMDF_MD_NOTHROW
{
    assert(ptr);
    return static_cast<const void*>(ptr);
}

/// Reinterprets the pointer as a byte block one.
/// \private
template
<
    typename Type
>
ONIXS_B3_UMDF_MD_HOTPATH
ONIXS_B3_UMDF_MD_PURE
Byte*
toByteBlock(Type* ptr)
    ONIXS_B3_UMDF_MD_NOTHROW
{
    assert(ptr);

    return
        static_cast
        <Byte*>
        (toOpaquePtr(ptr));
}

/// Reinterprets the pointer as a byte block one.
/// \private
template
<

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/messaging/Aliases.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Integral.h>

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_BEGIN

/// Message length type.
typedef UInt16 MessageSize;

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_END

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/messaging/Utils.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <cassert>

#include <OnixS/B3/MarketData/UMDF/ABI.h>

#ifdef ONIXS_B3_UMDF_MD_HAS_TYPE_TRAITS
#   include <type_traits>
#endif

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_BEGIN

#ifdef ONIXS_B3_UMDF_MD_HAS_TYPE_TRAITS

/// \private
template <bool B, class T = void>
using EnableIf = std::enable_if<B, T>;

/// \private
template <typename Base, typename Derived>
using IsBaseOf = std::is_base_of<Base, Derived>;

/// \private
template <class T>
using IsSigned = std::is_signed<T>;

#define CHECK_TYPE_INTEGRAL(Type) \
          static_assert( \
              std::is_integral<Type>::value, \
              #Type " must be an integral type, consider adding MemberTraits" \
              );
#else

/// \private
template <bool B, class T = void>
struct EnableIf
{
    typedef T type;
};

/// \private
template <class T>
struct EnableIf<false, T> {};

/// \private
template<typename Base, typename Derived>
struct IsBaseOf
{
    enum { value = __is_base_of(Base, Derived)};
};

/// \private
template<typename T>
struct IsSigned
{
    enum { value = (!(static_cast<T>(-1) > static_cast<T>(0))) };
};

#define CHECK_TYPE_INTEGRAL(Type)

#endif

///\private
namespace details {

    ///\private
    template <class T, class U>
    struct IsSameSignedness
    {
        enum { value = (static_cast<bool>(IsSigned<T>::value) == static_cast<bool>(IsSigned<U>::value)) };
    };

    ///\private
    template<typename T>
    struct HasMantissa
    {
        template<typename U> struct SFINAE {};
        template<typename U> static char test(SFINAE<typename U::Mantissa>*);
        template<typename U> static int test(...);
        enum { value = sizeof(test<T>(ONIXS_B3_UMDF_MD_NULLPTR)) == sizeof(char) };

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/messaging/String.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <string>

#include <OnixS/B3/MarketData/UMDF/ABI.h>

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_BEGIN

/// Character type alias.
typedef char Char;

/// Appends the character to the given std::string instance.
inline
void toStr(std::string& str, Char character)
{
    str.append(1, character);
}

/// Appends strings.
inline
void toStr(std::string& str, const std::string& value)
{
    str.append(value);
}

/// Constructs a std::string from the given character.
ONIXS_B3_UMDF_MD_NODISCARD
inline std::string toStr(Char character)
{
    return std::string(1, character);
}

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_END

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/messaging/ExceptionHelpers.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>
#include <OnixS/B3/MarketData/UMDF/messaging/SchemaTraits.h>

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_BEGIN

/// Message type (template) identification.
typedef MessageHeader::TemplateId MessageTemplateId;

/// \private
/// Throws an exception on a bad repeating group.
ONIXS_B3_UMDF_MD_EXPORTED
ONIXS_B3_UMDF_MD_COLDPATH
ONIXS_B3_UMDF_MD_NORETURN
void throwBadBinaryBlock();

/// \private
/// Throws an exception on a bad repeating group entry.
ONIXS_B3_UMDF_MD_EXPORTED
ONIXS_B3_UMDF_MD_COLDPATH
ONIXS_B3_UMDF_MD_NORETURN
void throwDisallowedField();

/// \private
/// Raises an exception when the given binary block is too small.
ONIXS_B3_UMDF_MD_EXPORTED
ONIXS_B3_UMDF_MD_COLDPATH
ONIXS_B3_UMDF_MD_NORETURN
void throwBinaryBlockIsTooSmall(MessageSize actual, MessageSize required);

/// \private
/// Raises an exception when the given binary block is too small.
ONIXS_B3_UMDF_MD_EXPORTED
ONIXS_B3_UMDF_MD_COLDPATH
ONIXS_B3_UMDF_MD_NORETURN
void throwBinaryBlockIsTooSmall(MessageSize actual, MessageSize required, const Char*);

/// \private
/// Raises an exception on a bad message version.
ONIXS_B3_UMDF_MD_EXPORTED
ONIXS_B3_UMDF_MD_COLDPATH
ONIXS_B3_UMDF_MD_NORETURN
void throwBadMessageVersion(SchemaVersion messageVersion, SchemaVersion minimalVersion);

/// \private
/// Raises an exception on a bad message id.
ONIXS_B3_UMDF_MD_EXPORTED
ONIXS_B3_UMDF_MD_COLDPATH
ONIXS_B3_UMDF_MD_NORETURN
void throwBadSchemaId(SchemaId expected, SchemaId provided);

/// \private
/// Throws an exception on a bad repeating group entry.
ONIXS_B3_UMDF_MD_EXPORTED
ONIXS_B3_UMDF_MD_COLDPATH
ONIXS_B3_UMDF_MD_NORETURN
void throwNotEnoughSpace();

/// \private
ONIXS_B3_UMDF_MD_EXPORTED
ONIXS_B3_UMDF_MD_COLDPATH
ONIXS_B3_UMDF_MD_NORETURN
void throwBadConversion(const Char* typeName);

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_END

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/messaging/Forwards.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_BEGIN

ONIXS_B3_UMDF_MD_LTWT_CLASS_DECL(SbeMessage);

ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(SequenceReset_1);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(Sequence_2);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(EmptyBook_9);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(ChannelReset_11);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(SecurityStatus_3);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(SecurityGroupPhase_10);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(SecurityDefinition_12);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(News_5);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(OpeningPrice_15);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(TheoreticalOpeningPrice_16);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(ClosingPrice_17);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(AuctionImbalance_19);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(QuantityBand_21);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(PriceBand_22);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(HighPrice_24);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(LowPrice_25);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(LastTradePrice_27);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(SettlementPrice_28);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(OpenInterest_29);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(SnapshotFullRefresh_Header_30);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(Order_MBO_50);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(DeleteOrder_MBO_51);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(MassDeleteOrders_MBO_52);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(Trade_53);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(ForwardTrade_54);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(ExecutionSummary_55);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(ExecutionStatistics_56);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(TradeBust_57);
ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(SnapshotFullRefresh_Orders_MBO_71);

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_END

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/messaging/Integral.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>
#include <OnixS/B3/MarketData/UMDF/messaging/String.h>

#include <string>

ONIXS_B3_UMDF_MD_MESSAGING_NAMESPACE_BEGIN

#if defined (_MSC_VER)

typedef signed char Int8;
typedef unsigned char UInt8;

typedef signed short Int16;
typedef unsigned short UInt16;

typedef signed int Int32;
typedef unsigned int UInt32;

typedef signed long long Int64;
typedef unsigned long long UInt64;

#elif defined (__GNUC__)

typedef signed char Int8;
typedef unsigned char UInt8;

typedef signed short Int16;
typedef unsigned short UInt16;

#if defined (__LP64__)

typedef signed int Int32;
typedef unsigned int UInt32;

typedef signed long Int64;
typedef unsigned long UInt64;

#else

typedef signed int Int32;
typedef unsigned int UInt32;

typedef signed long long Int64;
typedef unsigned long long UInt64;

#endif

#else

// Compiler is not (yet) supported.
// Integral types must be defined explicitly.

#error \
    Cannot identify compiler toolset to define integral types. \
    Please contact support@onixs.biz on further assistance.

#endif

/// Integral constant.
template
<
    typename Type,
    Type Constant
>
struct IntegralConstant
{
    /// Type of the constant.
    typedef Type Value;

    /// \return value of the constant.
    ONIXS_B3_UMDF_MD_CONSTEXPR
    operator Value() const ONIXS_B3_UMDF_MD_NOTHROW
    {
        return Constant;
    }

    /// \return value of the constant.
    ONIXS_B3_UMDF_MD_CONSTEXPR

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/FeedEngine.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>
#include <OnixS/B3/MarketData/UMDF/Integral.h>
#include <OnixS/B3/MarketData/UMDF/Defines.h>
#include <OnixS/B3/MarketData/UMDF/WatchService.h>
#include <OnixS/B3/MarketData/UMDF/LogSettings.h>

#include <string>
#include <vector>
#include <cassert>

namespace OnixS
{
    namespace B3
    {
        namespace MarketData
        {
            namespace UMDF
            {
                namespace System
                {
                    /// Current thread related tasks.
                    class ONIXS_B3_UMDF_MD_API ThisThread
                    {
                    public:
                        /// Sets the processor affinity mask for the current thread.
                        static void affinity(const System::ThreadAffinity&);
                        static void affinity(System::CpuIndex);

#if defined (_WIN32)
                        typedef unsigned int ThreadId;
#else
                        typedef pthread_t ThreadId;
#endif

                        static ThreadId threadId();
                    };
                }

                /// Designed to reflect various aspects of feed engine processing flow.
                class NetFeedEngineProcessResult
                {
                public:
                    /// Aliases integral type whose bits are used to indicate flag presence.
                    typedef UInt32 Flags;

                    ///
                    explicit NetFeedEngineProcessResult(UInt32 flags) ONIXS_B3_UMDF_MD_NOTHROW
                    {
                        value_.raw_ = flags;
                    }

                    /// Indicates whether feed-related events like data reception or absence have been dispatched.
                    bool eventsDispatched() const ONIXS_B3_UMDF_MD_NOTHROW
                    {
                        return 0 != value_.bits_.eventsDispatched_;
                    }

                    /// Indicates whether feed-related events like data reception or absence have been dispatched.
                    void eventsDispatched(bool state) ONIXS_B3_UMDF_MD_NOTHROW
                    {
                        value_.bits_.eventsDispatched_ = state ? 1 : 0;
                    }

                    /// Indicates whether processing had to sleep in kernel while checking data availability.
                    bool ioWaited() const ONIXS_B3_UMDF_MD_NOTHROW
                    {
                        return 0 != value_.bits_.ioWaited_;
                    }

                    /// Indicates whether processing had to sleep in kernel while checking data availability.
                    void ioWaited(bool state) ONIXS_B3_UMDF_MD_NOTHROW
                    {
                        value_.bits_.ioWaited_ = state ? 1 : 0;
                    }

                    /// Reserved (unused) flags.
                    Flags reserved() const ONIXS_B3_UMDF_MD_NOTHROW
                    {
                        return value_.bits_.reserved_;

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/HandlerStateListener.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>

#include <string>

namespace OnixS
{
    namespace B3
    {
        namespace MarketData
        {
            namespace UMDF
            {
                /// Defines the state that the handler is in.
                struct HandlerState
                {
                    /// @copydoc HandlerState
                    enum Enum
                    {
                        Stopped,  ///< Stopped.
                        Stopping, ///< The intermediate state when the Handler is not Stopped but not Started.
                        Started,     ///< Started.
                        Starting,    ///< The intermediate state when the Handler is not Started but not Stopped.
                    };
                };

                /// Returns string representation of HandlerState value.
                ONIXS_B3_UMDF_MD_API std::string enumToString (HandlerState::Enum);

                /// Status Listener.
                class HandlerStateListener
                {
                    public:
                        /// Implement this member to get notifications about the handler state change.
                        virtual void onStateChanged (HandlerState::Enum newState) = 0;

                    protected:
                        /// Disables public <b>delete</b> operator in the interface class.
                        virtual ~HandlerStateListener () {}
                };
            }
        }
    }
}

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/WatchService.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>
#include <OnixS/B3/MarketData/UMDF/Integral.h>
#include <OnixS/B3/MarketData/UMDF/Defines.h>
#include <OnixS/B3/MarketData/UMDF/CompilerDetection.h>
#include <OnixS/B3/MarketData/UMDF/Time.h>

#include <string>

namespace OnixS
{
    namespace B3
    {
        namespace MarketData
        {
            namespace UMDF
            {
                /// Abstract watch service.
                class ONIXS_B3_UMDF_MD_API WatchService
                {
                public:
                    /// Returns current UTC time.
                    Timestamp now();

                    /// Identifies watch service.
                    const char* id() const;

                    ///
                    virtual ~WatchService();

                protected:
                    WatchService(void* impl) ONIXS_B3_UMDF_MD_NOTHROW;

                private:
                    void* const impl_;
                    friend struct FeHelper;
                };

                /// UTC watch.
                class ONIXS_B3_UMDF_MD_API UtcWatch : public WatchService
                {
                public:
                    /// Returns watch service
                    static UtcWatch& service();

                    ///
                    ~UtcWatch() ONIXS_B3_UMDF_MD_OVERRIDE;

                private:
                    UtcWatch();
                };

                /// The network interface watch.
                ///
                /// This class is designed to use the network adapter's watch if the capability is supported.
                /// When an instance of the class is linked to a feed engine supporting hardware timestamps retrieval,
                /// the feed engine extracts hardware timestamps and assigns them to the incoming multicast packets.
                ///
                /// An ordinary system (UTC) clock is used in all other cases.
                /// \note Network interface card must be synchronized with the host's clock.
                class ONIXS_B3_UMDF_MD_API NicWatch : public WatchService
                {
                public:
                    /// Returns watch service
                    static NicWatch& service();

                    ///
                    ~NicWatch() ONIXS_B3_UMDF_MD_OVERRIDE;

                private:
                    NicWatch();
                };
            }
        }
    }
}

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/Semaphore.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable OnixS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>

namespace OnixS
{
    namespace B3
    {
        namespace MarketData
        {
            namespace UMDF
            {
                namespace System
                {
                    /// Semaphore
                    class ONIXS_B3_UMDF_MD_API Semaphore
                    {
                    public:
                        explicit
                        Semaphore(int initialCounter = 0);
                        ~Semaphore();

                        bool acquire(int timeoutInMs = -1); // infinite
                        void release();

                    private:
                        class Impl;
                        Impl* impl_;
                    };
                }
            }
        }
    }
}

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/Compiler.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
 */

#pragma once

#if !(defined(ONIXS_B3_UMDF_MD_DOXYGEN) && ONIXS_B3_UMDF_MD_DOXYGEN)

#include <OnixS/B3/MarketData/UMDF/CompilerDetection.h>


#if defined(_MSC_VER) && defined(_MSVC_LANG)
#  define ONIXS_B3_UMDF_MD_CURRENT_CXX_STD _MSVC_LANG
#else
#  define ONIXS_B3_UMDF_MD_CURRENT_CXX_STD __cplusplus
#endif

# if defined(ONIXS_B3_UMDF_MD_CXX11)
#  if (ONIXS_B3_UMDF_MD_CURRENT_CXX_STD < 201103L)
#   error C++11 was targeted during the OnixS SDK compilation but is not detected now
#   define ONIXS_TERMINATE_COMPILATION
#  endif
# endif

# if defined(ONIXS_B3_UMDF_MD_CXX14)
#  if (ONIXS_B3_UMDF_MD_CURRENT_CXX_STD < 201402L)
#   error C++14 was targeted during the OnixS SDK compilation but is not detected now
#   define ONIXS_TERMINATE_COMPILATION
#  endif
# endif

# if defined(ONIXS_B3_UMDF_MD_CXX17)
#  if (ONIXS_B3_UMDF_MD_CURRENT_CXX_STD < 201703L)
#   error C++17 was targeted during the OnixS SDK compilation but is not detected now
#   define ONIXS_TERMINATE_COMPILATION
#  endif
# endif

# if defined(ONIXS_B3_UMDF_MD_CXX20)
#  if !(ONIXS_B3_UMDF_MD_CURRENT_CXX_STD > 201703L)
#   error C++20 was targeted during the OnixS SDK compilation but is not detected now
#   define ONIXS_TERMINATE_COMPILATION
#  endif
# endif

# if defined(ONIXS_TERMINATE_COMPILATION)
#  include <terminate_compilation>
#endif

#undef ONIXS_B3_UMDF_MD_CURRENT_CXX_STD

# if defined(ONIXS_B3_UMDF_MD_CXX14)
#  define ONIXS_B3_UMDF_MD_CXX14_CONSTEXPR constexpr
#else
#  define ONIXS_B3_UMDF_MD_CXX14_CONSTEXPR
# endif

# if defined(ONIXS_B3_UMDF_MD_COMPILER_IS_GNU) | defined(ONIXS_B3_UMDF_MD_COMPILER_IS_Clang)
#  define ONIXS_B3_UMDF_MD_COMPILER_IS_GNU_or_Clang
# endif

# if defined(ONIXS_B3_UMDF_MD_COMPILER_IS_GNU)
# if __GNUC__ >= 9 && defined ONIXS_B3_UMDF_MD_CXX14
#   define ONIXS_B3_UMDF_MD_LIKELY(cond)   (__builtin_expect_with_probability((static_cast<bool>((cond))), true, 0.99999f))
#   define ONIXS_B3_UMDF_MD_UNLIKELY(cond) (__builtin_expect_with_probability((static_cast<bool>((cond))), false, 0.99999f))
# else
#   define ONIXS_B3_UMDF_MD_LIKELY(cond)   (__builtin_expect((static_cast<bool>((cond))), true))
#   define ONIXS_B3_UMDF_MD_UNLIKELY(cond) (__builtin_expect((static_cast<bool>((cond))), false))
# endif
# endif

# if defined(ONIXS_B3_UMDF_MD_COMPILER_IS_Clang)
#  define ONIXS_B3_UMDF_MD_LIKELY(cond) (__builtin_expect((static_cast<bool>((cond))), true))
#  define ONIXS_B3_UMDF_MD_UNLIKELY(cond) (__builtin_expect((static_cast<bool>((cond))), false))
#endif

# if defined(ONIXS_B3_UMDF_MD_COMPILER_IS_GNU_or_Clang)
#  define ONIXS_B3_UMDF_MD_UNUSED __attribute__((__unused__))
#  define ONIXS_B3_UMDF_MD_MAY_ALIAS __attribute__((__may_alias__))
#  define ONIXS_B3_UMDF_MD_HOTPATH __attribute__((hot))
#  define ONIXS_B3_UMDF_MD_COLDPATH __attribute__((noinline,cold))
#  define ONIXS_B3_UMDF_MD_NORETURN __attribute__ ((__noreturn__))
#  define ONIXS_B3_UMDF_MD_NODISCARD __attribute__((warn_unused_result))
#  define ONIXS_B3_UMDF_MD_PURE


===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/Export.h =====

#ifndef ONIXS_B3_UMDF_MD_API_H
#define ONIXS_B3_UMDF_MD_API_H

#ifdef ONIXS_B3_UMDF_MD_AS_STATIC_LIB
#  define ONIXS_B3_UMDF_MD_API
#  define ONIXS_B3UMDFH_NO_EXPORT
#else
#  ifndef ONIXS_B3_UMDF_MD_API
#    ifdef b3umdfh_EXPORTS
        /* We are building this library */
#      define ONIXS_B3_UMDF_MD_API __attribute__((visibility("default")))
#    else
        /* We are using this library */
#      define ONIXS_B3_UMDF_MD_API __attribute__((visibility("default")))
#    endif
#  endif

#  ifndef ONIXS_B3UMDFH_NO_EXPORT
#    define ONIXS_B3UMDFH_NO_EXPORT __attribute__((visibility("hidden")))
#  endif
#endif

#ifndef ONIXS_B3UMDFH_DEPRECATED
#  define ONIXS_B3UMDFH_DEPRECATED __attribute__ ((__deprecated__))
#endif

#ifndef ONIXS_B3UMDFH_DEPRECATED_EXPORT
#  define ONIXS_B3UMDFH_DEPRECATED_EXPORT ONIXS_B3_UMDF_MD_API ONIXS_B3UMDFH_DEPRECATED
#endif

#ifndef ONIXS_B3UMDFH_DEPRECATED_NO_EXPORT
#  define ONIXS_B3UMDFH_DEPRECATED_NO_EXPORT ONIXS_B3UMDFH_NO_EXPORT ONIXS_B3UMDFH_DEPRECATED
#endif

/* NOLINTNEXTLINE(readability-avoid-unconditional-preprocessor-if) */
#if 0 /* DEFINE_NO_DEPRECATED */
#  ifndef ONIXS_B3UMDFH_NO_DEPRECATED
#    define ONIXS_B3UMDFH_NO_DEPRECATED
#  endif
#endif

#endif /* ONIXS_B3_UMDF_MD_API_H */

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/ABI.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/MarketData/UMDF/Export.h>
#include <OnixS/B3/MarketData/UMDF/Compiler.h>

#if defined (_MSC_VER)
#define ONIXS_B3_UMDF_MD_API_DECL(typeKind, typeName) \
typeKind ONIXS_B3_UMDF_MD_API typeName

#define ONIXS_B3_UMDF_MD_THROWABLE
#else
#define ONIXS_B3_UMDF_MD_API_DECL(typeKind, typeName) \
typeKind typeName

#define ONIXS_B3_UMDF_MD_THROWABLE ONIXS_B3_UMDF_MD_API
#endif

#define ONIXS_B3_UMDF_MD_EXPORTED ONIXS_B3_UMDF_MD_API

// Common part of export-related decorations.

#define \
    ONIXS_B3_UMDF_MD_EXPORTED_CLASS_DECL(typeName) \
    ONIXS_B3_UMDF_MD_EXPORTED_DECL(class, typeName)

#define \
    ONIXS_B3_UMDF_MD_EXPORTED_STRUCT_DECL(typeName) \
    ONIXS_B3_UMDF_MD_EXPORTED_DECL(struct, typeName)

#define \
    ONIXS_B3_UMDF_MD_EXPORTED_CLASS \
    class ONIXS_B3_UMDF_MD_EXPORTED

#define \
    ONIXS_B3_UMDF_MD_EXPORTED_STRUCT \
    struct ONIXS_B3_UMDF_MD_EXPORTED

#define \
    ONIXS_B3_UMDF_MD_INTERNAL_CLASS_DECL(typeName) \
    class typeName

#define \
    ONIXS_B3_UMDF_MD_INTERNAL_STRUCT_DECL(typeName) \
    struct typeName

#if defined (ONIXS_B3_UMDF_MD_LTWT_AS_EXPORTED)

#define \
    ONIXS_B3_UMDF_MD_LTWT_CLASS \
    ONIXS_B3_UMDF_MD_EXPORTED_CLASS

#define \
    ONIXS_B3_UMDF_MD_LTWT_STRUCT \
    ONIXS_B3_UMDF_MD_EXPORTED_STRUCT

#define \
    ONIXS_B3_UMDF_MD_LTWT_EXPORTED \
    /* Nothing */

#define \
    ONIXS_B3_UMDF_MD_LTWT_CLASS_DECL(name) \
    ONIXS_B3_UMDF_MD_EXPORTED_CLASS_DECL(name)

#define \
    ONIXS_B3_UMDF_MD_LTWT_STRUCT_DECL(name) \
    ONIXS_B3_UMDF_MD_EXPORTED_STRUCT_DECL(name)

#else

#define \
    ONIXS_B3_UMDF_MD_LTWT_CLASS \
    class ONIXS_B3_UMDF_MD_GCC44_SPURIOUS_WARNING_TURNAROUND

#define \
    ONIXS_B3_UMDF_MD_LTWT_STRUCT \
    struct ONIXS_B3_UMDF_MD_GCC44_SPURIOUS_WARNING_TURNAROUND

#define \
    ONIXS_B3_UMDF_MD_LTWT_EXPORTED \
    ONIXS_B3_UMDF_MD_EXPORTED


===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/HandlerSettings.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>
#include <OnixS/B3/MarketData/UMDF/Defines.h>
#include <OnixS/B3/MarketData/UMDF/LogSettings.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Fields.h>

#include <sstream>
#include <string>
#include <set>
#include <vector>
#include <limits>

namespace OnixS
{
    namespace B3
    {
        namespace MarketData
        {
            namespace UMDF
            {
                class FeedEngine;

                /// A feed-related settings.
                struct Feed
                {
                    Feed() {}

                    ///
                    Feed(const std::string& addr, unsigned int port, const std::string& nif = "", FeedEngine* fe = nullptr)
                        : address(addr)
                        , port(port)
                        , networkInterface(nif)
                        , feedEngine(fe)
                    {}

                    /// IP address
                    std::string address;

                    /// Port number
                    unsigned port = 0;

                    /// Specifies one or more network interfaces to use while joining the multicast group;
                    /// use semi-colon delimited list if more than one.
                    /// This value overrides the default one.
                    std::string networkInterface;

                    /// Feed engine to use on feed.
                    /// This value overrides the default one.
                    FeedEngine* feedEngine = nullptr;

                    /// Returns true if the descriptor points to valid ip address
                    bool valid() const
                    {
                        return !address.empty() && port > 0;
                    }
                };

                ONIXS_B3_UMDF_MD_API std::ostream& operator<<(std::ostream& stream, const Feed& descriptor);

                /// Group of feeds by role
                struct FeedGroup
                {
                    /// Feed descriptor.
                    Feed a;

                    /// Feed descriptor.
                    Feed b;
                };

                ONIXS_B3_UMDF_MD_API std::ostream& operator<<(std::ostream& stream, const FeedGroup& descriptor);

                struct HandlerSettings;

                ONIXS_B3_UMDF_MD_API std::ostream& operator<<(std::ostream& stream, const HandlerSettings& settings);

                class OrderBookPool;

                /// Handler configuration settings.
                struct ONIXS_B3_UMDF_MD_API HandlerSettings
                {

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/ErrorListener.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>

#include <string>

namespace OnixS
{
    namespace B3
    {
        namespace MarketData
        {
            namespace UMDF
            {

                /// Known (selected) error codes.
                struct ONIXS_B3_UMDF_MD_API ErrorCode
                {
                    /// @copydoc ErrorCode
                    enum Enum
                    {
                        General = 1, ///< Identifiers errors of generic nature.
                        NotLicensed ///< Indicates License-related issues like there's no license available or license has been expired.
                    };
                };

                /// Returns string representation of ErrorCode value.
                ONIXS_B3_UMDF_MD_API std::string enumToString (ErrorCode::Enum);

                /// Defines an interface through which the Handler notifies subscribers
                /// about errors occurred while processing messages.
                class ErrorListener
                {
                    public:
                        /// Implement this member to get notified about errors.
                        /// @param code identifies error occurred while processing messages.
                        /// @param description supplies notes on occurred error.
                        /// @note Errors mean that the Handler is not capable to recover from errors by itself 
                        /// and have to be restarted manually.
                        virtual void onError (ErrorCode::Enum code, const std::string& description) = 0;

                    protected:
                        /// Class provides an interface for handling errors in subscriptions.
                        /// It doesn't provide an interface for instance deletion. However,
                        /// since C++ doesn't have a pure interface concept, the destructor will be
                        /// generated anyway. We can only control proper use of it. For this
                        /// reason we hide from public use and make it available for descendants.
                        virtual ~ErrorListener() {}
                };

            }
        }
    }
}

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/Integral.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//

#pragma once

#include <string>

#include <OnixS/B3/MarketData/UMDF/messaging/Integral.h>

ONIXS_B3_UMDF_MD_NAMESPACE_BEGIN


typedef Messaging::Int8 Int8;
typedef Messaging::UInt8 UInt8;

typedef Messaging::Int16 Int16;
typedef Messaging::UInt16 UInt16;

typedef Messaging::Int32 Int32;
typedef Messaging::UInt32 UInt32;

typedef Messaging::Int64 Int64;
typedef Messaging::UInt64 UInt64;

ONIXS_B3_UMDF_MD_NAMESPACE_END

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/Messaging.h =====
// Copyright 2005-2012 Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
// and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable ONIXS Software
// Services Agreement (the Agreement) and Customer end user license agreements granting
// a non-assignable, non-transferable and non-exclusive license to use the software
// for it's own data processing purposes under the terms defined in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
// of this source code or associated reference material to any other location for further reproduction
// or redistribution, and any amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in accordance with
// the terms of the Agreement is a violation of copyright law.
//
#pragma once

#include <OnixS/B3/MarketData/UMDF/messaging/Forwards.h>
#include <OnixS/B3/MarketData/UMDF/messaging/String.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Integral.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Utils.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Memory.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Aliases.h>
#include <OnixS/B3/MarketData/UMDF/messaging/StrRef.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Fields.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Composites.h>
#include <OnixS/B3/MarketData/UMDF/messaging/SchemaTraits.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Fields.h>
#include <OnixS/B3/MarketData/UMDF/messaging/ExceptionHelpers.h>
#include <OnixS/B3/MarketData/UMDF/messaging/MaxMessageSize.h>
#include <OnixS/B3/MarketData/UMDF/messaging/SbeMessage.h>
#include <OnixS/B3/MarketData/UMDF/messaging/MessageSerialization.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Typification.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Messages.h>

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/Replay.h =====
// Copyright 2005-2012 Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
// and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable ONIXS Software
// Services Agreement (the Agreement) and Customer end user license agreements granting
// a non-assignable, non-transferable and non-exclusive license to use the software
// for it's own data processing purposes under the terms defined in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
// of this source code or associated reference material to any other location for further reproduction
// or redistribution, and any amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in accordance with
// the terms of the Agreement is a violation of copyright law.
//
#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>

#include <vector>
#include <string>

namespace OnixS
{
    namespace B3
    {
        namespace MarketData
        {
            namespace UMDF
            {
                /// Ordered list of logs to be replayed.
                typedef std::vector<std::string> HandlerLogs;

                /// Read-write iterator over ordered list of logs to be replayed.
                typedef std::vector<std::string>::iterator HandlerLogsEntry;

                /// Listening interface for log replay-related events.
                class ONIXS_B3_UMDF_MD_API ReplayListener
                {
                    public:
                        /// Is called once an error occurs while replaying logs.
                        virtual void onReplayError (const std::string& errorDescription) = 0;

                        /// Is called once all the logs are replayed.
                        virtual void onReplayFinished() = 0;

                    protected:
                        /// Deletion is not supposed
                        /// through interface of this class.
                        virtual ~ReplayListener();
                };

                /// Logging options.
                struct ONIXS_B3_UMDF_MD_API ReplayMode
                {
                    enum Enum
                    {
                        /// The packets are replayed with constant delay, defined by ReplayOptions::packetReplayDelay
                        /// Timestamps from the replayed file are ignored
                        /// ReplayOptions::playSpeedMultiplier is ignored
                        ConstantPacketReplayDelay = 1,

                        /// The packets are replayed with delays as it comes from the replayed file.
                        /// FinalDelay = LogFileDelay * ReplayOptions::playSpeedMultiplier + ReplayOptions::packetReplayDelay
                        NaturalPacketReplayDelay = 2
                    };
                };


                /// @typedef FilesList
                /// Ordered list of files to be replayed.
                typedef std::vector<std::string> FilesList;

                /// Gathers files which are stored in a given folder.
                void ONIXS_B3_UMDF_MD_API gatherFiles(FilesList* gatheredFiles, const std::string& root, const std::string& extension);

                /// Gathers log files which are stored in a given folder.
                inline
                void gatherLogs(FilesList* gatheredLogs, const std::string& root)
                {
                    gatherFiles(gatheredLogs, root, ".log");
                }

                /// Defines params which affect replay.
                struct ReplayOptions
                {
                    /// List of files to be replayed.
                    /// Must be stored in 'oldest to recent' order.
                    FilesList files;

                    /// Instance to notify about replay events.
                    ReplayListener* listener;

                    /// Specifies the time delay (milliseconds) between replayed packets.
                    ///
                    /// @note Ability to control replay rate.
                    unsigned int packetReplayDelay = 0;


===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/Time.h =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is
// protected by copyright law and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable
// OnixS Software Services Agreement (the Agreement) and Customer end user license
// agreements granting a non-assignable, non-transferable and non-exclusive license
// to use the software for it's own data processing purposes under the terms defined
// in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or
// reproduction of any part of this source code or associated reference material
// to any other location for further reproduction or redistribution, and any
// amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in
// accordance with the terms of the Agreement is a violation of copyright law.
//
#pragma once

#include <string>
#include <algorithm>
#include <stdexcept>

#include <OnixS/B3/MarketData/UMDF/ABI.h>
#include <OnixS/B3/MarketData/UMDF/Compiler.h>
#include <OnixS/B3/MarketData/UMDF/Integral.h>


namespace OnixS
{
    namespace B3
    {
        namespace MarketData
        {
            namespace UMDF
            {
                /// Miscellaneous time characteristics.
                struct TimeTraits
                {
                    /// Returns number of nanoseconds in single day.
                    ONIXS_B3_UMDF_MD_CONSTEXPR
                    static Int64 nanosecondsPerDay()
                    {
                        return 86400000000000ll;
                    }

                    /// Returns number of nanoseconds in single hour.
                    ONIXS_B3_UMDF_MD_CONSTEXPR
                    static Int64 nanosecondsPerHour()
                    {
                        return 3600000000000ll;
                    }

                    /// Returns number of nanoseconds in single minute.
                    ONIXS_B3_UMDF_MD_CONSTEXPR
                    static Int64 nanosecondsPerMinute()
                    {
                        return 60000000000ll;
                    }

                    /// Returns number of nanoseconds in single second.
                    ONIXS_B3_UMDF_MD_CONSTEXPR
                    static Int32 nanosecondsPerSecond()
                    {
                        return 1000000000;
                    }

                    /// Returns number of nanoseconds in single millisecond.
                    ONIXS_B3_UMDF_MD_CONSTEXPR
                    static Int32 nanosecondsPerMillisecond()
                    {
                        return 1000000;
                    }

                    /// Returns number of nanoseconds in single microsecond.
                    ONIXS_B3_UMDF_MD_CONSTEXPR
                    static Int32 nanosecondsPerMicrosecond()
                    {
                        return 1000;
                    }

                    /// Returns number of hours in single day.
                    ONIXS_B3_UMDF_MD_CONSTEXPR
                    static Int32 hoursPerDay()
                    {
                        return 24;
                    }

                    /// Returns number of minutes in single hour.
                    ONIXS_B3_UMDF_MD_CONSTEXPR
                    static Int32 minutesPerHour()
                    {
                        return 60;
                    }

                    /// Returns number of seconds in single minute.
                    ONIXS_B3_UMDF_MD_CONSTEXPR
                    static Int32 secondsPerMinute()

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF/OrderBook.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/
#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>
#include <OnixS/B3/MarketData/UMDF/Defines.h>
#include <OnixS/B3/MarketData/UMDF/messaging/Composites.h>

namespace OnixS
{
    namespace B3
    {
        namespace MarketData
        {
            namespace UMDF
            {
                /// Settings for the `OrderBookPool`.
                ///
                /// To improve performance, the OrderBook keeps some of its internals in the preallocated
                /// memory areas (chunks).
                ///
                /// The chunks are initially owned by the OrderBookPool object. The `OrderBookPool` object
                /// is shared between the `OrderBook`s (and can be shared between several instances of the handlers).
                ///
                /// When a chunk is taken from the pool, it is not shared between the other order books,
                /// so the number of the chunks must be at least equal to the number of order books.
                /// A single order book can use from 1 to 255 chunks if necessary.
                ///
                /// The number of books equals the number of securities on a channel or the size of the security filter (if used).
                ///
                /// Placing the order book's internals into a single chunk improves data locality
                /// and can thus improve performance, so the chunk must be sufficient to fit the book content.
                /// On the other hand, making a chunk too big can lead to excessive memory consumption.
                struct OrderBookPoolSettings
                {
                    /// Amount of order book objects.
                    size_t orderBooksAmount = 500;

                    /// Amount of memory chunks.
                    /// @note If the pool is exhausted, the chunks are allocated dynamically, and a warning is raised.
                    size_t chunksAmount = 1000;

                    /// Length of a chunk.
                    /// The maximum chunk length should not be much more than the size of memory necessary to store all orders for security.
                    /// @note The minimal value is 4*1024.
                    size_t chunkLength = 512 * 1024;

                    /// Use Huge pages for chunk allocation.
                    /// @note Takes effect on Linux only.
                    /// @note Huge pages must be enabled on the system level.
                    bool preferHugePage = false;

                    /// Defines growth policy
                    struct GrowthPolicy
                    {
                        enum Policy
                        {
                            ///
                            Addition,

                            ///
                            Multiplication
                        };

                        Policy policy;

                        /// Argument
                        double arg;
                    };

                    GrowthPolicy growthPolicy = {GrowthPolicy::Addition, 1.0f};
                };

                /// A shared memory pool for building order books.
                class ONIXS_B3_UMDF_MD_API OrderBookPool
                {
                public:
                    ///
                    explicit OrderBookPool(const OrderBookPoolSettings&);

                    ///
                    ~OrderBookPool();

                    struct Statistic

===== FILE: ./external/B3/UMDF/include/OnixS/B3/MarketData/UMDF.h =====
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/

#pragma once

#include <OnixS/B3/MarketData/UMDF/ABI.h>
#include <OnixS/B3/MarketData/UMDF/Defines.h>
#include <OnixS/B3/MarketData/UMDF/ErrorListener.h>
#include <OnixS/B3/MarketData/UMDF/Exception.h>
#include <OnixS/B3/MarketData/UMDF/FeedEngine.h>
#include <OnixS/B3/MarketData/UMDF/Handler.h>
#include <OnixS/B3/MarketData/UMDF/HandlerSettings.h>
#include <OnixS/B3/MarketData/UMDF/HandlerStateListener.h>
#include <OnixS/B3/MarketData/UMDF/Integral.h>
#include <OnixS/B3/MarketData/UMDF/LogSettings.h>
#include <OnixS/B3/MarketData/UMDF/MessageListener.h>
#include <OnixS/B3/MarketData/UMDF/Messaging.h>
#include <OnixS/B3/MarketData/UMDF/Replay.h>
#include <OnixS/B3/MarketData/UMDF/Semaphore.h>
#include <OnixS/B3/MarketData/UMDF/Time.h>
#include <OnixS/B3/MarketData/UMDF/WarningListener.h>
#include <OnixS/B3/MarketData/UMDF/WatchService.h>
#include <OnixS/B3/MarketData/UMDF/OrderBook.h>
#include <OnixS/B3/MarketData/UMDF/OrderBookListener.h>

#include <OnixS/B3/MarketData/UMDF/testing/LogPlayer.h>

===== FILE: ./external/B3/UMDF/multicastTest/MulticastTest.cpp =====
// Copyright Onix Solutions Limited [OnixS]. All rights reserved.
//
// This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
// and international copyright treaties.
//
// Access to and use of the software is governed by the terms of the applicable ONIXS Software
// Services Agreement (the Agreement) and Customer end user license agreements granting
// a non-assignable, non-transferable and non-exclusive license to use the software
// for it's own data processing purposes under the terms defined in the Agreement.
//
// Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
// of this source code or associated reference material to any other location for further reproduction
// or redistribution, and any amendments to this copyright notice, are expressly prohibited.
//
// Any reproduction or redistribution for sale or hiring of the Software not in accordance with
// the terms of the Agreement is a violation of copyright law.

#include <ctime>
#include <cerrno>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <sstream>
#include <string>
#include <iostream>
#include <iomanip>

#ifdef _WIN32

#pragma comment(lib, "ws2_32")

#include <WinSock2.h>
#include <WS2tcpip.h>

#define IS_INVALID_SOCKET(SOCKETVAR) SOCKETVAR == INVALID_SOCKET

#if (_MSC_VER < 1600)
#define ETIMEDOUT WSAETIMEDOUT
#define EWOULDBLOCK WSAEWOULDBLOCK
#endif

typedef int socklen_t;
typedef long ssize_t;

int inet_aton(const char* strptr, struct in_addr* addrptr);
char const* getTextOfLastError();

#define SLEEP(n) Sleep(n)

#else

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <ifaddrs.h>
#include <unistd.h>

#define IS_INVALID_SOCKET(SOCKETVAR) SOCKETVAR < 0

char const* getTextOfLastError()
{
    return strerror(errno);
}

#define SLEEP(n) usleep((n*1000))

#endif

bool encode_base64(const void* src_buffer, size_t src_buffer_size, std::string& result);

const char* utcWithMs();

unsigned getSeqNum(const void* buffer);

bool isValidIpAddress(const char* ipAddress);

const char* getInterfaceIpAddress(const char* networkInterface);

void printUsage(const char* prog);

void closeFileWithFlush(FILE* file, bool flush);

const char* getArgs(int index, int size, char** args);

void printStatsHeader(time_t now);

void printStats(time_t now, ssize_t bytes, long numberOfPackets, const void* packet);

int main(int argc, char** argv)
{
    printf("Multicast Test for B3 MDH.\n");

    const int MAX_BUFFER_SIZE = 128 * 1024;
    const int DEFAULT_TIMEOUT = 30;

#ifdef _WIN32
    SOCKET sock = INVALID_SOCKET;
#else
