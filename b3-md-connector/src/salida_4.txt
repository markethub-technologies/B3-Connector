
===== FILE: /workspaces/MarketHub.B3Connector/b3-md-connector/src/core/MdPublishPipeline.hpp =====
// NO crea threads en ctor. NO conoce IO. NO conoce OnixS.
// Enqueue único punto de entrada (hot path friendly).
class MdPublishPipeline final {
public:
    explicit MdPublishPipeline(std::vector<std::unique_ptr<MdPublishWorker>> workers)
        : workers_(std::move(workers))
    {
        if (workers_.empty()) {
            throw std::invalid_argument("MdPublishPipeline: workers empty");
        }
    }

    MdPublishPipeline(const MdPublishPipeline&) = delete;
    MdPublishPipeline& operator=(const MdPublishPipeline&) = delete;

    void start() {
        bool expected = false;
        if (!started_.compare_exchange_strong(expected, true, std::memory_order_acq_rel)) {
            return; // idempotente
        }
        for (auto& w : workers_) {
            w->start();
        }
    }

    void stop(bool drain = true) {
        bool expected = true;
        if (!started_.compare_exchange_strong(expected, false, std::memory_order_acq_rel)) {
            return; // idempotente
        }
        for (auto& w : workers_) {
            w->stop(drain);
        }
    }

    // Hot path: no throw, no alloc.
    // Devuelve false si se dropeó (cola llena).
    bool tryEnqueue(const OrdersSnapshot& snapshot) noexcept {
        const uint32_t shard = shardFor(snapshot.instrumentId);
        return workers_[shard]->tryEnqueue(snapshot);
    }

    uint32_t shardCount() const noexcept {
        return static_cast<uint32_t>(workers_.size());
    }

private:
    // Hash multiplicativo para mejorar distribución si instrumentId tiene patrones.
    static constexpr uint64_t kKnuth = 11400714819323198485ull;

    uint32_t shardFor(uint64_t instrumentId) const noexcept {
        const uint64_t mixed = instrumentId * kKnuth;
        return static_cast<uint32_t>(mixed % workers_.size());
    }

private:
    std::vector<std::unique_ptr<MdPublishWorker>> workers_;
    std::atomic<bool> started_{false};
};

} // namespace b3::md

===== FILE: /workspaces/MarketHub.B3Connector/b3-md-connector/src/core/MboToMbpAggregator.hpp =====
#pragma once

#include "OrdersSnapshot.hpp"
#include "BookSnapshot.hpp"
#include <cstdint>

namespace b3::md {

// Agrega órdenes (MBO) por precio para producir niveles (MBP Top-N).
// No aloca. No tira exceptions. Diseñado para ejecutarse en worker.
inline void aggregateMboWindowToMbpTopN(const OrdersSnapshot& in, BookSnapshot& out) noexcept {
    out.instrumentId = in.instrumentId;
    out.exchangeTsNs = in.exchangeTsNs;
    out.bidCount = 0;
    out.askCount = 0;

    // Limpieza explícita (por si Level no es trivially-zero-safe)
    for (int i = 0; i < BookSnapshot::DEPTH; ++i) {
        out.bids[i] = Level{};
        out.asks[i] = Level{};
    }

    auto add_level = [](Level* levels, uint8_t& count, int64_t priceMantissa, int64_t qty) noexcept {
        // Buscar si ya existe ese precio dentro de los niveles armados
        for (uint8_t i = 0; i < count; ++i) {
            const auto existingPrice = static_cast<int64_t>(levels[i].price);
            if (existingPrice == priceMantissa) {
                levels[i].qty = static_cast<decltype(levels[i].qty)>(
                    static_cast<int64_t>(levels[i].qty) + qty
                );
                return;
            }
        }

        // Nuevo precio si todavía hay espacio
        if (count < BookSnapshot::DEPTH) {
            levels[count].price = static_cast<decltype(levels[count].price)>(priceMantissa);
            levels[count].qty   = static_cast<decltype(levels[count].qty)>(qty);
            ++count;
        }
    };

    // BID side
    {
        
        const uint16_t n = in.bidsCopied; // // solo lo copiado porque hubo descartes de raw donde order == market
        for (uint16_t i = 0; i < n && out.bidCount < BookSnapshot::DEPTH; ++i) {
            const auto& e = in.bids[i];
            if (e.qty == 0) continue;
            if (e.priceMantissa == 0) continue;

            add_level(out.bids, out.bidCount, e.priceMantissa, e.qty);
        }
    }

    // ASK side
    {
        const uint16_t n = in.asksCopied; // solo lo copiado porque hubo descartes de raw donde order == market
        for (uint16_t i = 0; i < n && out.askCount < BookSnapshot::DEPTH; ++i) {
            const auto& e = in.asks[i];
            if (e.qty == 0) continue;
            if (e.priceMantissa == 0) continue;

            add_level(out.asks, out.askCount, e.priceMantissa, e.qty);
        }
    }
}

} // namespace b3::md

===== FILE: /workspaces/MarketHub.B3Connector/b3-md-connector/src/core/MarketDataEngine.hpp =====
#pragma once

#include "MdPublishPipeline.hpp"
#include "IOrderBookView.hpp"
#include "OrdersSnapshot.hpp"

#include "../onixs/OnixsOrdersSnapshotBuilder.hpp"

#include <atomic>
#include <cstdint>

#include <OnixS/B3/MarketData/UMDF/OrderBook.h>

namespace b3::md {

class MarketDataEngine final {
public:
    explicit MarketDataEngine(MdPublishPipeline& pipeline)
        : pipeline_(pipeline)
    {}

    // Vive en el thread del feed (listener OnixS).
    // Construye OrdersSnapshot (ventana MBO) y encola al pipeline.
    void onOrderBookUpdated(const ::OnixS::B3::MarketData::UMDF::OrderBook& orderBook, uint64_t nowNs) noexcept {        
        OrdersSnapshot snapshot{};
        b3::md::onixs::OnixsOrdersSnapshotBuilder::buildFromBook(orderBook, nowNs, snapshot);

        if (!pipeline_.tryEnqueue(snapshot)) {
            drops_.fetch_add(1, std::memory_order_relaxed);
        }
    }

    uint64_t drops() const noexcept {
        return drops_.load(std::memory_order_relaxed);
    }

private:
    MdPublishPipeline& pipeline_;
    std::atomic<uint64_t> drops_{0};
};

} // namespace b3::md

===== FILE: /workspaces/MarketHub.B3Connector/b3-md-connector/src/core/SnapshotQueueSpsc.hpp =====
#pragma once
#include <atomic>
#include <cstddef>
#include <cstdint>
#include <memory>

namespace b3::md {

// FIFO SPSC ring buffer.
// Producer: 1 thread (pipeline/callback)
// Consumer: 1 thread (worker)
template <typename T, size_t CapacityPow2>
class SnapshotQueueSpsc {
    static_assert((CapacityPow2 & (CapacityPow2 - 1)) == 0, "Capacity must be power of two");

public:
    SnapshotQueueSpsc()
        : buffer_(std::make_unique<T[]>(CapacityPow2))
    {}

    bool try_push(const T& v) noexcept {
        const uint32_t t = tail_.load(std::memory_order_relaxed);
        const uint32_t h = head_.load(std::memory_order_acquire);

        if ((t - h) >= CapacityPow2) return false; // full

        buffer_[t & (CapacityPow2 - 1)] = v;
        tail_.store(t + 1, std::memory_order_release);
        return true;
    }

    bool try_pop(T& out) noexcept {
        const uint32_t h = head_.load(std::memory_order_relaxed);
        const uint32_t t = tail_.load(std::memory_order_acquire);

        if (h == t) return false; // empty

        out = buffer_[h & (CapacityPow2 - 1)];
        head_.store(h + 1, std::memory_order_release);
        return true;
    }

    uint32_t size_approx() const noexcept {
        const uint32_t h = head_.load(std::memory_order_acquire);
        const uint32_t t = tail_.load(std::memory_order_acquire);
        return t - h;
    }

private:
    alignas(64) std::atomic<uint32_t> head_{0};
    alignas(64) std::atomic<uint32_t> tail_{0};

    std::unique_ptr<T[]> buffer_;
};

} // namespace b3::md

===== FILE: /workspaces/MarketHub.B3Connector/b3-md-connector/src/testsupport/OrdersSnapshotFromMbpView.hpp =====
#pragma once

#include "../core/OrdersSnapshot.hpp"
#include "../core/IOrderBookView.hpp"

namespace b3::md::testsupport {

// Adapter MBP (niveles) -> OrdersSnapshot (ventana MBO fake)
// Uso exclusivo para tests.
// Cada nivel se copia como si fuera una "orden agregada".
inline OrdersSnapshot makeOrdersSnapshotFromMbpView(
    const IOrderBookView& book) noexcept
{
    OrdersSnapshot snapshot{};

    snapshot.instrumentId = book.instrumentId();
    snapshot.exchangeTsNs = book.exchangeTsNs();

    const uint32_t bidN = book.bidCount();
    const uint32_t askN = book.askCount();

    uint16_t writtenBid = 0;
    for (uint32_t i = 0;
         i < bidN && writtenBid < OrdersSnapshot::K;
         ++i)
    {
        const auto lv = book.bidLevel(i);
        snapshot.bids[writtenBid].priceMantissa = lv.price;
        snapshot.bids[writtenBid].qty = lv.qty;
        ++writtenBid;
    }

    snapshot.bidCountRaw = writtenBid;
    snapshot.bidsCopied  = writtenBid;
    snapshot.bidTruncated = (bidN > OrdersSnapshot::K) ? 1u : 0u;

    uint16_t writtenAsk = 0;
    for (uint32_t i = 0;
         i < askN && writtenAsk < OrdersSnapshot::K;
         ++i)
    {
        const auto lv = book.askLevel(i);
        snapshot.asks[writtenAsk].priceMantissa = lv.price;
        snapshot.asks[writtenAsk].qty = lv.qty;
        ++writtenAsk;
    }

    snapshot.askCountRaw = writtenAsk;
    snapshot.asksCopied  = writtenAsk;
    snapshot.askTruncated = (askN > OrdersSnapshot::K) ? 1u : 0u;

    return snapshot;
}

} // namespace b3::md::testsupport

===== FILE: /workspaces/MarketHub.B3Connector/b3-md-connector/src/testsupport/FakeInstrumentTopicMapper.hpp =====
#pragma once

#include <cstdint>
#include <cstring>
#include <string>
#include <unordered_map>

#include "../src/publishing/PublishEvent.hpp"
#include "../src/mapping/InstrumentRegistry.hpp"

namespace testsupport {

  class FakeInstrumentTopicMapper final {
   public:
    using InstrumentId = b3::md::mapping::InstrumentId;

    FakeInstrumentTopicMapper(std::initializer_list<std::pair<InstrumentId, std::string>> init) {
      for (const auto& kv : init) map_.emplace(kv.first, kv.second);
    }

    bool tryWriteTopic(InstrumentId iid, b3::md::publishing::PublishEvent& ev) const noexcept {
      auto it = map_.find(iid);
      if (it == map_.end()) return false;

      const auto& s = it->second;
      if (s.empty() || s.size() > b3::md::publishing::PublishEvent::kMaxTopic) return false;

      ev.topicLen = static_cast<std::uint8_t>(s.size());
      std::memcpy(ev.topic, s.data(), s.size());
      return true;
    }

   private:
    std::unordered_map<InstrumentId, std::string> map_;
  };

} // namespace testsupport

===== FILE: /workspaces/MarketHub.B3Connector/b3-md-connector/src/mapping/MdSnapshotMapper.hpp =====
#pragma once
#include "../core/BookSnapshot.hpp"
#include <string>

namespace b3::md {

// Mapper puro: snapshot -> bytes
// (stub determinístico para tests; luego será Protobuf)
class MdSnapshotMapper {
public:
    void mapAndSerialize(const BookSnapshot& s,
                         std::string& out) const {
        out.clear();
        out.reserve(64);
        out.append("iid=");
        out.append(std::to_string(s.instrumentId));
        out.append(";ts=");
        out.append(std::to_string(s.exchangeTsNs));
        out.append(";bc=");
        out.append(std::to_string(s.bidCount));
        out.append(";ac=");
        out.append(std::to_string(s.askCount));
    }
};

} // namespace b3::md

===== FILE: /workspaces/MarketHub.B3Connector/b3-md-connector/src/mapping/InstrumentTopicMapper.hpp =====
#pragma once

#include <cstdint>
#include <cstring>
#include <string>
#include <cstdio>

#include "../publishing/PublishEvent.hpp"
#include "InstrumentRegistry.hpp"

namespace b3::md::mapping {

  /**
   * @brief Construye topics de marketdata en formato: "<SYMBOL>"
   *
   * las subscripciones y el publish usan SIEMPRE símbolo puro,   *
   */
  class InstrumentTopicMapper final {
   public:
    explicit InstrumentTopicMapper(const InstrumentRegistry &registry) : registry_(registry) {}

    InstrumentTopicMapper(const InstrumentTopicMapper &) = delete;
    InstrumentTopicMapper &operator=(const InstrumentTopicMapper &) = delete;

    // Llena ev.topic + ev.topicLen. Devuelve false si excede kMaxTopic.
    bool tryWriteTopic(InstrumentId iid, b3::md::publishing::PublishEvent &ev) const noexcept {
      const std::string *sym = registry_.tryResolve(iid);

      // Fallback en pruebas / warmup: evitamos cortar publish.
      // Ej: "IID:123456"
      if (!sym) {
        return writeFallback(iid, ev);
      }

      const std::size_t n = sym->size();
      if (n == 0 || n > b3::md::publishing::PublishEvent::kMaxTopic)
        return false;

      ev.topicLen = static_cast<std::uint8_t>(n);
      std::memcpy(ev.topic, sym->data(), n);
      return true;
    }

   private:
    static bool writeFallback(InstrumentId iid, b3::md::publishing::PublishEvent &ev) noexcept {
      // "IID:" + up to 20 digits (uint64) -> max 24
      char buf[32];
      const int wrote =
          std::snprintf(buf, sizeof(buf), "IID:%llu", static_cast<unsigned long long>(iid));
      if (wrote <= 0)
        return false;
      const std::size_t n = static_cast<std::size_t>(wrote);
      if (n > b3::md::publishing::PublishEvent::kMaxTopic)
        return false;

      ev.topicLen = static_cast<std::uint8_t>(n);
      std::memcpy(ev.topic, buf, n);
      return true;
    }

   private:
    const InstrumentRegistry &registry_;
  };

} // namespace b3::md::mapping

===== FILE: /workspaces/MarketHub.B3Connector/b3-md-connector/src/mapping/InstrumentRegistry.hpp =====
#pragma once

#include <shared_mutex>
#include <string>
#include <unordered_map>

namespace b3::md::mapping {

  using InstrumentId = std::uint64_t;

  class InstrumentRegistry final {
   public:
    InstrumentRegistry() = default;
    InstrumentRegistry(const InstrumentRegistry &) = delete;
    InstrumentRegistry &operator=(const InstrumentRegistry &) = delete;

    // Lectura: shared_lock => muchos readers simultáneos.
    const std::string *tryResolve(InstrumentId iid) const noexcept {
      std::shared_lock<std::shared_mutex> lock(mu_);
      auto it = byId_.find(iid);
      if (it == byId_.end())
        return nullptr;
      return &it->second;
    }

    // Escritura: unique_lock => 1 writer, bloquea readers mientras dura.
    void upsert(InstrumentId iid, std::string symbol) {
      std::unique_lock<std::shared_mutex> lock(mu_);
      byId_[iid] = std::move(symbol);
    }

    // Útil cuando recibís un fragmento de SecurityList con muchas entradas.
    template <class It>
    void bulkUpsert(It begin, It end) {
      std::unique_lock<std::shared_mutex> lock(mu_);
      for (auto it = begin; it != end; ++it) {
        byId_[it->first] = it->second;
      }
    }

    std::size_t size() const noexcept {
      std::shared_lock<std::shared_mutex> lock(mu_);
      return byId_.size();
    }

   private:
    mutable std::shared_mutex mu_;
    std::unordered_map<InstrumentId, std::string> byId_;
  };

} // namespace b3::md::mapping

===== FILE: /workspaces/MarketHub.B3Connector/b3-md-connector/src/MessagingLibIntegrationTest.cpp =====
#include "core/MarketDataEngine.hpp"
#include <clients/PublisherSubscriber.h>
#include <models/messages.pb.h>
#include <models/messageTypes.h>
#include <models/risk_management.pb.h>
#include <iostream>
#include <spdlog/spdlog.h>
