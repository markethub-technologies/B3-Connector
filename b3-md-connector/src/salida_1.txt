
===== FILE: /workspaces/MarketHub.B3Connector/b3-md-connector/src/main.cpp =====
#include <OnixS/B3/MarketData/UMDF.h>

#include "core/MdPublishPipeline.hpp"
#include "core/MdPublishWorker.hpp"
#include "core/MarketDataEngine.hpp"
#include "onixs/OnixsOrderBookListener.hpp"

#include "mapping/MdSnapshotMapper.hpp"
#include "mapping/InstrumentTopicMapper.hpp"

// NEW: concentrador PUB (fan-in desde shards)
#include "publishing/ZmqPublishConcentrator.hpp"

#include <cstdint>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <unordered_map>
#include <vector>

using namespace OnixS::B3::MarketData::UMDF;

namespace {

  // Config ultra simple: key=value por línea, ignora vacíos y #comentarios.
  std::unordered_map<std::string, std::string> loadKeyValueFile(const std::string &path) {
    std::unordered_map<std::string, std::string> kv;

    std::ifstream in(path);
    if (!in.is_open()) {
      std::cerr << "[config] cannot open file: " << path << "\n";
      return kv;
    }

    std::string line;
    while (std::getline(in, line)) {
      // trim básico
      auto trim = [](std::string &s) {
        while (!s.empty() &&
               (s.back() == ' ' || s.back() == '\r' || s.back() == '\n' || s.back() == '\t'))
          s.pop_back();
        size_t i = 0;
        while (i < s.size() && (s[i] == ' ' || s[i] == '\t')) ++i;
        if (i > 0)
          s.erase(0, i);
      };

      trim(line);
      if (line.empty())
        continue;
      if (!line.empty() && line[0] == '#')
        continue;

      const auto eq = line.find('=');
      if (eq == std::string::npos)
        continue;

      std::string key = line.substr(0, eq);
      std::string val = line.substr(eq + 1);

      trim(key);
      trim(val);
      if (!key.empty())
        kv[key] = val;
    }

    return kv;
  }

  std::string getOr(const std::unordered_map<std::string, std::string> &kv, const std::string &key,
                    const std::string &def) {
    auto it = kv.find(key);
    return (it == kv.end()) ? def : it->second;
  }

  int getOrInt(const std::unordered_map<std::string, std::string> &kv, const std::string &key,
               int def) {
    auto it = kv.find(key);
    if (it == kv.end())
      return def;
    try {
      return std::stoi(it->second);
    } catch (...) {
      return def;
    }
  }

} // namespace

int main(int argc, char **argv) {
  const std::string configPath = (argc >= 2) ? argv[1] : "b3-md-connector.conf";
  const auto cfg = loadKeyValueFile(configPath);

  // -------------------------
  // Config
  // -------------------------
  const std::string licenseDir = getOr(cfg, "onixs.license_dir", "./LICENSE_DIR_TODO");
  const std::string connectivityFile =
      getOr(cfg, "onixs.connectivity_file", "./CONNECTIVITY_TODO.xml");
  const int channel = getOrInt(cfg, "onixs.channel", 80);

  const std::string ifA = getOr(cfg, "onixs.if_a", "");
  const std::string ifB = getOr(cfg, "onixs.if_b", "");

  const int shards = getOrInt(cfg, "md.shards", 4);

  // NEW: PUB endpoint (un solo puerto para todos los topics)
  const std::string pubEndpoint = getOr(cfg, "pub.endpoint", "tcp://*:8081");

  std::cerr << "[startup] config=" << configPath << "\n";
  std::cerr << "[startup] onixs.license_dir=" << licenseDir << "\n";
  std::cerr << "[startup] onixs.connectivity_file=" << connectivityFile << "\n";
  std::cerr << "[startup] onixs.channel=" << channel << "\n";
  std::cerr << "[startup] onixs.if_a=" << (ifA.empty() ? "<auto>" : ifA) << "\n";
  std::cerr << "[startup] onixs.if_b=" << (ifB.empty() ? "<auto>" : ifB) << "\n";
  std::cerr << "[startup] md.shards=" << shards << "\n";
  std::cerr << "[startup] pub.endpoint=" << pubEndpoint << "\n";

  // -------------------------
  // Mapping instrumentId -> human symbol
  // -------------------------
  b3::md::mapping::InstrumentRegistry registry;

  // TODO: al startup, llenás registry con SecurityList via OnixS FIX (35=y)
  // registry.upsert(123456, "PETR4"); etc.

  b3::md::mapping::InstrumentTopicMapper topicMapper(registry);

  // -------------------------
  // Publishing concentrator (1 thread, 1 PUB socket)
  // -------------------------
  b3::md::publishing::ZmqPublishConcentrator concentrator(pubEndpoint,
                                                          static_cast<uint32_t>(shards));
  concentrator.start();

  // -------------------------
  // Pipeline
  // -------------------------
  b3::md::MdSnapshotMapper mapper;

  std::vector<std::unique_ptr<b3::md::MdPublishWorker>> workers;
  workers.reserve(static_cast<size_t>(shards));

  for (int i = 0; i < shards; ++i) {
    workers.emplace_back(std::make_unique<b3::md::MdPublishWorker>(static_cast<uint32_t>(i), mapper,
                                                                   concentrator, topicMapper));
  }

  b3::md::MdPublishPipeline pipeline(std::move(workers));
  pipeline.start();

  // -------------------------
  // Engine + Listener OnixS
  // -------------------------
  b3::md::MarketDataEngine engine(pipeline);
  b3::md::onixs::OnixsOrderBookListener orderBookListener(engine);

  // -------------------------
  // OnixS Handler
  // -------------------------
  try {
    HandlerSettings settings;
    settings.licenseDirectory = licenseDir.c_str();
    settings.buildOrderBooks = true;

    settings.loadFeeds(channel, connectivityFile.c_str());

    if (!ifA.empty())
      settings.networkInterfaceA = ifA.c_str();
    if (!ifB.empty())
      settings.networkInterfaceB = ifB.c_str();

    Handler handler(settings);
    handler.registerOrderBookListener(&orderBookListener);

    std::cerr << "[startup] starting OnixS handler...\n";
    handler.start();

    std::cerr << "[runtime] running. Press ENTER to stop...\n";
    std::cin.get();

    std::cerr << "[shutdown] stopping OnixS handler...\n";
    handler.stop(true);
  } catch (const std::exception &ex) {
    std::cerr << "[fatal] exception: " << ex.what() << "\n";
  } catch (...) {
    std::cerr << "[fatal] unknown exception\n";
  }

  // -------------------------
  // Shutdown: stop pipeline first (workers stop producing publish events),
  // then stop concentrator (drains remaining events).
  // -------------------------
  std::cerr << "[shutdown] stopping pipeline...\n";
  pipeline.stop(true);

  std::cerr << "[shutdown] stopping publisher concentrator...\n";
  concentrator.stop();

  std::cerr << "[shutdown] done.\n";
  return 0;
}

===== FILE: /workspaces/MarketHub.B3Connector/b3-md-connector/src/telemetry/LogQueueSpsc.hpp =====
#pragma once
#include <atomic>
#include <cstddef>
#include <cstdint>
#include <type_traits>

namespace b3::md::telemetry {

template <typename T, size_t Capacity>
class LogQueueSpsc {
    static_assert(Capacity >= 2, "Capacity must be >= 2");
    static_assert(std::is_trivially_copyable_v<T>, "T must be trivially copyable");

public:
    bool try_push(const T& v) noexcept {
        const uint32_t t = tail_.load(std::memory_order_relaxed);
        const uint32_t next = inc(t);
        if (next == head_.load(std::memory_order_acquire)) return false; // full
        buffer_[t] = v;
        tail_.store(next, std::memory_order_release);
        return true;
    }

    bool try_pop(T& out) noexcept {
        const uint32_t h = head_.load(std::memory_order_relaxed);
        if (h == tail_.load(std::memory_order_acquire)) return false; // empty
        out = buffer_[h];
        head_.store(inc(h), std::memory_order_release);
        return true;
    }

private:
    static constexpr uint32_t inc(uint32_t v) noexcept {
        v++;
        if (v >= Capacity) v = 0;
        return v;
    }

    alignas(64) T buffer_[Capacity]{};
    alignas(64) std::atomic<uint32_t> head_{0};
    alignas(64) std::atomic<uint32_t> tail_{0};
};

} // namespace b3::md::telemetry

===== FILE: /workspaces/MarketHub.B3Connector/b3-md-connector/src/telemetry/SpdlogLogPublisher.hpp =====
#pragma once
#include "LogEvent.hpp"
#include "LogQueueSpsc.hpp"

#include <atomic>
#include <chrono>
#include <thread>

#include <spdlog/spdlog.h>

namespace b3::md::telemetry {

template <size_t Capacity>
class SpdlogLogPublisher {
public:
    SpdlogLogPublisher() = default;

    // Producer API (SPSC): call only from ONE producer thread (owner)
    bool try_publish(const LogEvent& e) noexcept {
        if (!queue_.try_push(e)) {
            dropped_.fetch_add(1, std::memory_order_relaxed);
            return false;
        }
        return true;
    }

    void start() {
        running_.store(true, std::memory_order_release);
        thread_ = std::thread([this] { this->run(); });
    }

    void stop() {
        running_.store(false, std::memory_order_release);
        if (thread_.joinable()) thread_.join();
    }

    uint64_t dropped() const noexcept {
        return dropped_.load(std::memory_order_relaxed);
    }

private:
    void run() noexcept {
        using namespace std::chrono_literals;

        auto nextDropReport = std::chrono::steady_clock::now() + 5s;
        uint64_t lastDropped = 0;

        LogEvent e{};
        while (running_.load(std::memory_order_acquire)) {
            bool didWork = false;

            while (queue_.try_pop(e)) {
                didWork = true;
                emit_to_spdlog(e);
            }

            const auto now = std::chrono::steady_clock::now();
            if (now >= nextDropReport) {
                const uint64_t d = dropped_.load(std::memory_order_relaxed);
                const uint64_t delta = d - lastDropped;
                lastDropped = d;
                nextDropReport = now + 5s;

                if (delta > 0) {
                    spdlog::warn("[telemetry] log queue saturated: dropped={} in last 5s", delta);
                }
            }

            if (!didWork) {
                std::this_thread::sleep_for(1ms);
            }
        }

        // Drain remaining events on shutdown
        while (queue_.try_pop(e)) {
            emit_to_spdlog(e);
        }
    }

    static const char* to_component(Component c) noexcept {
        switch (c) {
            case Component::Core:       return "core";
            case Component::Pipeline:   return "pipeline";
            case Component::Worker:     return "worker";
            case Component::Mapping:    return "mapping";
            case Component::Publishing: return "publishing";
            case Component::Adapter:    return "adapter";
            default:                    return "unknown";
        }
    }

    static const char* to_code(Code code) noexcept {
        switch (code) {
            case Code::Startup:         return "startup";
            case Code::Shutdown:        return "shutdown";
            case Code::HealthTick:      return "health_tick";
            case Code::Drops:           return "drops";
            case Code::QueueSaturated:  return "queue_saturated";
            case Code::WorkerException: return "worker_exception";
            case Code::PublishFailed:   return "publish_failed";
            case Code::SerializeFailed: return "serialize_failed";
            case Code::Backpressured:   return "backpressured";
            default:                    return "unknown";
        }
    }

    static void emit_to_spdlog(const LogEvent& e) {
        const char* comp = to_component(e.component);
        const char* code = to_code(e.code);

        // Minimal formatting; do string work here (NOT in producers)
        if (e.level == LogLevel::Error) {
            spdlog::error("[{}] code={} iid={} shard={} arg0={} arg1={}",
                          comp, code, e.instrumentId, e.shard, e.arg0, e.arg1);
        } else {
            // Health and Info -> info for now (can map Health->info too)
            spdlog::info("[{}] code={} iid={} shard={} arg0={} arg1={}",
                         comp, code, e.instrumentId, e.shard, e.arg0, e.arg1);
        }
    }

private:
    LogQueueSpsc<LogEvent, Capacity> queue_{};
    std::atomic<bool> running_{false};
    std::thread thread_{};
    std::atomic<uint64_t> dropped_{0};
};


===== FILE: /workspaces/MarketHub.B3Connector/b3-md-connector/src/telemetry/LogEvent.hpp =====
#pragma once
#include <cstdint>
#include <type_traits>

namespace b3::md::telemetry {

  enum class LogLevel : uint8_t { Health = 0, Info = 1, Error = 2 };

  enum class Component : uint8_t {
    Core = 0,
    Pipeline = 1,
    Worker = 2,
    Mapping = 3,
    Publishing = 4,
    Adapter = 5
  };

  enum class Code : uint16_t {
    Startup = 1,
    Shutdown = 2,

    HealthTick = 10,
    Drops = 11,
    QueueSaturated = 12,

    WorkerException = 100,
    PublishFailed = 101,
    SerializeFailed = 102,
    Backpressured = 103,
  };

  struct LogEvent {
    uint64_t tsNs{0};

    LogLevel level{LogLevel::Info};
    Component component{Component::Core};
    Code code{Code::HealthTick};

    uint64_t instrumentId{0}; // 0 = n/a
    uint16_t shard{0};        // 0 = n/a
    uint16_t reserved{0};

    uint64_t arg0{0};
    uint64_t arg1{0};
  };

  static_assert(std::is_trivially_copyable_v<LogEvent>);
  static_assert(std::is_trivially_destructible_v<LogEvent>);

} // namespace b3::md::telemetry

===== FILE: /workspaces/MarketHub.B3Connector/b3-md-connector/src/onixs/OnixOrderBookView.hpp =====
#pragma once

#include "../core/IOrderBookView.hpp"
#include "../core/BookSnapshot.hpp" // Level + kTopN (o el const que uses)

#include <OnixS/B3/MarketData/UMDF/OrderBook.h>

#include <algorithm>
#include <chrono>
#include <cstdint>
#include <type_traits>
#include <utility>

namespace b3::md::onixs {

  class OnixsOrderBookView final : public b3::md::IOrderBookView {
   public:
    explicit OnixsOrderBookView(const ::OnixS::B3::MarketData::UMDF::OrderBook &book) noexcept
        : book_(book) {}

    uint64_t instrumentId() const noexcept override {
      // SDK: InstrumentId es UInt64
      const auto iid64 = static_cast<uint64_t>(book_.instrumentId());
      return static_cast<uint64_t>(
          iid64); // asumimos entra en 32 bits (si no, subimos el tipo en core)
    }

    uint64_t exchangeTsNs() const noexcept override {
      // OrderBook no expone timestamp.
      // Fallback: monotonic now (sirve para detectar backlog/jitter, no latencia real
      // exchange->publish).
      const auto now = std::chrono::steady_clock::now().time_since_epoch();
      return static_cast<uint64_t>(
          std::chrono::duration_cast<std::chrono::nanoseconds>(now).count());
    }

    uint32_t bidCount() const noexcept override {
      const auto n = book_.bids().size();
      return clampToTopN(n);
    }

    uint32_t askCount() const noexcept override {
      const auto n = book_.asks().size();
      return clampToTopN(n);
    }

    b3::md::Level bidLevel(uint32_t i) const noexcept override {
      const auto r = book_.bids();
      const auto n = r.size();
      const auto top = clampToTopN(n);

      if (i >= top || n == 0)
        return b3::md::Level{};

