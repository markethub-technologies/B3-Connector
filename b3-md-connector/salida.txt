
===== FILE: ./src/main.cpp =====
#include <OnixS/B3/MarketData/UMDF.h>

#include "core/MdPublishPipeline.hpp"
#include "core/MdPublishWorker.hpp"
#include "core/MarketDataEngine.hpp"
#include "onixs/OnixsOrderBookListener.hpp"

#include "mapping/MdSnapshotMapper.hpp"
#include "publishing/IMdPublisher.hpp"
#include "telemetry/LogEvent.hpp"

// TODO: reemplazar por tus implementaciones reales
#include "testsupport/FakePublisher.hpp"   // placeholder publisher
#include "telemetry/SpdlogLogPublisher.hpp"

#include <cstdint>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <unordered_map>
#include <vector>

using namespace OnixS::B3::MarketData::UMDF;

namespace {

// Config ultra simple: key=value por línea, ignora vacíos y #comentarios.
std::unordered_map<std::string, std::string> loadKeyValueFile(const std::string& path) {
    std::unordered_map<std::string, std::string> kv;

    std::ifstream in(path);
    if (!in.is_open()) {
        std::cerr << "[config] cannot open file: " << path << "\n";
        return kv;
    }

    std::string line;
    while (std::getline(in, line)) {
        // trim básico
        auto trim = [](std::string& s) {
            while (!s.empty() && (s.back() == ' ' || s.back() == '\r' || s.back() == '\n' || s.back() == '\t')) s.pop_back();
            size_t i = 0;
            while (i < s.size() && (s[i] == ' ' || s[i] == '\t')) ++i;
            if (i > 0) s.erase(0, i);
        };

        trim(line);
        if (line.empty()) continue;
        if (!line.empty() && line[0] == '#') continue;

        const auto eq = line.find('=');
        if (eq == std::string::npos) continue;

        std::string key = line.substr(0, eq);
        std::string val = line.substr(eq + 1);

        trim(key);
        trim(val);
        if (!key.empty()) kv[key] = val;
    }

    return kv;
}

std::string getOr(const std::unordered_map<std::string, std::string>& kv,
                  const std::string& key,
                  const std::string& def) {
    auto it = kv.find(key);
    return (it == kv.end()) ? def : it->second;
}

int getOrInt(const std::unordered_map<std::string, std::string>& kv,
             const std::string& key,
             int def) {
    auto it = kv.find(key);
    if (it == kv.end()) return def;
    try {
        return std::stoi(it->second);
    } catch (...) {
        return def;
    }
}

} // namespace

int main(int argc, char** argv) {
    const std::string configPath = (argc >= 2) ? argv[1] : "b3-md-connector.conf";
    const auto cfg = loadKeyValueFile(configPath);

    // -------------------------
    // Placeholders / defaults
    // -------------------------
    const std::string licenseDir       = getOr(cfg, "onixs.license_dir",       "./LICENSE_DIR_TODO");
    const std::string connectivityFile = getOr(cfg, "onixs.connectivity_file", "./CONNECTIVITY_TODO.xml");
    const int channel                  = getOrInt(cfg, "onixs.channel",        80);

    const std::string ifA              = getOr(cfg, "onixs.if_a", "");

===== FILE: ./src/telemetry/LogQueueSpsc.hpp =====
#pragma once
#include <atomic>
#include <cstddef>
#include <cstdint>
#include <type_traits>

namespace b3::md::telemetry {

template <typename T, size_t Capacity>
class LogQueueSpsc {
    static_assert(Capacity >= 2, "Capacity must be >= 2");
    static_assert(std::is_trivially_copyable_v<T>, "T must be trivially copyable");

public:
    bool try_push(const T& v) noexcept {
        const uint32_t t = tail_.load(std::memory_order_relaxed);
        const uint32_t next = inc(t);
        if (next == head_.load(std::memory_order_acquire)) return false; // full
        buffer_[t] = v;
        tail_.store(next, std::memory_order_release);
        return true;
    }

    bool try_pop(T& out) noexcept {
        const uint32_t h = head_.load(std::memory_order_relaxed);
        if (h == tail_.load(std::memory_order_acquire)) return false; // empty
        out = buffer_[h];
        head_.store(inc(h), std::memory_order_release);
        return true;
    }

private:
    static constexpr uint32_t inc(uint32_t v) noexcept {
        v++;
        if (v >= Capacity) v = 0;
        return v;
    }

    alignas(64) T buffer_[Capacity]{};
    alignas(64) std::atomic<uint32_t> head_{0};
    alignas(64) std::atomic<uint32_t> tail_{0};
};

} // namespace b3::md::telemetry

===== FILE: ./src/telemetry/SpdlogLogPublisher.hpp =====
#pragma once
#include "LogEvent.hpp"
#include "LogQueueSpsc.hpp"

#include <atomic>
#include <chrono>
#include <thread>

#include <spdlog/spdlog.h>

namespace b3::md::telemetry {

template <size_t Capacity>
class SpdlogLogPublisher {
public:
    SpdlogLogPublisher() = default;

    // Producer API (SPSC): call only from ONE producer thread (owner)
    bool try_publish(const LogEvent& e) noexcept {
        if (!queue_.try_push(e)) {
            dropped_.fetch_add(1, std::memory_order_relaxed);
            return false;
        }
        return true;
    }

    void start() {
        running_.store(true, std::memory_order_release);
        thread_ = std::thread([this] { this->run(); });
    }

    void stop() {
        running_.store(false, std::memory_order_release);
        if (thread_.joinable()) thread_.join();
    }

    uint64_t dropped() const noexcept {
        return dropped_.load(std::memory_order_relaxed);
    }

private:
    void run() noexcept {
        using namespace std::chrono_literals;

        auto nextDropReport = std::chrono::steady_clock::now() + 5s;
        uint64_t lastDropped = 0;

        LogEvent e{};
        while (running_.load(std::memory_order_acquire)) {
            bool didWork = false;

            while (queue_.try_pop(e)) {
                didWork = true;
                emit_to_spdlog(e);
            }

            const auto now = std::chrono::steady_clock::now();
            if (now >= nextDropReport) {
                const uint64_t d = dropped_.load(std::memory_order_relaxed);
                const uint64_t delta = d - lastDropped;
                lastDropped = d;
                nextDropReport = now + 5s;

                if (delta > 0) {
                    spdlog::warn("[telemetry] log queue saturated: dropped={} in last 5s", delta);
                }
            }

            if (!didWork) {
                std::this_thread::sleep_for(1ms);
            }
        }

        // Drain remaining events on shutdown
        while (queue_.try_pop(e)) {
            emit_to_spdlog(e);
        }
    }

    static const char* to_component(Component c) noexcept {
        switch (c) {
            case Component::Core:       return "core";
            case Component::Pipeline:   return "pipeline";
            case Component::Worker:     return "worker";
            case Component::Mapping:    return "mapping";
            case Component::Publishing: return "publishing";
            case Component::Adapter:    return "adapter";
            default:                    return "unknown";
        }
    }

    static const char* to_code(Code code) noexcept {
        switch (code) {
            case Code::Startup:         return "startup";
            case Code::Shutdown:        return "shutdown";
            case Code::HealthTick:      return "health_tick";
            case Code::Drops:           return "drops";
            case Code::QueueSaturated:  return "queue_saturated";
            case Code::WorkerException: return "worker_exception";
            case Code::PublishFailed:   return "publish_failed";

===== FILE: ./src/telemetry/LogEvent.hpp =====
#pragma once
#include <cstdint>
#include <type_traits>

namespace b3::md::telemetry {

enum class LogLevel : uint8_t { Health = 0, Info = 1, Error = 2 };

enum class Component : uint8_t {
    Core = 0, Pipeline = 1, Worker = 2, Mapping = 3, Publishing = 4, Adapter = 5
};

enum class Code : uint16_t {
    Startup = 1,
    Shutdown = 2,

    HealthTick = 10,
    Drops = 11,
    QueueSaturated = 12,

    WorkerException = 100,
    PublishFailed = 101,
    SerializeFailed = 102,
    Backpressured = 103,
};

struct LogEvent {
    uint64_t tsNs{0};

    LogLevel level{LogLevel::Info};
    Component component{Component::Core};
    Code code{Code::HealthTick};

    uint32_t instrumentId{0}; // 0 = n/a
    uint16_t shard{0};        // 0 = n/a
    uint16_t reserved{0};

    uint64_t arg0{0};
    uint64_t arg1{0};
};

static_assert(std::is_trivially_copyable_v<LogEvent>);
static_assert(std::is_trivially_destructible_v<LogEvent>);

} // namespace b3::md::telemetry

===== FILE: ./src/onixs/OnixOrderBookView.hpp =====
#pragma once

#include "../core/IOrderBookView.hpp"
#include "../core/BookSnapshot.hpp" // Level + kTopN (o el const que uses)

#include <OnixS/B3/MarketData/UMDF/OrderBook.h>

#include <algorithm>
#include <chrono>
#include <cstdint>
#include <type_traits>
#include <utility>

namespace b3::md::onixs {

class OnixsOrderBookView final : public b3::md::IOrderBookView {
public:
    explicit OnixsOrderBookView(const ::OnixS::B3::MarketData::UMDF::OrderBook& book) noexcept
        : book_(book) {}

    uint32_t instrumentId() const noexcept override {
        // SDK: InstrumentId es UInt64
        const auto iid64 = static_cast<uint64_t>(book_.instrumentId());
        return static_cast<uint32_t>(iid64); // asumimos entra en 32 bits (si no, subimos el tipo en core)
    }

    uint64_t exchangeTsNs() const noexcept override {
        // OrderBook no expone timestamp.
        // Fallback: monotonic now (sirve para detectar backlog/jitter, no latencia real exchange->publish).
        const auto now = std::chrono::steady_clock::now().time_since_epoch();
        return static_cast<uint64_t>(
            std::chrono::duration_cast<std::chrono::nanoseconds>(now).count()
        );
    }

    uint32_t bidCount() const noexcept override {
        const auto n = book_.bids().size();
        return clampToTopN(n);
    }

    uint32_t askCount() const noexcept override {
        const auto n = book_.asks().size();
        return clampToTopN(n);
    }

    b3::md::Level bidLevel(uint32_t i) const noexcept override {
        const auto r = book_.bids();
        const auto n = r.size();
        const auto top = clampToTopN(n);

        if (i >= top || n == 0) return b3::md::Level{};

        // bids() en header dice "ascending bid prices" => mejor bid al final
        const size_t idx = (n - 1) - static_cast<size_t>(i);
        return mapOrderToLevel(r[idx]);
    }

    b3::md::Level askLevel(uint32_t i) const noexcept override {
        const auto r = book_.asks();
        const auto n = r.size();
        const auto top = clampToTopN(n);

        if (i >= top || n == 0) return b3::md::Level{};

        // Asumimos mejor ask al principio (lo típico).
        // Si ves que asks() viene descending realmente, cambiá a: idx = (n - 1) - i
        const size_t idx = static_cast<size_t>(i);
        return mapOrderToLevel(r[idx]);
    }

private:
    static uint32_t clampToTopN(size_t n) noexcept {
        // si tu TopN está en otro lado, ajustá este nombre:
        constexpr size_t TopN = static_cast<size_t>(5);
        return static_cast<uint32_t>(std::min(n, TopN));
    }

    static b3::md::Level mapOrderToLevel(const ::OnixS::B3::MarketData::UMDF::Order& o) noexcept {
        b3::md::Level lv{};

        // ---- qty ----
        // SDK: Quantity = Int64
        using QtyFieldT = decltype(lv.qty);
        lv.qty = static_cast<QtyFieldT>(o.quantity());

        // ---- price ----
        // SDK: PriceOptional (4 decimals), marketOrder => isNull()
        const auto p = o.price();
        if (p.isNull()) {
            // market order: precio "sin valor"
            // mantenemos default 0
            return lv;
        }

        const auto mant = p.mantissa(); // entero con 4 decimales

        using PriceFieldT = decltype(lv.price);
        if constexpr (std::is_floating_point_v<PriceFieldT>) {
            // Guardamos como double/float en unidades reales
            lv.price = static_cast<PriceFieldT>(static_cast<double>(mant) / 10000.0);

===== FILE: ./src/onixs/OnixsOrdersSnapshotBuilder.hpp =====
#pragma once

#include "../core/OrdersSnapshot.hpp"

#include <cstddef>
#include <cstdint>
#include <chrono>

// OnixS
#include <OnixS/B3/MarketData/UMDF/OrderBook.h> // o el include correcto en tu entorno

namespace b3::md::onixs {

// Builder hot-path: copia una ventana acotada de órdenes (MBO) desde el OrderBook de OnixS.
// Reglas:
// - NO aloca
// - NO loguea
// - NO agrupa por niveles (eso se hace en worker)
// - saltea órdenes con precio null (market orders), porque no aportan a MBP por niveles de precio.
struct OnixsOrdersSnapshotBuilder final {
    using OrderBook = OnixS::B3::MarketData::UMDF::OrderBook;

    static inline void buildFromBook(const OrderBook& book, b3::md::OrdersSnapshot& out) noexcept {
        // Reset POD
        out = b3::md::OrdersSnapshot{};

        // Metadata base
        out.instrumentId = static_cast<uint32_t>(book.instrumentId());
        out.rptSeq       = static_cast<uint64_t>(book.lastRptSeq());
        out.channelSeq   = static_cast<uint64_t>(book.lastMessageSeqNumApplied());

        //TODO: tratar de meter el timestamp del exchange.
        using clock = std::chrono::system_clock;
        const auto now = clock::now().time_since_epoch();
        out.exchangeTsNs =
            static_cast<uint64_t>(
                std::chrono::duration_cast<std::chrono::nanoseconds>(now).count());

        // Copia bids (según header: bids() => ascending bid prices
        // TODO: el comentario del SDK parece raro, que viene al revés, validar en runtime, 
        {
            const auto bidsRange = book.bids();
            const size_t raw = bidsRange.size();
            out.bidCountRaw = static_cast<uint16_t>(raw > 0xFFFFu ? 0xFFFFu : raw);

            uint16_t copied = 0;
            bool truncated = false;

            // Recorremos y copiamos solo precios válidos hasta K
            for (size_t i = 0; i < raw; ++i) {
                const auto& ord = bidsRange[i];

                const auto px = ord.price();
                if (px.isNull()) {
                    // Market order: se saltea; no contribuye al agregado MBP por niveles de precio.
                    continue;
                }

                if (copied >= b3::md::OrdersSnapshot::K) {
                    truncated = true;
                    break;
                }

                out.bids[copied].priceMantissa = static_cast<int64_t>(px.mantissa());
                out.bids[copied].qty          = static_cast<int64_t>(ord.quantity());
                ++copied;
            }

            out.bidsCopied   = copied;
            out.bidTruncated = truncated ? 1 : 0;
        }

        // Copia asks
        {
            const auto asksRange = book.asks();
            const size_t raw = asksRange.size();
            out.askCountRaw = static_cast<uint16_t>(raw > 0xFFFFu ? 0xFFFFu : raw);

            uint16_t copied = 0;
            bool truncated = false;

            for (size_t i = 0; i < raw; ++i) {
                const auto& ord = asksRange[i];

                const auto px = ord.price();
                if (px.isNull()) {
                    // Market order: se saltea; no contribuye al agregado MBP por niveles de precio.
                    continue;
                }

                if (copied >= b3::md::OrdersSnapshot::K) {
                    truncated = true;
                    break;
                }

                out.asks[copied].priceMantissa = static_cast<int64_t>(px.mantissa());
                out.asks[copied].qty          = static_cast<int64_t>(ord.quantity());
                ++copied;
            }


===== FILE: ./src/onixs/OnixsOrderBookListener.hpp =====
#pragma once

#include "../core/MarketDataEngine.hpp"

#include <OnixS/B3/MarketData/UMDF/OrderBookListener.h>
#include <OnixS/B3/MarketData/UMDF/OrderBook.h>
#include <OnixS/B3/MarketData/UMDF/messaging/SbeMessage.h>

#include <atomic>
#include <cstdint>

namespace b3::md::onixs {

// Adapter: OnixS -> MarketDataEngine
class OnixsOrderBookListener final : public ::OnixS::B3::MarketData::UMDF::OrderBookListener {
public:
    explicit OnixsOrderBookListener(b3::md::MarketDataEngine& engine) noexcept
        : engine_(engine)
    {}

    OnixsOrderBookListener(const OnixsOrderBookListener&) = delete;
    OnixsOrderBookListener& operator=(const OnixsOrderBookListener&) = delete;

    void onOrderBookChanged(
        const ::OnixS::B3::MarketData::UMDF::OrderBook& /*book*/,
        const ::OnixS::B3::MarketData::UMDF::Messaging::SbeMessage /*message*/) override
    {
        // Por ahora no publicamos acá para evitar snapshots intermedios.
        //
        // TODO(B3): revisar si el SbeMessage trae exchange timestamp (o event time) y dónde.
        // Si existe, decidir cómo propagarlo sin heap ni mapas en hot path (ideal: usar onOrderBookUpdated
        // si el SDK expone el timestamp ahí; si no, estudiar estrategia).
        changedCount_.fetch_add(1, std::memory_order_relaxed);
    }

    void onOrderBookUpdated(const ::OnixS::B3::MarketData::UMDF::OrderBook& book) override {
        updatedCount_.fetch_add(1, std::memory_order_relaxed);
        engine_.onOrderBookUpdated(book);
    }

    void onOrderBookOutOfDate(const ::OnixS::B3::MarketData::UMDF::OrderBook& /*book*/) override {
        outOfDateCount_.fetch_add(1, std::memory_order_relaxed);
        // TODO(B3): emitir health/counter para marcar "books outdated" (sin bloquear).
    }

    uint64_t changedCount() const noexcept { return changedCount_.load(std::memory_order_relaxed); }
    uint64_t updatedCount() const noexcept { return updatedCount_.load(std::memory_order_relaxed); }
    uint64_t outOfDateCount() const noexcept { return outOfDateCount_.load(std::memory_order_relaxed); }

private:
    b3::md::MarketDataEngine& engine_;

    std::atomic<uint64_t> changedCount_{0};
    std::atomic<uint64_t> updatedCount_{0};
    std::atomic<uint64_t> outOfDateCount_{0};
};

} // namespace b3::md::onixs

===== FILE: ./src/b3-md-connector.conf =====
# OnixS
onixs.license_dir=./license
onixs.connectivity_file=./b3_connectivity.xml
onixs.channel=80
# onixs.if_a=eth0
# onixs.if_b=eth1

# MD
md.shards=4

===== FILE: ./src/publishing/IMdPublisher.hpp =====
#pragma once
#include <cstdint>
#include <string_view>

namespace b3::md {

class IMdPublisher {
public:
    virtual ~IMdPublisher() = default;
    virtual void publish(std::string_view topic,
                         const uint8_t* data,
                         size_t size) = 0;
};

} // namespace b3::md

===== FILE: ./src/core/MdPublishWorker.hpp =====
#pragma once

#include "SnapshotQueueSpsc.hpp"
#include "BookSnapshot.hpp"
#include "OrdersSnapshot.hpp" 
#include "MboToMbpAggregator.hpp"

#include "../mapping/MdSnapshotMapper.hpp" // BookSnapshot -> bytes
#include "../publishing/IMdPublisher.hpp"
#include "../telemetry/SpdlogLogPublisher.hpp"
#include "../telemetry/LogEvent.hpp"

#include <atomic>
#include <thread>
#include <string>

namespace b3::md {

class MdPublishWorker final {
public:
    static constexpr size_t kQueueCapacity    = 4096;
    static constexpr size_t kLogQueueCapacity = 1024;

    MdPublishWorker(uint32_t shardId,
                    MdSnapshotMapper& mapper,
                    IMdPublisher& publisher)
        : shardId_(shardId)
        , mapper_(mapper)
        , publisher_(publisher)
    {}

    MdPublishWorker(const MdPublishWorker&) = delete;
    MdPublishWorker& operator=(const MdPublishWorker&) = delete;

    void start() {
        bool expected = false;
        if (!running_.compare_exchange_strong(expected, true, std::memory_order_acq_rel)) {
            return; // idempotente
        }

        // Logger propio del worker (thread separado)
        logger_.start();

        drainOnStop_.store(true, std::memory_order_relaxed);
        thread_ = std::thread([this] { run(); });
    }

    void stop(bool drain = true) {
        drainOnStop_.store(drain, std::memory_order_relaxed);
        running_.store(false, std::memory_order_release);

        if (thread_.joinable()) {
            thread_.join();
        }

        // Drenar y detener logger al final
        logger_.stop();
    }

    // Hot path del pipeline->worker: SPSC, no throw, no alloc.
    bool tryEnqueue(const OrdersSnapshot& snapshot) noexcept {
        if (queue_.try_push(snapshot)) {
            enqueued_.fetch_add(1, std::memory_order_relaxed);
            return true;
        }

        dropped_.fetch_add(1, std::memory_order_relaxed);
        return false;
    }

    uint64_t enqueued()  const noexcept { return enqueued_.load(std::memory_order_relaxed); }
    uint64_t dropped()   const noexcept { return dropped_.load(std::memory_order_relaxed); }
    uint64_t published() const noexcept { return published_.load(std::memory_order_relaxed); }

private:
    void run() noexcept {
        OrdersSnapshot raw{};
        BookSnapshot   mbp{};        // Top-N agregado (MBP)
        std::string    outBuffer;
        outBuffer.reserve(512);

        auto publish_one = [&](const OrdersSnapshot& s) {
            // 1) Agregar MBO window -> MBP Top-N
            aggregateMboWindowToMbpTopN(s, mbp);

            // 2) Serializar y publicar
            outBuffer.clear();
            mapper_.mapAndSerialize(mbp, outBuffer);

            publisher_.publish(
                "b3.md.book",
                reinterpret_cast<const uint8_t*>(outBuffer.data()),
                outBuffer.size());

            published_.fetch_add(1, std::memory_order_relaxed);
        };

        while (running_.load(std::memory_order_acquire) ||
               (drainOnStop_.load(std::memory_order_relaxed) && queue_.size_approx() > 0)) {


===== FILE: ./src/core/IOrderBookView.hpp =====
#pragma once
#include <cstdint>

namespace b3::md {

struct Level {
    int64_t price{0};
    int64_t qty{0};
};

class IOrderBookView {
public:
    virtual ~IOrderBookView() = default;

    virtual uint32_t instrumentId() const noexcept = 0;
    virtual uint64_t exchangeTsNs() const noexcept = 0;

    virtual uint32_t bidCount() const noexcept = 0;
    virtual uint32_t askCount() const noexcept = 0;

    virtual Level bidLevel(uint32_t i) const noexcept = 0;
    virtual Level askLevel(uint32_t i) const noexcept = 0;
};

} // namespace b3::md

===== FILE: ./src/core/BookSnapshot.hpp =====
#pragma once
#include "IOrderBookView.hpp"   // o donde esté Level
#include <cstdint>
#include <type_traits>

namespace b3::md {

template<int N>
struct BookSnapshotT {
    static constexpr int DEPTH = N;

    uint32_t instrumentId{0};
    uint64_t exchangeTsNs{0};
    uint8_t bidCount{0};
    uint8_t askCount{0};

    Level bids[N]{};
    Level asks[N]{};
};

using BookSnapshot = BookSnapshotT<5>;

static_assert(std::is_trivially_copyable_v<BookSnapshot>);
static_assert(std::is_trivially_destructible_v<BookSnapshot>);

} // namespace b3::md

===== FILE: ./src/core/OrdersSnapshot.hpp =====
#pragma once

#include <cstdint>
#include <cstddef>
#include <type_traits>

namespace b3::md {

// Ventana acotada de órdenes (MBO) copiada en hot path.
// Se agrega (MBO->MBP) en el worker para generar BookSnapshot (niveles de precio).
//
// Nota: las órdenes con precio null (market orders) se SALTEAN al copiar,
// porque no contribuyen al agregado por niveles de precio (MBP).
struct OrdersSnapshot {
    static constexpr size_t K = 256;

    struct OrderEntry {  //todo:verificar prefision
        int64_t priceMantissa{0}; // precio con 4 decimales (mantissa) 
        int64_t qty{0};           // Quantity (Int64)
    };

    uint32_t instrumentId{0};
    uint64_t exchangeTsNs{0};

    // Secuencias del SDK (las copiamos para futuro/protobuf/health)
    uint64_t rptSeq{0};      // OrderBook::lastRptSeq()
    uint64_t channelSeq{0};  // OrderBook::lastMessageSeqNumApplied()

    // Tamaños "crudos" del libro (lo que expone el SDK, sin filtrar null-price)
    uint16_t bidCountRaw{0};
    uint16_t askCountRaw{0};

    // Cantidad efectiva copiada (solo órdenes con precio válido, hasta K)
    uint16_t bidsCopied{0};
    uint16_t asksCopied{0};

    // Flags: 1 si hubo más órdenes válidas que K y se truncó; 0 si entraron todas.
    uint8_t bidTruncated{0};
    uint8_t askTruncated{0};

    OrderEntry bids[K]{};
    OrderEntry asks[K]{};
};

static_assert(std::is_trivially_copyable_v<OrdersSnapshot>);
static_assert(std::is_trivially_destructible_v<OrdersSnapshot>);

} // namespace b3::md

===== FILE: ./src/core/MdPublishPipeline.hpp =====
#pragma once

#include "MdPublishWorker.hpp"
#include "OrdersSnapshot.hpp"

#include <cstdint>
#include <memory>
#include <vector>
#include <atomic>
#include <stdexcept>

namespace b3::md {

// Pipeline = orquestador de sharding + lifecycle de workers.
// NO crea threads en ctor. NO conoce IO. NO conoce OnixS.
// Enqueue único punto de entrada (hot path friendly).
class MdPublishPipeline final {
public:
    explicit MdPublishPipeline(std::vector<std::unique_ptr<MdPublishWorker>> workers)
        : workers_(std::move(workers))
    {
        if (workers_.empty()) {
            throw std::invalid_argument("MdPublishPipeline: workers empty");
        }
    }

    MdPublishPipeline(const MdPublishPipeline&) = delete;
    MdPublishPipeline& operator=(const MdPublishPipeline&) = delete;

    void start() {
        bool expected = false;
        if (!started_.compare_exchange_strong(expected, true, std::memory_order_acq_rel)) {
            return; // idempotente
        }
        for (auto& w : workers_) {
            w->start();
        }
    }

    void stop(bool drain = true) {
        bool expected = true;
        if (!started_.compare_exchange_strong(expected, false, std::memory_order_acq_rel)) {
            return; // idempotente
        }
        for (auto& w : workers_) {
            w->stop(drain);
        }
    }

    // Hot path: no throw, no alloc.
    // Devuelve false si se dropeó (cola llena).
    bool tryEnqueue(const OrdersSnapshot& snapshot) noexcept {
        const uint32_t shard = shardFor(snapshot.instrumentId);
        return workers_[shard]->tryEnqueue(snapshot);
    }

    uint32_t shardCount() const noexcept {
        return static_cast<uint32_t>(workers_.size());
    }

private:
    // Hash multiplicativo para mejorar distribución si instrumentId tiene patrones.
    static constexpr uint64_t kKnuth = 11400714819323198485ull;

    uint32_t shardFor(uint64_t instrumentId) const noexcept {
        const uint64_t mixed = instrumentId * kKnuth;
        return static_cast<uint32_t>(mixed % workers_.size());
    }

private:
    std::vector<std::unique_ptr<MdPublishWorker>> workers_;
    std::atomic<bool> started_{false};
};

} // namespace b3::md

===== FILE: ./src/core/MboToMbpAggregator.hpp =====
#pragma once

#include "OrdersSnapshot.hpp"
#include "BookSnapshot.hpp"
#include <cstdint>

namespace b3::md {

// Agrega órdenes (MBO) por precio para producir niveles (MBP Top-N).
// No aloca. No tira exceptions. Diseñado para ejecutarse en worker.
inline void aggregateMboWindowToMbpTopN(const OrdersSnapshot& in, BookSnapshot& out) noexcept {
    out.instrumentId = in.instrumentId;
    out.exchangeTsNs = in.exchangeTsNs;
    out.bidCount = 0;
    out.askCount = 0;

    // Limpieza explícita (por si Level no es trivially-zero-safe)
    for (int i = 0; i < BookSnapshot::DEPTH; ++i) {
        out.bids[i] = Level{};
        out.asks[i] = Level{};
    }

    auto add_level = [](Level* levels, uint8_t& count, int64_t priceMantissa, int64_t qty) noexcept {
        // Buscar si ya existe ese precio dentro de los niveles armados
        for (uint8_t i = 0; i < count; ++i) {
            // TODO, verificar la presicion cuando tenga la documentacion para evitar narrowing
            // típicamente Level::price es entero (mantissa) o algo compatible ṕero verificar. 20251222
            const auto existingPrice = static_cast<int64_t>(levels[i].price);
            if (existingPrice == priceMantissa) {
                levels[i].qty = static_cast<decltype(levels[i].qty)>(
                    static_cast<int64_t>(levels[i].qty) + qty
                );
                return;
            }
        }

        // Nuevo precio si todavía hay espacio
        if (count < BookSnapshot::DEPTH) {
            levels[count].price = static_cast<decltype(levels[count].price)>(priceMantissa);
            levels[count].qty   = static_cast<decltype(levels[count].qty)>(qty);
            ++count;
        }
    };

    // BID side
    {
        const uint16_t n = in.bidCountRaw;
        for (uint16_t i = 0; i < n && out.bidCount < BookSnapshot::DEPTH; ++i) {
            const auto& e = in.bids[i];
            if (e.qty == 0) continue;
            // market orders se saltean en el builder, así que priceMantissa==0 acá debería ser raro.
            if (e.priceMantissa == 0) continue;

            add_level(out.bids, out.bidCount, e.priceMantissa, e.qty);
        }
    }

    // ASK side
    {
        const uint16_t n = in.askCountRaw;
        for (uint16_t i = 0; i < n && out.askCount < BookSnapshot::DEPTH; ++i) {
            const auto& e = in.asks[i];
            if (e.qty == 0) continue;
            if (e.priceMantissa == 0) continue;

            add_level(out.asks, out.askCount, e.priceMantissa, e.qty);
        }
    }
}

} // namespace b3::md

===== FILE: ./src/core/MarketDataEngine.hpp =====
#pragma once

#include "MdPublishPipeline.hpp"
#include "IOrderBookView.hpp"
#include "OrdersSnapshot.hpp"

#include "../onixs/OnixsOrdersSnapshotBuilder.hpp"

#include <atomic>
#include <cstdint>

#include <OnixS/B3/MarketData/UMDF/OrderBook.h>

namespace b3::md {

class MarketDataEngine final {
public:
    explicit MarketDataEngine(MdPublishPipeline& pipeline)
        : pipeline_(pipeline)
    {}

    // Vive en el thread del feed (listener OnixS).
    // Construye OrdersSnapshot (ventana MBO) y encola al pipeline.
    void onOrderBookUpdated(const ::OnixS::B3::MarketData::UMDF::OrderBook& orderBook) noexcept {
        OrdersSnapshot snapshot{};
        b3::md::onixs::OnixsOrdersSnapshotBuilder::buildFromBook(orderBook, snapshot);

        if (!pipeline_.tryEnqueue(snapshot)) {
            drops_.fetch_add(1, std::memory_order_relaxed);
        }
    }

    uint64_t drops() const noexcept {
        return drops_.load(std::memory_order_relaxed);
    }

private:
    MdPublishPipeline& pipeline_;
    std::atomic<uint64_t> drops_{0};
};

} // namespace b3::md

===== FILE: ./src/core/SnapshotQueueSpsc.hpp =====
#pragma once
#include <atomic>
#include <cstddef>
#include <cstdint>
#include <memory>

namespace b3::md {

// FIFO SPSC ring buffer.
// Producer: 1 thread (pipeline/callback)
// Consumer: 1 thread (worker)
template <typename T, size_t CapacityPow2>
class SnapshotQueueSpsc {
    static_assert((CapacityPow2 & (CapacityPow2 - 1)) == 0, "Capacity must be power of two");

public:
    SnapshotQueueSpsc()
        : buffer_(std::make_unique<T[]>(CapacityPow2))
    {}

    bool try_push(const T& v) noexcept {
        const uint32_t t = tail_.load(std::memory_order_relaxed);
        const uint32_t h = head_.load(std::memory_order_acquire);

        if ((t - h) >= CapacityPow2) return false; // full

        buffer_[t & (CapacityPow2 - 1)] = v;
        tail_.store(t + 1, std::memory_order_release);
        return true;
    }

    bool try_pop(T& out) noexcept {
        const uint32_t h = head_.load(std::memory_order_relaxed);
        const uint32_t t = tail_.load(std::memory_order_acquire);

        if (h == t) return false; // empty

        out = buffer_[h & (CapacityPow2 - 1)];
        head_.store(h + 1, std::memory_order_release);
        return true;
    }

    uint32_t size_approx() const noexcept {
        const uint32_t h = head_.load(std::memory_order_acquire);
        const uint32_t t = tail_.load(std::memory_order_acquire);
        return t - h;
    }

private:
    alignas(64) std::atomic<uint32_t> head_{0};
    alignas(64) std::atomic<uint32_t> tail_{0};

    std::unique_ptr<T[]> buffer_;
};

} // namespace b3::md

===== FILE: ./src/testsupport/OrdersSnapshotFromMbpView.hpp =====
#pragma once

#include "../core/OrdersSnapshot.hpp"
#include "../core/IOrderBookView.hpp"

namespace b3::md::testsupport {

// Adapter MBP (niveles) -> OrdersSnapshot (ventana MBO fake)
// Uso exclusivo para tests.
// Cada nivel se copia como si fuera una "orden agregada".
inline OrdersSnapshot makeOrdersSnapshotFromMbpView(
    const IOrderBookView& book) noexcept
{
    OrdersSnapshot snapshot{};

    snapshot.instrumentId = book.instrumentId();
    snapshot.exchangeTsNs = book.exchangeTsNs();

    const uint32_t bidN = book.bidCount();
    const uint32_t askN = book.askCount();

    uint16_t writtenBid = 0;
    for (uint32_t i = 0;
         i < bidN && writtenBid < OrdersSnapshot::K;
         ++i)
    {
        const auto lv = book.bidLevel(i);
        snapshot.bids[writtenBid].priceMantissa = lv.price;
        snapshot.bids[writtenBid].qty = lv.qty;
        ++writtenBid;
    }

    snapshot.bidCountRaw = writtenBid;
    snapshot.bidTruncated = (bidN > OrdersSnapshot::K) ? 1u : 0u;

    uint16_t writtenAsk = 0;
    for (uint32_t i = 0;
         i < askN && writtenAsk < OrdersSnapshot::K;
         ++i)
    {
        const auto lv = book.askLevel(i);
        snapshot.asks[writtenAsk].priceMantissa = lv.price;
        snapshot.asks[writtenAsk].qty = lv.qty;
        ++writtenAsk;
    }

    snapshot.askCountRaw = writtenAsk;
    snapshot.askTruncated = (askN > OrdersSnapshot::K) ? 1u : 0u;

    return snapshot;
}

} // namespace b3::md::testsupport

===== FILE: ./src/testsupport/FakePublisher.hpp =====
#pragma once
#include "../publishing/IMdPublisher.hpp"
#include <mutex>
#include <string>
#include <vector>

namespace b3::md :: testsupport {

struct PublishedMessage {
    std::string topic;
    std::string bytes;
};

class FakePublisher final : public IMdPublisher {
public:
    void publish(std::string_view topic,
                 const uint8_t* data,
                 size_t size) override {
        std::lock_guard<std::mutex> g(m_);
        PublishedMessage m;
        m.topic.assign(topic.data(), topic.size());
        m.bytes.assign(reinterpret_cast<const char*>(data), size);
        msgs_.push_back(std::move(m));
    }

    size_t count() const {
        std::lock_guard<std::mutex> g(m_);
        return msgs_.size();
    }

    PublishedMessage at(size_t i) const {
        std::lock_guard<std::mutex> g(m_);
        return msgs_.at(i);
    }

private:
    mutable std::mutex m_;
    std::vector<PublishedMessage> msgs_;
};

} // namespace b3::md

===== FILE: ./src/mapping/MdSnapshotMapper.hpp =====
#pragma once
#include "../core/BookSnapshot.hpp"
#include <string>

namespace b3::md {

// Mapper puro: snapshot -> bytes
// (stub determinístico para tests; luego será Protobuf)
class MdSnapshotMapper {
public:
    void mapAndSerialize(const BookSnapshot& s,
                         std::string& out) const {
        out.clear();
        out.reserve(64);
        out.append("iid=");
        out.append(std::to_string(s.instrumentId));
        out.append(";ts=");
        out.append(std::to_string(s.exchangeTsNs));
        out.append(";bc=");
        out.append(std::to_string(s.bidCount));
        out.append(";ac=");
        out.append(std::to_string(s.askCount));
    }
};

} // namespace b3::md

===== FILE: ./src/MessagingLibIntegrationTest.cpp =====
#include "core/MarketDataEngine.hpp"
#include <clients/PublisherSubscriber.h>
#include <models/messages.pb.h>
#include <models/messageTypes.h>
#include <models/risk_management.pb.h>
#include <iostream>
#include <spdlog/spdlog.h>
//#include <OnixS/B3/MarketData/UMDF.h>
#include <thread>
#include <chrono>
#include <iomanip>
#include <sstream>
#include <atomic>

namespace {
    std::string GenerateSimpleUUID() {
        auto now = std::chrono::system_clock::now();
        auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
        std::stringstream ss;
        ss << "msg-" << ms << "-" << std::this_thread::get_id();
        return ss.str();
    }

    void SimpleLogger(const std::string &level, const std::string &message) {
        auto now = std::chrono::system_clock::now();
        auto time = std::chrono::system_clock::to_time_t(now);
        std::cout << "[" << std::put_time(std::localtime(&time), "%H:%M:%S") << "] "
                  << "[" << level << "] " << message << '\n';
    }
}

int main2() {
    // spdlog::info("=== B3 Market Data Connector Test ===");
    // spdlog::info("OnixS C++ B3 Binary UMDF Market Data Handler version {}",
    //              OnixS::B3::MarketData::UMDF::Handler::version());

    // Test configuration
    const std::string SERVER = "Risk01.byma.mkthub.int";
    int RISK_UAT[] = {5955, 5956, 5557};

    std::string REQ_ENDPOINT{"tcp://" + SERVER + ":" + std::to_string(RISK_UAT[0])};
    std::string RES_ENDPOINT{"tcp://" + SERVER + ":" + std::to_string(RISK_UAT[1])};
    std::string RT_ENDPOINT{"tcp://" + SERVER + ":" + std::to_string(RISK_UAT[2])};

    std::string clientId = "95515";
    std::atomic<int> clientResponsesReceived{0};

    // Create PublisherSubscriber client
    markethub::messaging::clients::PublisherSubscriber client(
        clientId,
        REQ_ENDPOINT,
        RES_ENDPOINT,
        SimpleLogger
    );

    // Setup message received callback
    client.SetMessageReceivedCallback([&](const markethub::messaging::WrapperMessage &response) {
        int count = ++clientResponsesReceived;
        std::stringstream ss;
        ss << "Response #" << count << ": " << response.ShortDebugString();
        SimpleLogger("Info", ss.str());
    });

    // Start client
    SimpleLogger("Info", "Starting CLIENT...");
    client.Start();
    SimpleLogger("Info", "CLIENT ready");

    std::cout << "\n=== Press ENTER to send PNL Report Request ===" << std::endl;
    std::string dummy;
    std::getline(std::cin, dummy);

    // Create and send PNL Report Request
    markethub::messaging::WrapperMessage msg;
    msg.set_message_id(GenerateSimpleUUID());
    msg.set_message_type(markethub::messaging::models::MessageTypes::PNLReportRequest);

    auto *pnl = msg.mutable_pnl_report_request();
    pnl->set_market("byma");
    pnl->set_account("10410");

    client.SendMessage(std::move(msg));
    SimpleLogger("Info", "PNL Report Request sent");

    std::cout << "\n=== Press ENTER to exit ===" << std::endl;
    std::getline(std::cin, dummy);

    SimpleLogger("Info", "Shutting down...");
    client.Stop();

    spdlog::info("Total responses received: {}", clientResponsesReceived.load());
    spdlog::info("Test completed successfully");

    return 0;
}
