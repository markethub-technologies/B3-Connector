
===== FILE: /workspaces/MarketHub.B3Connector/tests/md/test_mbo_to_mbp_aggregator.cpp =====
    aggregateMboWindowToMbpTopN(in, out);

    ASSERT_EQ(out.bidCount, 1u);
    EXPECT_EQ(out.bids[0].price, 1000);
    EXPECT_EQ(out.bids[0].qty,   10);
    EXPECT_EQ(out.askCount, 0u);
}

===== FILE: /workspaces/MarketHub.B3Connector/tests/md/FakeOrderBook.hpp =====
#pragma once
#include "../../b3-md-connector/src/core/IOrderBookView.hpp"
#include <array>

namespace b3::md::test {

  class FakeOrderBook final : public b3::md::IOrderBookView {
   public:
    void setInstrumentId(uint64_t v) { instrumentId_ = v; }
    void setExchangeTsNs(uint64_t v) { exchangeTsNs_ = v; }

    void setBidCount(uint32_t c) { bidCount_ = c; }
    void setAskCount(uint32_t c) { askCount_ = c; }

    void setBidLevel(uint32_t i, b3::md::Level lv) { bids_.at(i) = lv; }
    void setAskLevel(uint32_t i, b3::md::Level lv) { asks_.at(i) = lv; }

    uint64_t instrumentId() const noexcept override { return instrumentId_; }
    uint64_t exchangeTsNs() const noexcept override { return exchangeTsNs_; }

    uint32_t bidCount() const noexcept override { return bidCount_; }
    uint32_t askCount() const noexcept override { return askCount_; }

    b3::md::Level bidLevel(uint32_t i) const noexcept override { return bids_.at(i); }
    b3::md::Level askLevel(uint32_t i) const noexcept override { return asks_.at(i); }

   private:
    uint64_t instrumentId_{0};
    uint64_t exchangeTsNs_{0};
    uint32_t bidCount_{0};
    uint32_t askCount_{0};
    std::array<b3::md::Level, 10> bids_{};
    std::array<b3::md::Level, 10> asks_{};
  };


===== FILE: /workspaces/MarketHub.B3Connector/tests/md/test_md_pipeline.cpp =====
#include <gtest/gtest.h>

#include "../../b3-md-connector/src/core/MdPublishPipeline.hpp"
#include "../../b3-md-connector/src/core/MdPublishWorker.hpp"
#include "../../b3-md-connector/src/mapping/MdSnapshotMapper.hpp"
#include "FakePublishSink.hpp"
#include "FakeMapper.hpp"
#include <chrono>
#include <thread>
#include <unordered_map>
#include <vector>
#include <string>
#include <memory>

using namespace b3::md;

namespace {

  uint64_t ParseTs(const std::string &bytes) {
    auto pos = bytes.find(";ts=");
    EXPECT_NE(pos, std::string::npos);
    if (pos == std::string::npos)
      return 0;

    pos += 4;
    auto end = bytes.find(';', pos);
    EXPECT_NE(end, std::string::npos);
    if (end == std::string::npos)
      return 0;

    return std::stoull(bytes.substr(pos, end - pos));
  }

  uint32_t ParseIid(const std::string &bytes) {
    auto pos = bytes.find("iid=");
    EXPECT_EQ(pos, 0u);
    if (pos != 0u)
      return 0;

    pos += 4;
    auto end = bytes.find(';', pos);
    EXPECT_NE(end, std::string::npos);
    if (end == std::string::npos)
      return 0;

    return static_cast<uint32_t>(std::stoul(bytes.substr(pos, end - pos)));
  }

  MdPublishPipeline BuildPipeline(uint32_t shards, MdSnapshotMapper &mapper,
                                  testsupport::FakePublishSink &sink) {
    std::vector<std::unique_ptr<MdPublishWorker>> workers;
    workers.reserve(shards);

    // IMPORTANT:
    // El worker guarda un puntero/referencia al mapper de topics para armar el topic en hot path.
    // Si el mapper vive en stack (local) y devolvés el pipeline, queda dangling y crashea.
    static testsupport::FakeInstrumentTopicMapper fakeTopics{
        {1, "AAA"}, {2, "BBB"}, {3, "CCC"}, {4, "DDD"}, {5, "EEE"}, {6, "FFF"},
    };

    for (uint32_t i = 0; i < shards; ++i) {
      workers.emplace_back(std::make_unique<MdPublishWorker>(i, mapper, sink, fakeTopics.get()));
    }

    return MdPublishPipeline(std::move(workers));
  }
} // namespace

TEST(MdPublishPipelineTests, PreservesFifoOrderPerInstrument) {
  testsupport::FakePublishSink sink;
  MdSnapshotMapper mapper;

  auto pipeline = BuildPipeline(4, mapper, sink);
  pipeline.start();

  constexpr int EVENTS_PER_INSTRUMENT = 10'000;
  const std::vector<uint64_t> instruments = {1, 2, 3, 4, 5, 6};

  for (uint64_t iid : instruments) {
    for (int i = 0; i < EVENTS_PER_INSTRUMENT; ++i) {
      OrdersSnapshot s{};
      s.instrumentId = iid;
      s.exchangeTsNs = static_cast<uint64_t>(i);

      // Para que el agregador produzca bid/askCount > 0 (opcional):
      s.bidsCopied = 1;
      s.asksCopied = 1;
      s.bids[0] = {.priceMantissa = 1000 + i, .qty = 1};
      s.asks[0] = {.priceMantissa = 2000 + i, .qty = 1};

      while (!pipeline.tryEnqueue(s)) {
        std::this_thread::yield();
      }
    }
  }

  const size_t expected = instruments.size() * static_cast<size_t>(EVENTS_PER_INSTRUMENT);

  const auto deadline = std::chrono::steady_clock::now() + std::chrono::seconds(5);

  while (sink.count() < expected && std::chrono::steady_clock::now() < deadline) {
    std::this_thread::sleep_for(std::chrono::milliseconds(1));
  }

  pipeline.stop(true);

  ASSERT_EQ(sink.count(), expected);

  // Agrupar timestamps por instrumento
  std::unordered_map<uint64_t, std::vector<uint64_t>> seen;
  seen.reserve(instruments.size());

  for (size_t i = 0; i < expected; ++i) {
    const auto msg = sink.at(i);
    seen[ParseIid(msg.bytes)].push_back(ParseTs(msg.bytes));
  }

  // FIFO estricto por instrumento
  for (const auto &[iid, tss] : seen) {
    ASSERT_FALSE(tss.empty());
    for (size_t i = 1; i < tss.size(); ++i) {
      EXPECT_EQ(tss[i], tss[i - 1] + 1) << "iid=" << iid;
    }
  }
}

TEST(MdPublishPipelineTests, ProgressUnderMultipleInstruments) {
  testsupport::FakePublishSink sink;
  MdSnapshotMapper mapper;

  auto pipeline = BuildPipeline(2, mapper, sink);
  pipeline.start();

  constexpr int N = 50'000;

  const uint32_t iidA = 1;
  const uint32_t iidB = 2;

  for (int i = 0; i < N; ++i) {
    OrdersSnapshot a{}, b{};
    a.instrumentId = iidA;
    a.exchangeTsNs = static_cast<uint64_t>(i);
    b.instrumentId = iidB;
    b.exchangeTsNs = static_cast<uint64_t>(i);

    while (!pipeline.tryEnqueue(a)) std::this_thread::yield();
    while (!pipeline.tryEnqueue(b)) std::this_thread::yield();
  }

  const size_t expected = static_cast<size_t>(2 * N);

  const auto deadline = std::chrono::steady_clock::now() + std::chrono::seconds(5);

  while (sink.count() < expected && std::chrono::steady_clock::now() < deadline) {
    std::this_thread::sleep_for(std::chrono::milliseconds(1));
  }

  pipeline.stop(true);

  ASSERT_EQ(sink.count(), expected);

===== FILE: /workspaces/MarketHub.B3Connector/tests/md/test_md_engine.cpp =====
#include <gtest/gtest.h>

#include "../../b3-md-connector/src/core/MarketDataEngine.hpp"
#include "../../b3-md-connector/src/core/MdPublishPipeline.hpp"
#include "../../b3-md-connector/src/core/MdPublishWorker.hpp"
#include "../../b3-md-connector/src/testsupport/OrdersSnapshotFromMbpView.hpp"
#include "FakeOrderBook.hpp"
#include "FakeMapper.hpp"

#include <atomic>
#include <chrono>
#include <thread>
#include <memory>
#include <vector>

using namespace b3::md;
using namespace b3::md::test;

// Publisher que cuenta publicaciones (thread-safe).
struct CountingSink final : b3::md::publishing::IPublishSink {
  bool tryPublish(uint32_t, const b3::md::publishing::PublishEvent &) noexcept override {
    published.fetch_add(1, std::memory_order_relaxed);
    return true;
  }
  std::atomic<uint64_t> published{0};
};

// Mapper de test: no aloca pesado, solo dispara publish.
struct TestMapper final : MdSnapshotMapper {
  void mapAndSerialize(const BookSnapshot &, std::string &out) const { out.assign("x"); }
};

TEST(MarketDataEngineTests, EnqueuesAndPublishes) {
  TestMapper mapper;
  CountingSink sink;

  testsupport::FakeInstrumentTopicMapper fakeTopics{{42, "AAA"}};

  auto worker = std::make_unique<MdPublishWorker>(0, mapper, sink, fakeTopics.get());
  std::vector<std::unique_ptr<MdPublishWorker>> workers;
  workers.push_back(std::move(worker));

  MdPublishPipeline pipeline(std::move(workers));
  pipeline.start();

  FakeOrderBook book;
  book.setInstrumentId(42);
  book.setExchangeTsNs(123);
  book.setBidCount(1);
  book.setAskCount(1);
  book.setBidLevel(0, b3::md::Level{10, 5});
  book.setAskLevel(0, b3::md::Level{11, 7});

  auto snapshot = b3::md::testsupport::makeOrdersSnapshotFromMbpView(book);

  pipeline.tryEnqueue(snapshot);

  const auto deadline = std::chrono::steady_clock::now() + std::chrono::milliseconds(200);

  while (sink.published.load(std::memory_order_relaxed) < 1 &&
         std::chrono::steady_clock::now() < deadline) {
    std::this_thread::sleep_for(std::chrono::milliseconds(1));
  }

  pipeline.stop(true);

  EXPECT_GE(sink.published.load(), 1u);
}

TEST(MarketDataEngineTests, EnqueueNeverBlocks) {
  CountingSink sink;
  MdSnapshotMapper mapper;
  testsupport::FakeInstrumentTopicMapper fakeTopics{
      {1, "AAA"},
      {2, "BBB"},
  };

  std::vector<std::unique_ptr<MdPublishWorker>> workers;
  workers.emplace_back(std::make_unique<MdPublishWorker>(0, mapper, sink, fakeTopics.get()));
  MdPublishPipeline pipeline(std::move(workers));
  pipeline.start();

  FakeOrderBook book;
  book.setInstrumentId(1);
  book.setExchangeTsNs(1);
  book.setBidCount(0);
  book.setAskCount(0);

  for (int i = 0; i < 100000; ++i) {
    auto snapshot = b3::md::testsupport::makeOrdersSnapshotFromMbpView(book);
    pipeline.tryEnqueue(snapshot);
  }

  pipeline.stop(false);
  SUCCEED();
}

===== FILE: /workspaces/MarketHub.B3Connector/tests/md/test_md_worker.cpp =====
#include "../../b3-md-connector/src/core/MdPublishWorker.hpp"
#include "FakePublishSink.hpp"
#include "FakeMapper.hpp"
#include "../../b3-md-connector/src/mapping/MdSnapshotMapper.hpp"
#include "../../b3-md-connector/src/core/OrdersSnapshot.hpp"
#include <gtest/gtest.h>

#include <chrono>
#include <thread>

using namespace b3::md;

static uint64_t parse_ts(const std::string &bytes) {
  auto pos = bytes.find(";ts=");
  EXPECT_NE(pos, std::string::npos);
  pos += 4;
  auto end = bytes.find(';', pos);
  EXPECT_NE(end, std::string::npos);
  return std::stoull(bytes.substr(pos, end - pos));
}

TEST(MdPublishWorkerTests, PublishesFifoOrder) {
  testsupport::FakePublishSink sink;
  MdSnapshotMapper mapper;
  uint32_t shard = 1;
  testsupport::FakeInstrumentTopicMapper fakeTopics{{77, "AAA"}};

  MdPublishWorker worker(0, mapper, sink, fakeTopics.get());
  worker.start();

  constexpr int N = 100000;
  for (int i = 0; i < N; ++i) {
    OrdersSnapshot orderSnapshot{};
    orderSnapshot.instrumentId = 77;
    orderSnapshot.exchangeTsNs = static_cast<uint64_t>(i);

    // opcional para bid/ask count:
    orderSnapshot.bidsCopied = 1;
    orderSnapshot.asksCopied = 1;
    orderSnapshot.bids[0] = {.priceMantissa = 1000, .qty = 1};
    orderSnapshot.asks[0] = {.priceMantissa = 2000, .qty = 1};

    while (!worker.tryEnqueue(orderSnapshot)) {
      std::this_thread::yield();
    }
  }

  const auto deadline = std::chrono::steady_clock::now() + std::chrono::seconds(5);
  while (sink.count() < static_cast<size_t>(N) && std::chrono::steady_clock::now() < deadline) {
    std::this_thread::sleep_for(std::chrono::milliseconds(1));
  }

  worker.stop(true);

  ASSERT_EQ(sink.count(), static_cast<size_t>(N));

  uint64_t last = 0;
  for (int i = 0; i < N; ++i) {
    auto m = sink.at(i);
    EXPECT_EQ(m.topic, "AAA"); // topic fijo del worker
    uint64_t ts = parse_ts(m.bytes);
    if (i == 0)
      EXPECT_EQ(ts, 0);
    else
      EXPECT_EQ(ts, last + 1);
    last = ts;
  }
}

TEST(MdPublishWorkerTests, StopClean) {
  testsupport::FakePublishSink sink;
  MdSnapshotMapper mapper;
  uint32_t shard = 1;

  testsupport::FakeInstrumentTopicMapper fakeTopics{{1, "AAA"}};

  MdPublishWorker worker(0, mapper, sink, fakeTopics.get());
  worker.start();
  std::this_thread::sleep_for(std::chrono::milliseconds(10));
  worker.stop(false);
  SUCCEED();
}

TEST(MdPublishWorkerTests, StopWithoutDrainReturnsQuickly) {
  testsupport::FakePublishSink sink;
  MdSnapshotMapper mapper;
  uint32_t shard = 1;

  testsupport::FakeInstrumentTopicMapper fakeTopics{{77, "AAA"}};
  MdPublishWorker worker(0, mapper, sink, fakeTopics.get());
  worker.start();

  OrdersSnapshot s{};
  s.instrumentId = 77;
  s.exchangeTsNs = 0;

  s.bidCountRaw = 1;
  s.askCountRaw = 1;
  s.bidsCopied = 1;
  s.asksCopied = 1;
  s.bids[0] = {.priceMantissa = 1000, .qty = 1};
  s.asks[0] = {.priceMantissa = 2000, .qty = 1};

  // Empujar bastante para que haya backlog real
  for (int i = 0; i < 200000; ++i) {
    s.exchangeTsNs = static_cast<uint64_t>(i);
    (void)worker.tryEnqueue(s);
  }

  const auto t0 = std::chrono::steady_clock::now();
  worker.stop(false);
  const auto dt = std::chrono::steady_clock::now() - t0;

  // No-drain: apagado rápido (umbral amplio para CI)
  EXPECT_LT(std::chrono::duration_cast<std::chrono::milliseconds>(dt).count(), 200);
}

TEST(MdPublishWorkerTests, StopWithDrainPublishesAll) {
  testsupport::FakePublishSink sink;
  MdSnapshotMapper mapper;
  uint32_t shard = 1;

  testsupport::FakeInstrumentTopicMapper fakeTopics{
      {77, "CCC"},
  };

  MdPublishWorker worker(0, mapper, sink, fakeTopics.get());
  worker.start();

  for (int i = 0; i < 1000; ++i) {
    OrdersSnapshot s{};
    s.instrumentId = 77;
    s.exchangeTsNs = static_cast<uint64_t>(i);

    s.bidsCopied = 1;
    s.asksCopied = 1;
    s.bids[0] = {.priceMantissa = 1000, .qty = 1};
    s.asks[0] = {.priceMantissa = 2000, .qty = 1};

    while (!worker.tryEnqueue(s)) {
      std::this_thread::yield();
    }
  }

  worker.stop(true);
  EXPECT_EQ(sink.count(), 1000u);
}

static uint32_t parse_count(const std::string &bytes, const char *key) {
  std::string needle = std::string(";") + key + "="; // ";bc=" o ";ac="
  auto pos = bytes.find(needle);
  EXPECT_NE(pos, std::string::npos);
  if (pos == std::string::npos)
    return 0;

  pos += needle.size();
  auto end = bytes.find(';', pos);
  // si es el último campo, end puede ser npos; lo toleramos
  const std::string value =
      (end == std::string::npos) ? bytes.substr(pos) : bytes.substr(pos, end - pos);

  return static_cast<uint32_t>(std::stoul(value));
}

TEST(MdPublishWorkerTests, AggregationAffectsCountsInSerializedOutput) {
  testsupport::FakePublishSink sink;
  MdSnapshotMapper mapper;
  uint32_t shard = 1;
  testsupport::FakeInstrumentTopicMapper fakeTopics{{77, "AAA"}};

  MdPublishWorker worker(0, mapper, sink, fakeTopics.get());
  worker.start();

  OrdersSnapshot raw{};
  raw.instrumentId = 77;
  raw.exchangeTsNs = 999;

  // bids: dos órdenes mismo precio + una de otro -> 2 niveles
  raw.bidsCopied = 3;
  raw.bids[0] = {.priceMantissa = 1000, .qty = 10};
  raw.bids[1] = {.priceMantissa = 1000, .qty = 20};
  raw.bids[2] = {.priceMantissa = 900, .qty = 1};

  // asks: dos precios -> 2 niveles
  raw.asksCopied = 3;
  raw.asks[0] = {.priceMantissa = 1100, .qty = 7};
  raw.asks[1] = {.priceMantissa = 1100, .qty = 8};
  raw.asks[2] = {.priceMantissa = 1200, .qty = 1};

  while (!worker.tryEnqueue(raw)) {
    std::this_thread::yield();
  }

