
===== FILE: /workspaces/MarketHub.B3Connector/tests/md/FakeMapper.hpp =====
#pragma once

#include <initializer_list>
#include <string_view>
#include <utility>

#include "../../b3-md-connector/src/mapping/InstrumentTopicMapper.hpp"

namespace b3::md::testsupport {

  /**
   * FakeInstrumentTopicMapper
   * ------------------------
   * En realidad es un "test builder" que devuelve un InstrumentTopicMapper real
   * precargado. Es la mejor opción porque:
   * - MdPublishWorker espera mapping::InstrumentTopicMapper (tipo concreto, final)
   * - Evitás herencia/impostores
   * - Misma semántica que producción
   */
  struct FakeInstrumentTopicMapper final {
    using InstrumentId = b3::md::mapping::InstrumentTopicMapper::InstrumentId;

    // Construye con una lista de pares {instrumentId, "SYMBOL"}
    explicit FakeInstrumentTopicMapper(
        std::initializer_list<std::pair<InstrumentId, std::string_view>> items = {}) {
      for (const auto &kv : items) {
        // En tests preferimos fail-fast: si no entra, es un error del test
        const bool ok = mapper_.tryWriteTopic(kv.first, kv.second);
        (void)ok;
#ifdef _DEBUG
        if (!ok) {
          // Si preferís, reemplazá por tu assert framework (gtest/ctest/etc.)
          __builtin_trap();
        }
#endif
      }
    }

    // Acceso al mapper real que tu MdPublishWorker necesita
    const b3::md::mapping::InstrumentTopicMapper &get() const noexcept { return mapper_; }
    b3::md::mapping::InstrumentTopicMapper &get() noexcept { return mapper_; }

    // Helpers cómodos
    FakeInstrumentTopicMapper &with(InstrumentId id, std::string_view sym) noexcept {
      mapper_.tryWriteTopic(id, sym);
      return *this;
    }

   private:
    b3::md::mapping::InstrumentTopicMapper mapper_{};
  };


===== FILE: /workspaces/MarketHub.B3Connector/tests/md/test_mbo_to_mbp_ordering_contract.cpp =====
#include <gtest/gtest.h>

#include "../../b3-md-connector/src/core/OrdersSnapshot.hpp"
#include "../../b3-md-connector/src/core/BookSnapshot.hpp"
#include "../../b3-md-connector/src/core/MboToMbpAggregator.hpp"

using namespace b3::md;

TEST(MboToMbpAggregatorOrderingContractTests, BestFirstInputProducesTrueTopN) {
    OrdersSnapshot in{};
    in.instrumentId = 7;
    in.exchangeTsNs = 777;

    // Queremos 10 precios únicos por lado.
    // "Contrato" para este test: input ya viene best-first.
    // - bids: best -> worst (mayor a menor)
    // - asks: best -> worst (menor a mayor)

    constexpr int N = 10;

    // BID: 2000,1999,...,1991
    in.bidCountRaw = N;
    in.bidsCopied  = N;
    for (int i = 0; i < N; ++i) {
        in.bids[i].priceMantissa = 2000 - i;
        in.bids[i].qty = 1;
    }

    // ASK: 3000,3001,...,3009
    in.askCountRaw = N;
    in.asksCopied  = N;
    for (int i = 0; i < N; ++i) {
        in.asks[i].priceMantissa = 3000 + i;
        in.asks[i].qty = 1;
    }

    BookSnapshot out{};
    aggregateMboWindowToMbpTopN(in, out);

    EXPECT_EQ(out.instrumentId, 7u);
    EXPECT_EQ(out.exchangeTsNs, 777u);

    ASSERT_EQ(out.bidCount, BookSnapshot::DEPTH);
    ASSERT_EQ(out.askCount, BookSnapshot::DEPTH);

    // Top-5 bids esperados: 2000..1996
    for (int i = 0; i < BookSnapshot::DEPTH; ++i) {
        const int64_t expectedPx = 2000 - i;
        EXPECT_EQ(out.bids[i].price, expectedPx) << "i=" << i;
        EXPECT_EQ(out.bids[i].qty, 1) << "i=" << i;
    }

    // Top-5 asks esperados: 3000..3004
    for (int i = 0; i < BookSnapshot::DEPTH; ++i) {
        const int64_t expectedPx = 3000 + i;
        EXPECT_EQ(out.asks[i].price, expectedPx) << "i=" << i;
        EXPECT_EQ(out.asks[i].qty, 1) << "i=" << i;
    }
}

===== FILE: /workspaces/MarketHub.B3Connector/tests/md/FakePublishSink.hpp =====
#pragma once

#include "../../b3-md-connector/src/publishing/IPublishSink.hpp"
#include "../../b3-md-connector/src/publishing/PublishEvent.hpp"

#include <mutex>
#include <string>
#include <vector>
#include <cstdint>

namespace b3::md::testsupport {

  struct CapturedPublish {
    uint32_t shardId{0};
    std::string topic;
    std::string bytes;
  };

  class FakePublishSink final : public b3::md::publishing::IPublishSink {
   public:
    bool tryPublish(uint32_t shardId,
                    const b3::md::publishing::PublishEvent &ev) noexcept override {
      // En tests está OK usar mutex/vector (no es hot path prod)
      std::lock_guard<std::mutex> g(m_);
      CapturedPublish c;
      c.shardId = shardId;
      c.topic.assign(ev.topic, ev.topic + ev.topicLen);
      c.bytes.assign(reinterpret_cast<const char *>(ev.bytes), ev.size);
      msgs_.push_back(std::move(c));
      return true;
    }

    size_t count() const {
      std::lock_guard<std::mutex> g(m_);
      return msgs_.size();
    }

    CapturedPublish at(size_t i) const {
      std::lock_guard<std::mutex> g(m_);
      return msgs_.at(i);
    }

   private:
    mutable std::mutex m_;
    std::vector<CapturedPublish> msgs_;
  };

} // namespace b3::md::testsupport

===== FILE: /workspaces/MarketHub.B3Connector/tests/md/test_md_core.cpp =====
#include "../../b3-md-connector/src/core/BookSnapshot.hpp"
#include "../../b3-md-connector/src/core/SnapshotQueueSpsc.hpp"
#include <gtest/gtest.h>
#include <thread>
#include <vector>
#include <atomic>

using b3::md::BookSnapshot;
using b3::md::SnapshotQueueSpsc;

// ============================================================================
// TopNBookSnapshot Tests
// ============================================================================

TEST(TopNBookSnapshotTests, IsTriviallyCopyable) {
    EXPECT_TRUE(std::is_trivially_copyable_v<BookSnapshot>);
}

TEST(TopNBookSnapshotTests, IsTriviallyDestructible) {
    EXPECT_TRUE(std::is_trivially_destructible_v<BookSnapshot>);
}

TEST(TopNBookSnapshotTests, DefaultConstruction) {
    BookSnapshot s{};

    EXPECT_EQ(s.instrumentId, 0);
    EXPECT_EQ(s.exchangeTsNs, 0);
    EXPECT_EQ(s.bidCount, 0);
    EXPECT_EQ(s.askCount, 0);

    // Verify all levels are zeroed
    for (int i = 0; i < 5; ++i) {
        EXPECT_EQ(s.bids[i].price, 0);
        EXPECT_EQ(s.bids[i].qty, 0);
        EXPECT_EQ(s.asks[i].price, 0);
        EXPECT_EQ(s.asks[i].qty, 0);
    }
}

TEST(TopNBookSnapshotTests, DataAssignment) {
    BookSnapshot snapshot;

    snapshot.instrumentId = 12345;
    snapshot.exchangeTsNs = 1234567890123456789ULL;
    snapshot.bidCount = 3;
    snapshot.askCount = 2;

    // Set bid levels
    snapshot.bids[0] = {100000, 1000};
    snapshot.bids[1] = {99500, 1500};
    snapshot.bids[2] = {99000, 2000};

    // Set ask levels
    snapshot.asks[0] = {100500, 800};
    snapshot.asks[1] = {101000, 1200};

    EXPECT_EQ(snapshot.instrumentId, 12345);
    EXPECT_EQ(snapshot.exchangeTsNs, 1234567890123456789ULL);
    EXPECT_EQ(snapshot.bidCount, 3);
    EXPECT_EQ(snapshot.askCount, 2);

    EXPECT_EQ(snapshot.bids[0].price, 100000);
    EXPECT_EQ(snapshot.bids[0].qty, 1000);
    EXPECT_EQ(snapshot.bids[1].price, 99500);
    EXPECT_EQ(snapshot.bids[1].qty, 1500);
    EXPECT_EQ(snapshot.bids[2].price, 99000);
    EXPECT_EQ(snapshot.bids[2].qty, 2000);

    EXPECT_EQ(snapshot.asks[0].price, 100500);
    EXPECT_EQ(snapshot.asks[0].qty, 800);
    EXPECT_EQ(snapshot.asks[1].price, 101000);
    EXPECT_EQ(snapshot.asks[1].qty, 1200);
}

// ============================================================================
// SnapshotQueueSpsc Tests - Single Thread
// ============================================================================

TEST(SnapshotQueueSpscTests, EmptyQueueBehavior) {
    SnapshotQueueSpsc<BookSnapshot, 1024> q;
    BookSnapshot out{};

    EXPECT_EQ(q.size_approx(), 0);
    EXPECT_FALSE(q.try_pop(out));
}

TEST(SnapshotQueueSpscTests, FifoSingleThread) {
    SnapshotQueueSpsc<BookSnapshot, 1024> q;
    BookSnapshot a{}, b{}, out{};
    a.instrumentId = 10;
    b.instrumentId = 11;

    EXPECT_TRUE(q.try_push(a));
    EXPECT_TRUE(q.try_push(b));
    EXPECT_GE(q.size_approx(), 2);

    EXPECT_TRUE(q.try_pop(out));
    EXPECT_EQ(out.instrumentId, 10);

    EXPECT_TRUE(q.try_pop(out));
    EXPECT_EQ(out.instrumentId, 11);

    EXPECT_FALSE(q.try_pop(out));
    EXPECT_EQ(q.size_approx(), 0);
}

TEST(SnapshotQueueSpscTests, PushMultipleElements) {
    SnapshotQueueSpsc<int, 16> queue;

    for (int i = 0; i < 10; ++i) {
        EXPECT_TRUE(queue.try_push(i));
    }

    EXPECT_EQ(queue.size_approx(), 10);

    for (int i = 0; i < 10; ++i) {
        int value;
        EXPECT_TRUE(queue.try_pop(value));
        EXPECT_EQ(value, i);
    }

    EXPECT_EQ(queue.size_approx(), 0);
}

TEST(SnapshotQueueSpscTests, QueueFullBehavior) {
    SnapshotQueueSpsc<int, 4> queue;

    // Fill the queue to capacity
    EXPECT_TRUE(queue.try_push(1));
    EXPECT_TRUE(queue.try_push(2));
    EXPECT_TRUE(queue.try_push(3));
    EXPECT_TRUE(queue.try_push(4));

    EXPECT_EQ(queue.size_approx(), 4);

    // Next push should fail (queue is full)
    EXPECT_FALSE(queue.try_push(5));

    // Pop one element
    int value;
    EXPECT_TRUE(queue.try_pop(value));
    EXPECT_EQ(value, 1);

    // Now we should be able to push again
    EXPECT_TRUE(queue.try_push(5));
}

TEST(SnapshotQueueSpscTests, WrapAroundBehavior) {
    SnapshotQueueSpsc<int, 4> queue;

    // Fill and empty multiple times to test wrap-around
    for (int cycle = 0; cycle < 3; ++cycle) {
        // Fill
        for (int i = 0; i < 4; ++i) {
            EXPECT_TRUE(queue.try_push(cycle * 10 + i));
        }

        // Empty
        for (int i = 0; i < 4; ++i) {
            int value;
            EXPECT_TRUE(queue.try_pop(value));
            EXPECT_EQ(value, cycle * 10 + i);
        }

        EXPECT_EQ(queue.size_approx(), 0);
    }
}

// ============================================================================
// SnapshotQueueSpsc Tests - Multi-threaded SPSC
// ============================================================================

TEST(SnapshotQueueSpscTests, SpscThreadedNoCorruption) {
    constexpr int N = 200000;
    SnapshotQueueSpsc<BookSnapshot, 4096> q;

    std::atomic<bool> done{false};
    std::atomic<int> produced{0};
    std::atomic<int> consumed{0};

    // Producer thread
    std::thread prod([&]{
        for (int i = 0; i < N; ) {
            BookSnapshot s{};
            s.instrumentId = 77;
            s.exchangeTsNs = static_cast<uint64_t>(i);
            if (q.try_push(s)) {
                ++i;
                ++produced;
            }
        }
        done.store(true, std::memory_order_release);
    });

    // Consumer thread
    std::thread cons([&]{
        uint64_t last = 0;
        bool hasLast = false;

        BookSnapshot s{};
        while (!done.load(std::memory_order_acquire) || q.size_approx() > 0) {
            if (q.try_pop(s)) {
                if (hasLast) {
                    // FIFO: in a single producer, exchangeTsNs must be increasing
                    EXPECT_EQ(s.exchangeTsNs, last + 1);
                } else {
                    hasLast = true;
                }
                last = s.exchangeTsNs;
                ++consumed;
            }
        }
        EXPECT_EQ(consumed.load(), produced.load());
    });

    prod.join();
    cons.join();
}

TEST(SnapshotQueueSpscTests, SpscThreadedStress) {
    constexpr int N = 100000;
    SnapshotQueueSpsc<int, 256> q;

    std::atomic<bool> producerDone{false};
    std::vector<int> consumedValues;
    consumedValues.reserve(N);

    // Producer thread
    std::thread producer([&]() {
        for (int i = 0; i < N; ++i) {
            while (!q.try_push(i)) {
                std::this_thread::yield();
            }
        }
        producerDone.store(true, std::memory_order_release);
    });

    // Consumer thread
    std::thread consumer([&]() {
        int value;
        while (!producerDone.load(std::memory_order_acquire) || q.size_approx() > 0) {
            if (q.try_pop(value)) {
                consumedValues.push_back(value);
            } else {
                std::this_thread::yield();
            }
        }
    });

    producer.join();
    consumer.join();

    // Verify all values were consumed in order
    EXPECT_EQ(consumedValues.size(), N);
    for (int i = 0; i < N; ++i) {
        EXPECT_EQ(consumedValues[i], i);
    }

    EXPECT_EQ(q.size_approx(), 0);
}

===== FILE: /workspaces/MarketHub.B3Connector/tests/md/test_mbo_to_mbp_aggregator.cpp =====
#include <gtest/gtest.h>

#include "../../b3-md-connector/src/core/OrdersSnapshot.hpp"
#include "../../b3-md-connector/src/core/BookSnapshot.hpp"
#include "../../b3-md-connector/src/core/MboToMbpAggregator.hpp"

using namespace b3::md;

TEST(MboToMbpAggregatorTests, AggregatesSamePriceIntoSingleLevel) {
    OrdersSnapshot in{};
    in.instrumentId = 42;
    in.exchangeTsNs = 123;

    // Bid side: 3 órdenes mismo precio, + 1 orden otro precio
    in.bidsCopied = 4;
    in.bids[0] = { .priceMantissa = 1000, .qty = 10 };
    in.bids[1] = { .priceMantissa = 1000, .qty = 20 };
    in.bids[2] = { .priceMantissa = 1000, .qty = 30 };
    in.bids[3] = { .priceMantissa =  900, .qty =  5 };

    // Ask side: 2 precios distintos
    in.asksCopied = 3;
    in.asks[0] = { .priceMantissa = 1100, .qty = 7 };
    in.asks[1] = { .priceMantissa = 1100, .qty = 8 };
    in.asks[2] = { .priceMantissa = 1200, .qty = 1 };

    BookSnapshot out{};
    aggregateMboWindowToMbpTopN(in, out);

    EXPECT_EQ(out.instrumentId, 42u);
    EXPECT_EQ(out.exchangeTsNs, 123u);

    ASSERT_EQ(out.bidCount, 2u);
    EXPECT_EQ(out.bids[0].price, 1000);
    EXPECT_EQ(out.bids[0].qty,   60);
    EXPECT_EQ(out.bids[1].price,  900);
    EXPECT_EQ(out.bids[1].qty,    5);

    ASSERT_EQ(out.askCount, 2u);
    EXPECT_EQ(out.asks[0].price, 1100);
    EXPECT_EQ(out.asks[0].qty,   15);
    EXPECT_EQ(out.asks[1].price, 1200);
    EXPECT_EQ(out.asks[1].qty,    1);
}

TEST(MboToMbpAggregatorTests, ProducesAtMostTopNLevels) {
    OrdersSnapshot in{};
    in.instrumentId = 1;
    in.exchangeTsNs = 1;

    // Generar 10 precios distintos (más que Top-5)
    in.bidsCopied = 10;
    for (int i = 0; i < 10; ++i) {
        in.bids[i] = { .priceMantissa = 1000 - i, .qty = 1 };
    }

    in.asksCopied = 10;
    for (int i = 0; i < 10; ++i) {
        in.asks[i] = { .priceMantissa = 2000 + i, .qty = 1 };
    }

    BookSnapshot out{};
    aggregateMboWindowToMbpTopN(in, out);

    EXPECT_EQ(out.bidCount, BookSnapshot::DEPTH);
    EXPECT_EQ(out.askCount, BookSnapshot::DEPTH);

    // Solo chequeamos que no exceda DEPTH y que los primeros existan
    EXPECT_NE(out.bids[0].price, 0);
    EXPECT_NE(out.asks[0].price, 0);
}

TEST(MboToMbpAggregatorTests, IgnoresZeroQtyOrders) {
    OrdersSnapshot in{};
    in.instrumentId = 9;
    in.exchangeTsNs = 9;

    in.bidsCopied = 3;
    in.bids[0] = { .priceMantissa = 1000, .qty = 0 };   // ignorar
    in.bids[1] = { .priceMantissa = 1000, .qty = 10 };  // sumar
    in.bids[2] = { .priceMantissa =  900, .qty = 0 };   // ignorar

    in.asksCopied = 0;

    BookSnapshot out{};
